"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@prisma";
exports.ids = ["vendor-chunks/@prisma"];
exports.modules = {

/***/ "(rsc)/./node_modules/@prisma/client-runtime-utils/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@prisma/client-runtime-utils/dist/index.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod2) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod2);\n\n// src/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  AnyNull: () => AnyNull,\n  AnyNullClass: () => AnyNullClass,\n  DbNull: () => DbNull,\n  DbNullClass: () => DbNullClass,\n  Decimal: () => Decimal,\n  JsonNull: () => JsonNull,\n  JsonNullClass: () => JsonNullClass,\n  NullTypes: () => NullTypes,\n  ObjectEnumValue: () => ObjectEnumValue,\n  PrismaClientInitializationError: () => PrismaClientInitializationError,\n  PrismaClientKnownRequestError: () => PrismaClientKnownRequestError,\n  PrismaClientRustError: () => PrismaClientRustError,\n  PrismaClientRustPanicError: () => PrismaClientRustPanicError,\n  PrismaClientUnknownRequestError: () => PrismaClientUnknownRequestError,\n  PrismaClientValidationError: () => PrismaClientValidationError,\n  Sql: () => Sql,\n  empty: () => empty,\n  hasBatchIndex: () => hasBatchIndex,\n  isAnyNull: () => isAnyNull,\n  isDbNull: () => isDbNull,\n  isJsonNull: () => isJsonNull,\n  join: () => join,\n  raw: () => raw,\n  sql: () => sql\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// src/errors/ErrorWithBatchIndex.ts\nfunction hasBatchIndex(value) {\n  return typeof value[\"batchRequestIdx\"] === \"number\";\n}\n\n// src/errors/setClassName.ts\nfunction setClassName(classObject, name) {\n  Object.defineProperty(classObject, \"name\", {\n    value: name,\n    configurable: true\n  });\n}\n\n// src/errors/PrismaClientInitializationError.ts\nvar PrismaClientInitializationError = class _PrismaClientInitializationError extends Error {\n  clientVersion;\n  errorCode;\n  retryable;\n  constructor(message, clientVersion, errorCode) {\n    super(message);\n    this.name = \"PrismaClientInitializationError\";\n    this.clientVersion = clientVersion;\n    this.errorCode = errorCode;\n    Error.captureStackTrace(_PrismaClientInitializationError);\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientInitializationError\";\n  }\n};\nsetClassName(PrismaClientInitializationError, \"PrismaClientInitializationError\");\n\n// src/errors/PrismaClientKnownRequestError.ts\nvar PrismaClientKnownRequestError = class extends Error {\n  code;\n  meta;\n  clientVersion;\n  batchRequestIdx;\n  constructor(message, { code, clientVersion, meta, batchRequestIdx }) {\n    super(message);\n    this.name = \"PrismaClientKnownRequestError\";\n    this.code = code;\n    this.clientVersion = clientVersion;\n    this.meta = meta;\n    Object.defineProperty(this, \"batchRequestIdx\", {\n      value: batchRequestIdx,\n      enumerable: false,\n      writable: true\n    });\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientKnownRequestError\";\n  }\n};\nsetClassName(PrismaClientKnownRequestError, \"PrismaClientKnownRequestError\");\n\n// src/errors/log.ts\nfunction getBacktrace(log3) {\n  if (log3.fields?.message) {\n    let str = log3.fields?.message;\n    if (log3.fields?.file) {\n      str += ` in ${log3.fields.file}`;\n      if (log3.fields?.line) {\n        str += `:${log3.fields.line}`;\n      }\n      if (log3.fields?.column) {\n        str += `:${log3.fields.column}`;\n      }\n    }\n    if (log3.fields?.reason) {\n      str += `\n${log3.fields?.reason}`;\n    }\n    return str;\n  }\n  return \"Unknown error\";\n}\nfunction isPanic(err) {\n  return err.fields?.message === \"PANIC\";\n}\n\n// src/errors/PrismaClientRustError.ts\nvar PrismaClientRustError = class extends Error {\n  clientVersion;\n  _isPanic;\n  constructor({ clientVersion, error }) {\n    const backtrace = getBacktrace(error);\n    super(backtrace ?? \"Unknown error\");\n    this._isPanic = isPanic(error);\n    this.clientVersion = clientVersion;\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientRustError\";\n  }\n  isPanic() {\n    return this._isPanic;\n  }\n};\nsetClassName(PrismaClientRustError, \"PrismaClientRustError\");\n\n// src/errors/PrismaClientRustPanicError.ts\nvar PrismaClientRustPanicError = class extends Error {\n  clientVersion;\n  constructor(message, clientVersion) {\n    super(message);\n    this.name = \"PrismaClientRustPanicError\";\n    this.clientVersion = clientVersion;\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientRustPanicError\";\n  }\n};\nsetClassName(PrismaClientRustPanicError, \"PrismaClientRustPanicError\");\n\n// src/errors/PrismaClientUnknownRequestError.ts\nvar PrismaClientUnknownRequestError = class extends Error {\n  clientVersion;\n  batchRequestIdx;\n  constructor(message, { clientVersion, batchRequestIdx }) {\n    super(message);\n    this.name = \"PrismaClientUnknownRequestError\";\n    this.clientVersion = clientVersion;\n    Object.defineProperty(this, \"batchRequestIdx\", {\n      value: batchRequestIdx,\n      writable: true,\n      enumerable: false\n    });\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientUnknownRequestError\";\n  }\n};\nsetClassName(PrismaClientUnknownRequestError, \"PrismaClientUnknownRequestError\");\n\n// src/errors/PrismaClientValidationError.ts\nvar PrismaClientValidationError = class extends Error {\n  name = \"PrismaClientValidationError\";\n  clientVersion;\n  constructor(message, { clientVersion }) {\n    super(message);\n    this.clientVersion = clientVersion;\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientValidationError\";\n  }\n};\nsetClassName(PrismaClientValidationError, \"PrismaClientValidationError\");\n\n// src/nullTypes.ts\nvar secret = Symbol();\nvar representations = /* @__PURE__ */ new WeakMap();\nvar ObjectEnumValue = class {\n  constructor(arg) {\n    if (arg === secret) {\n      representations.set(this, `Prisma.${this._getName()}`);\n    } else {\n      representations.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);\n    }\n  }\n  _getName() {\n    return this.constructor.name;\n  }\n  toString() {\n    return representations.get(this);\n  }\n};\nfunction setClassName2(classObject, name) {\n  Object.defineProperty(classObject, \"name\", {\n    value: name,\n    configurable: true\n  });\n}\nvar NullTypesEnumValue = class extends ObjectEnumValue {\n  _getNamespace() {\n    return \"NullTypes\";\n  }\n};\nvar DbNullClass = class extends NullTypesEnumValue {\n  // Phantom private property to prevent structural type equality\n  // eslint-disable-next-line no-unused-private-class-members\n  #_brand_DbNull;\n};\nsetClassName2(DbNullClass, \"DbNull\");\nvar JsonNullClass = class extends NullTypesEnumValue {\n  // Phantom private property to prevent structural type equality\n  // eslint-disable-next-line no-unused-private-class-members\n  #_brand_JsonNull;\n};\nsetClassName2(JsonNullClass, \"JsonNull\");\nvar AnyNullClass = class extends NullTypesEnumValue {\n  // Phantom private property to prevent structural type equality\n  // eslint-disable-next-line no-unused-private-class-members\n  #_brand_AnyNull;\n};\nsetClassName2(AnyNullClass, \"AnyNull\");\nvar NullTypes = {\n  DbNull: DbNullClass,\n  JsonNull: JsonNullClass,\n  AnyNull: AnyNullClass\n};\nvar DbNull = new DbNullClass(secret);\nvar JsonNull = new JsonNullClass(secret);\nvar AnyNull = new AnyNullClass(secret);\nfunction isDbNull(value) {\n  return value === DbNull;\n}\nfunction isJsonNull(value) {\n  return value === JsonNull;\n}\nfunction isAnyNull(value) {\n  return value === AnyNull;\n}\n\n// ../../node_modules/.pnpm/decimal.js@10.5.0/node_modules/decimal.js/decimal.mjs\nvar EXP_LIMIT = 9e15;\nvar MAX_DIGITS = 1e9;\nvar NUMERALS = \"0123456789abcdef\";\nvar LN10 = \"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058\";\nvar PI = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789\";\nvar DEFAULTS = {\n  // These values must be integers within the stated ranges (inclusive).\n  // Most of these values can be changed at run-time using the `Decimal.config` method.\n  // The maximum number of significant digits of the result of a calculation or base conversion.\n  // E.g. `Decimal.config({ precision: 20 });`\n  precision: 20,\n  // 1 to MAX_DIGITS\n  // The rounding mode used when rounding to `precision`.\n  //\n  // ROUND_UP         0 Away from zero.\n  // ROUND_DOWN       1 Towards zero.\n  // ROUND_CEIL       2 Towards +Infinity.\n  // ROUND_FLOOR      3 Towards -Infinity.\n  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n  //\n  // E.g.\n  // `Decimal.rounding = 4;`\n  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\n  rounding: 4,\n  // 0 to 8\n  // The modulo mode used when calculating the modulus: a mod n.\n  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\n  // The remainder (r) is calculated as: r = a - n * q.\n  //\n  // UP         0 The remainder is positive if the dividend is negative, else is negative.\n  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\n  // FLOOR      3 The remainder has the same sign as the divisor (Python %).\n  // HALF_EVEN  6 The IEEE 754 remainder function.\n  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\n  //\n  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\n  // division (9) are commonly used for the modulus operation. The other rounding modes can also\n  // be used, but they may not give useful results.\n  modulo: 1,\n  // 0 to 9\n  // The exponent value at and beneath which `toString` returns exponential notation.\n  // JavaScript numbers: -7\n  toExpNeg: -7,\n  // 0 to -EXP_LIMIT\n  // The exponent value at and above which `toString` returns exponential notation.\n  // JavaScript numbers: 21\n  toExpPos: 21,\n  // 0 to EXP_LIMIT\n  // The minimum exponent value, beneath which underflow to zero occurs.\n  // JavaScript numbers: -324  (5e-324)\n  minE: -EXP_LIMIT,\n  // -1 to -EXP_LIMIT\n  // The maximum exponent value, above which overflow to Infinity occurs.\n  // JavaScript numbers: 308  (1.7976931348623157e+308)\n  maxE: EXP_LIMIT,\n  // 1 to EXP_LIMIT\n  // Whether to use cryptographically-secure random number generation, if available.\n  crypto: false\n  // true/false\n};\nvar inexact;\nvar quadrant;\nvar external = true;\nvar decimalError = \"[DecimalError] \";\nvar invalidArgument = decimalError + \"Invalid argument: \";\nvar precisionLimitExceeded = decimalError + \"Precision limit exceeded\";\nvar cryptoUnavailable = decimalError + \"crypto unavailable\";\nvar tag = \"[object Decimal]\";\nvar mathfloor = Math.floor;\nvar mathpow = Math.pow;\nvar isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i;\nvar isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i;\nvar isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i;\nvar isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\nvar BASE = 1e7;\nvar LOG_BASE = 7;\nvar MAX_SAFE_INTEGER = 9007199254740991;\nvar LN10_PRECISION = LN10.length - 1;\nvar PI_PRECISION = PI.length - 1;\nvar P = { toStringTag: tag };\nP.absoluteValue = P.abs = function() {\n  var x = new this.constructor(this);\n  if (x.s < 0) x.s = 1;\n  return finalise(x);\n};\nP.ceil = function() {\n  return finalise(new this.constructor(this), this.e + 1, 2);\n};\nP.clampedTo = P.clamp = function(min2, max2) {\n  var k, x = this, Ctor = x.constructor;\n  min2 = new Ctor(min2);\n  max2 = new Ctor(max2);\n  if (!min2.s || !max2.s) return new Ctor(NaN);\n  if (min2.gt(max2)) throw Error(invalidArgument + max2);\n  k = x.cmp(min2);\n  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);\n};\nP.comparedTo = P.cmp = function(y) {\n  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;\n  if (!xd || !yd) {\n    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\n  }\n  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\n  if (xs !== ys) return xs;\n  if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\n  xdL = xd.length;\n  ydL = yd.length;\n  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\n    if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\n  }\n  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\n};\nP.cosine = P.cos = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.d) return new Ctor(NaN);\n  if (!x.d[0]) return new Ctor(1);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n  Ctor.rounding = 1;\n  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\n};\nP.cubeRoot = P.cbrt = function() {\n  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero()) return new Ctor(x);\n  external = false;\n  s = x.s * mathpow(x.s * x, 1 / 3);\n  if (!s || Math.abs(s) == 1 / 0) {\n    n = digitsToString(x.d);\n    e = x.e;\n    if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? \"0\" : \"00\";\n    s = mathpow(n, 1 / 3);\n    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\n    if (s == 1 / 0) {\n      n = \"5e\" + e;\n    } else {\n      n = s.toExponential();\n      n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n    }\n    r = new Ctor(n);\n    r.s = x.s;\n  } else {\n    r = new Ctor(s.toString());\n  }\n  sd = (e = Ctor.precision) + 3;\n  for (; ; ) {\n    t = r;\n    t3 = t.times(t).times(t);\n    t3plusx = t3.plus(x);\n    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n      n = n.slice(sd - 3, sd + 1);\n      if (n == \"9999\" || !rep && n == \"4999\") {\n        if (!rep) {\n          finalise(t, e + 1, 0);\n          if (t.times(t).times(t).eq(x)) {\n            r = t;\n            break;\n          }\n        }\n        sd += 4;\n        rep = 1;\n      } else {\n        if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n          finalise(r, e + 1, 1);\n          m = !r.times(r).times(r).eq(x);\n        }\n        break;\n      }\n    }\n  }\n  external = true;\n  return finalise(r, e, Ctor.rounding, m);\n};\nP.decimalPlaces = P.dp = function() {\n  var w, d = this.d, n = NaN;\n  if (d) {\n    w = d.length - 1;\n    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\n    w = d[w];\n    if (w) for (; w % 10 == 0; w /= 10) n--;\n    if (n < 0) n = 0;\n  }\n  return n;\n};\nP.dividedBy = P.div = function(y) {\n  return divide(this, new this.constructor(y));\n};\nP.dividedToIntegerBy = P.divToInt = function(y) {\n  var x = this, Ctor = x.constructor;\n  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\n};\nP.equals = P.eq = function(y) {\n  return this.cmp(y) === 0;\n};\nP.floor = function() {\n  return finalise(new this.constructor(this), this.e + 1, 3);\n};\nP.greaterThan = P.gt = function(y) {\n  return this.cmp(y) > 0;\n};\nP.greaterThanOrEqualTo = P.gte = function(y) {\n  var k = this.cmp(y);\n  return k == 1 || k === 0;\n};\nP.hyperbolicCosine = P.cosh = function() {\n  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);\n  if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\n  if (x.isZero()) return one;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n  Ctor.rounding = 1;\n  len = x.d.length;\n  if (len < 32) {\n    k = Math.ceil(len / 3);\n    n = (1 / tinyPow(4, k)).toString();\n  } else {\n    k = 16;\n    n = \"2.3283064365386962890625e-10\";\n  }\n  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\n  var cosh2_x, i = k, d8 = new Ctor(8);\n  for (; i--; ) {\n    cosh2_x = x.times(x);\n    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\n  }\n  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\nP.hyperbolicSine = P.sinh = function() {\n  var k, pr, rm, len, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero()) return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n  Ctor.rounding = 1;\n  len = x.d.length;\n  if (len < 3) {\n    x = taylorSeries(Ctor, 2, x, x, true);\n  } else {\n    k = 1.4 * Math.sqrt(len);\n    k = k > 16 ? 16 : k | 0;\n    x = x.times(1 / tinyPow(5, k));\n    x = taylorSeries(Ctor, 2, x, x, true);\n    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n    for (; k--; ) {\n      sinh2_x = x.times(x);\n      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\n    }\n  }\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(x, pr, rm, true);\n};\nP.hyperbolicTangent = P.tanh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite()) return new Ctor(x.s);\n  if (x.isZero()) return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 7;\n  Ctor.rounding = 1;\n  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\n};\nP.inverseCosine = P.acos = function() {\n  var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;\n  if (k !== -1) {\n    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);\n  }\n  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\n  Ctor.precision = pr + 6;\n  Ctor.rounding = 1;\n  x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.times(2);\n};\nP.inverseHyperbolicCosine = P.acosh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\n  if (!x.isFinite()) return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\n  Ctor.rounding = 1;\n  external = false;\n  x = x.times(x).minus(1).sqrt().plus(x);\n  external = true;\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.ln();\n};\nP.inverseHyperbolicSine = P.asinh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero()) return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\n  Ctor.rounding = 1;\n  external = false;\n  x = x.times(x).plus(1).sqrt().plus(x);\n  external = true;\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.ln();\n};\nP.inverseHyperbolicTangent = P.atanh = function() {\n  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;\n  if (!x.isFinite()) return new Ctor(NaN);\n  if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  xsd = x.sd();\n  if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\n  Ctor.precision = wpr = xsd - x.e;\n  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\n  Ctor.precision = pr + 4;\n  Ctor.rounding = 1;\n  x = x.ln();\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.times(0.5);\n};\nP.inverseSine = P.asin = function() {\n  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;\n  if (x.isZero()) return new Ctor(x);\n  k = x.abs().cmp(1);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (k !== -1) {\n    if (k === 0) {\n      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n      halfPi.s = x.s;\n      return halfPi;\n    }\n    return new Ctor(NaN);\n  }\n  Ctor.precision = pr + 6;\n  Ctor.rounding = 1;\n  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.times(2);\n};\nP.inverseTangent = P.atan = function() {\n  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;\n  if (!x.isFinite()) {\n    if (!x.s) return new Ctor(NaN);\n    if (pr + 4 <= PI_PRECISION) {\n      r = getPi(Ctor, pr + 4, rm).times(0.5);\n      r.s = x.s;\n      return r;\n    }\n  } else if (x.isZero()) {\n    return new Ctor(x);\n  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\n    r = getPi(Ctor, pr + 4, rm).times(0.25);\n    r.s = x.s;\n    return r;\n  }\n  Ctor.precision = wpr = pr + 10;\n  Ctor.rounding = 1;\n  k = Math.min(28, wpr / LOG_BASE + 2 | 0);\n  for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));\n  external = false;\n  j = Math.ceil(wpr / LOG_BASE);\n  n = 1;\n  x2 = x.times(x);\n  r = new Ctor(x);\n  px = x;\n  for (; i !== -1; ) {\n    px = px.times(x2);\n    t = r.minus(px.div(n += 2));\n    px = px.times(x2);\n    r = t.plus(px.div(n += 2));\n    if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--; ) ;\n  }\n  if (k) r = r.times(2 << k - 1);\n  external = true;\n  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\nP.isFinite = function() {\n  return !!this.d;\n};\nP.isInteger = P.isInt = function() {\n  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\n};\nP.isNaN = function() {\n  return !this.s;\n};\nP.isNegative = P.isNeg = function() {\n  return this.s < 0;\n};\nP.isPositive = P.isPos = function() {\n  return this.s > 0;\n};\nP.isZero = function() {\n  return !!this.d && this.d[0] === 0;\n};\nP.lessThan = P.lt = function(y) {\n  return this.cmp(y) < 0;\n};\nP.lessThanOrEqualTo = P.lte = function(y) {\n  return this.cmp(y) < 1;\n};\nP.logarithm = P.log = function(base) {\n  var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;\n  if (base == null) {\n    base = new Ctor(10);\n    isBase10 = true;\n  } else {\n    base = new Ctor(base);\n    d = base.d;\n    if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\n    isBase10 = base.eq(10);\n  }\n  d = arg.d;\n  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\n    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\n  }\n  if (isBase10) {\n    if (d.length > 1) {\n      inf = true;\n    } else {\n      for (k = d[0]; k % 10 === 0; ) k /= 10;\n      inf = k !== 1;\n    }\n  }\n  external = false;\n  sd = pr + guard;\n  num = naturalLogarithm(arg, sd);\n  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n  r = divide(num, denominator, sd, 1);\n  if (checkRoundingDigits(r.d, k = pr, rm)) {\n    do {\n      sd += 10;\n      num = naturalLogarithm(arg, sd);\n      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n      r = divide(num, denominator, sd, 1);\n      if (!inf) {\n        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\n          r = finalise(r, pr + 1, 0);\n        }\n        break;\n      }\n    } while (checkRoundingDigits(r.d, k += 10, rm));\n  }\n  external = true;\n  return finalise(r, pr, rm);\n};\nP.minus = P.sub = function(y) {\n  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.d) {\n    if (!x.s || !y.s) y = new Ctor(NaN);\n    else if (x.d) y.s = -y.s;\n    else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\n    return y;\n  }\n  if (x.s != y.s) {\n    y.s = -y.s;\n    return x.plus(y);\n  }\n  xd = x.d;\n  yd = y.d;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (!xd[0] || !yd[0]) {\n    if (yd[0]) y.s = -y.s;\n    else if (xd[0]) y = new Ctor(x);\n    else return new Ctor(rm === 3 ? -0 : 0);\n    return external ? finalise(y, pr, rm) : y;\n  }\n  e = mathfloor(y.e / LOG_BASE);\n  xe = mathfloor(x.e / LOG_BASE);\n  xd = xd.slice();\n  k = xe - e;\n  if (k) {\n    xLTy = k < 0;\n    if (xLTy) {\n      d = xd;\n      k = -k;\n      len = yd.length;\n    } else {\n      d = yd;\n      e = xe;\n      len = xd.length;\n    }\n    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\n    if (k > i) {\n      k = i;\n      d.length = 1;\n    }\n    d.reverse();\n    for (i = k; i--; ) d.push(0);\n    d.reverse();\n  } else {\n    i = xd.length;\n    len = yd.length;\n    xLTy = i < len;\n    if (xLTy) len = i;\n    for (i = 0; i < len; i++) {\n      if (xd[i] != yd[i]) {\n        xLTy = xd[i] < yd[i];\n        break;\n      }\n    }\n    k = 0;\n  }\n  if (xLTy) {\n    d = xd;\n    xd = yd;\n    yd = d;\n    y.s = -y.s;\n  }\n  len = xd.length;\n  for (i = yd.length - len; i > 0; --i) xd[len++] = 0;\n  for (i = yd.length; i > k; ) {\n    if (xd[--i] < yd[i]) {\n      for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1;\n      --xd[j];\n      xd[i] += BASE;\n    }\n    xd[i] -= yd[i];\n  }\n  for (; xd[--len] === 0; ) xd.pop();\n  for (; xd[0] === 0; xd.shift()) --e;\n  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\n  y.d = xd;\n  y.e = getBase10Exponent(xd, e);\n  return external ? finalise(y, pr, rm) : y;\n};\nP.modulo = P.mod = function(y) {\n  var q, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\n  if (!y.d || x.d && !x.d[0]) {\n    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\n  }\n  external = false;\n  if (Ctor.modulo == 9) {\n    q = divide(x, y.abs(), 0, 3, 1);\n    q.s *= y.s;\n  } else {\n    q = divide(x, y, 0, Ctor.modulo, 1);\n  }\n  q = q.times(y);\n  external = true;\n  return x.minus(q);\n};\nP.naturalExponential = P.exp = function() {\n  return naturalExponential(this);\n};\nP.naturalLogarithm = P.ln = function() {\n  return naturalLogarithm(this);\n};\nP.negated = P.neg = function() {\n  var x = new this.constructor(this);\n  x.s = -x.s;\n  return finalise(x);\n};\nP.plus = P.add = function(y) {\n  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.d) {\n    if (!x.s || !y.s) y = new Ctor(NaN);\n    else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\n    return y;\n  }\n  if (x.s != y.s) {\n    y.s = -y.s;\n    return x.minus(y);\n  }\n  xd = x.d;\n  yd = y.d;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (!xd[0] || !yd[0]) {\n    if (!yd[0]) y = new Ctor(x);\n    return external ? finalise(y, pr, rm) : y;\n  }\n  k = mathfloor(x.e / LOG_BASE);\n  e = mathfloor(y.e / LOG_BASE);\n  xd = xd.slice();\n  i = k - e;\n  if (i) {\n    if (i < 0) {\n      d = xd;\n      i = -i;\n      len = yd.length;\n    } else {\n      d = yd;\n      e = k;\n      len = xd.length;\n    }\n    k = Math.ceil(pr / LOG_BASE);\n    len = k > len ? k + 1 : len + 1;\n    if (i > len) {\n      i = len;\n      d.length = 1;\n    }\n    d.reverse();\n    for (; i--; ) d.push(0);\n    d.reverse();\n  }\n  len = xd.length;\n  i = yd.length;\n  if (len - i < 0) {\n    i = len;\n    d = yd;\n    yd = xd;\n    xd = d;\n  }\n  for (carry = 0; i; ) {\n    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\n    xd[i] %= BASE;\n  }\n  if (carry) {\n    xd.unshift(carry);\n    ++e;\n  }\n  for (len = xd.length; xd[--len] == 0; ) xd.pop();\n  y.d = xd;\n  y.e = getBase10Exponent(xd, e);\n  return external ? finalise(y, pr, rm) : y;\n};\nP.precision = P.sd = function(z) {\n  var k, x = this;\n  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\n  if (x.d) {\n    k = getPrecision(x.d);\n    if (z && x.e + 1 > k) k = x.e + 1;\n  } else {\n    k = NaN;\n  }\n  return k;\n};\nP.round = function() {\n  var x = this, Ctor = x.constructor;\n  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\n};\nP.sine = P.sin = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite()) return new Ctor(NaN);\n  if (x.isZero()) return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n  Ctor.rounding = 1;\n  x = sine(Ctor, toLessThanHalfPi(Ctor, x));\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\n};\nP.squareRoot = P.sqrt = function() {\n  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;\n  if (s !== 1 || !d || !d[0]) {\n    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\n  }\n  external = false;\n  s = Math.sqrt(+x);\n  if (s == 0 || s == 1 / 0) {\n    n = digitsToString(d);\n    if ((n.length + e) % 2 == 0) n += \"0\";\n    s = Math.sqrt(n);\n    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\n    if (s == 1 / 0) {\n      n = \"5e\" + e;\n    } else {\n      n = s.toExponential();\n      n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n    }\n    r = new Ctor(n);\n  } else {\n    r = new Ctor(s.toString());\n  }\n  sd = (e = Ctor.precision) + 3;\n  for (; ; ) {\n    t = r;\n    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n      n = n.slice(sd - 3, sd + 1);\n      if (n == \"9999\" || !rep && n == \"4999\") {\n        if (!rep) {\n          finalise(t, e + 1, 0);\n          if (t.times(t).eq(x)) {\n            r = t;\n            break;\n          }\n        }\n        sd += 4;\n        rep = 1;\n      } else {\n        if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n          finalise(r, e + 1, 1);\n          m = !r.times(r).eq(x);\n        }\n        break;\n      }\n    }\n  }\n  external = true;\n  return finalise(r, e, Ctor.rounding, m);\n};\nP.tangent = P.tan = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite()) return new Ctor(NaN);\n  if (x.isZero()) return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 10;\n  Ctor.rounding = 1;\n  x = x.sin();\n  x.s = 1;\n  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\n};\nP.times = P.mul = function(y) {\n  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;\n  y.s *= x.s;\n  if (!xd || !xd[0] || !yd || !yd[0]) {\n    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);\n  }\n  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\n  xdL = xd.length;\n  ydL = yd.length;\n  if (xdL < ydL) {\n    r = xd;\n    xd = yd;\n    yd = r;\n    rL = xdL;\n    xdL = ydL;\n    ydL = rL;\n  }\n  r = [];\n  rL = xdL + ydL;\n  for (i = rL; i--; ) r.push(0);\n  for (i = ydL; --i >= 0; ) {\n    carry = 0;\n    for (k = xdL + i; k > i; ) {\n      t = r[k] + yd[i] * xd[k - i - 1] + carry;\n      r[k--] = t % BASE | 0;\n      carry = t / BASE | 0;\n    }\n    r[k] = (r[k] + carry) % BASE | 0;\n  }\n  for (; !r[--rL]; ) r.pop();\n  if (carry) ++e;\n  else r.shift();\n  y.d = r;\n  y.e = getBase10Exponent(r, e);\n  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\n};\nP.toBinary = function(sd, rm) {\n  return toStringBinary(this, 2, sd, rm);\n};\nP.toDecimalPlaces = P.toDP = function(dp, rm) {\n  var x = this, Ctor = x.constructor;\n  x = new Ctor(x);\n  if (dp === void 0) return x;\n  checkInt32(dp, 0, MAX_DIGITS);\n  if (rm === void 0) rm = Ctor.rounding;\n  else checkInt32(rm, 0, 8);\n  return finalise(x, dp + x.e + 1, rm);\n};\nP.toExponential = function(dp, rm) {\n  var str, x = this, Ctor = x.constructor;\n  if (dp === void 0) {\n    str = finiteToString(x, true);\n  } else {\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;\n    else checkInt32(rm, 0, 8);\n    x = finalise(new Ctor(x), dp + 1, rm);\n    str = finiteToString(x, true, dp + 1);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toFixed = function(dp, rm) {\n  var str, y, x = this, Ctor = x.constructor;\n  if (dp === void 0) {\n    str = finiteToString(x);\n  } else {\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;\n    else checkInt32(rm, 0, 8);\n    y = finalise(new Ctor(x), dp + x.e + 1, rm);\n    str = finiteToString(y, false, dp + y.e + 1);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toFraction = function(maxD) {\n  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;\n  if (!xd) return new Ctor(x);\n  n1 = d0 = new Ctor(1);\n  d1 = n0 = new Ctor(0);\n  d = new Ctor(d1);\n  e = d.e = getPrecision(xd) - x.e - 1;\n  k = e % LOG_BASE;\n  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\n  if (maxD == null) {\n    maxD = e > 0 ? d : n1;\n  } else {\n    n = new Ctor(maxD);\n    if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\n    maxD = n.gt(d) ? e > 0 ? d : n1 : n;\n  }\n  external = false;\n  n = new Ctor(digitsToString(xd));\n  pr = Ctor.precision;\n  Ctor.precision = e = xd.length * LOG_BASE * 2;\n  for (; ; ) {\n    q = divide(n, d, 0, 1, 1);\n    d2 = d0.plus(q.times(d1));\n    if (d2.cmp(maxD) == 1) break;\n    d0 = d1;\n    d1 = d2;\n    d2 = n1;\n    n1 = n0.plus(q.times(d2));\n    n0 = d2;\n    d2 = d;\n    d = n.minus(q.times(d2));\n    n = d2;\n  }\n  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\n  n0 = n0.plus(d2.times(n1));\n  d0 = d0.plus(d2.times(d1));\n  n0.s = n1.s = x.s;\n  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\n  Ctor.precision = pr;\n  external = true;\n  return r;\n};\nP.toHexadecimal = P.toHex = function(sd, rm) {\n  return toStringBinary(this, 16, sd, rm);\n};\nP.toNearest = function(y, rm) {\n  var x = this, Ctor = x.constructor;\n  x = new Ctor(x);\n  if (y == null) {\n    if (!x.d) return x;\n    y = new Ctor(1);\n    rm = Ctor.rounding;\n  } else {\n    y = new Ctor(y);\n    if (rm === void 0) {\n      rm = Ctor.rounding;\n    } else {\n      checkInt32(rm, 0, 8);\n    }\n    if (!x.d) return y.s ? x : y;\n    if (!y.d) {\n      if (y.s) y.s = x.s;\n      return y;\n    }\n  }\n  if (y.d[0]) {\n    external = false;\n    x = divide(x, y, 0, rm, 1).times(y);\n    external = true;\n    finalise(x);\n  } else {\n    y.s = x.s;\n    x = y;\n  }\n  return x;\n};\nP.toNumber = function() {\n  return +this;\n};\nP.toOctal = function(sd, rm) {\n  return toStringBinary(this, 8, sd, rm);\n};\nP.toPower = P.pow = function(y) {\n  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));\n  if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\n  x = new Ctor(x);\n  if (x.eq(1)) return x;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (y.eq(1)) return finalise(x, pr, rm);\n  e = mathfloor(y.e / LOG_BASE);\n  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\n    r = intPow(Ctor, x, k, pr);\n    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\n  }\n  s = x.s;\n  if (s < 0) {\n    if (e < y.d.length - 1) return new Ctor(NaN);\n    if ((y.d[e] & 1) == 0) s = 1;\n    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\n      x.s = s;\n      return x;\n    }\n  }\n  k = mathpow(+x, yn);\n  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log(\"0.\" + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + \"\").e;\n  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\n  external = false;\n  Ctor.rounding = x.s = 1;\n  k = Math.min(12, (e + \"\").length);\n  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\n  if (r.d) {\n    r = finalise(r, pr + 5, 1);\n    if (checkRoundingDigits(r.d, pr, rm)) {\n      e = pr + 10;\n      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\n      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\n        r = finalise(r, pr + 1, 0);\n      }\n    }\n  }\n  r.s = s;\n  external = true;\n  Ctor.rounding = rm;\n  return finalise(r, pr, rm);\n};\nP.toPrecision = function(sd, rm) {\n  var str, x = this, Ctor = x.constructor;\n  if (sd === void 0) {\n    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  } else {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;\n    else checkInt32(rm, 0, 8);\n    x = finalise(new Ctor(x), sd, rm);\n    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toSignificantDigits = P.toSD = function(sd, rm) {\n  var x = this, Ctor = x.constructor;\n  if (sd === void 0) {\n    sd = Ctor.precision;\n    rm = Ctor.rounding;\n  } else {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;\n    else checkInt32(rm, 0, 8);\n  }\n  return finalise(new Ctor(x), sd, rm);\n};\nP.toString = function() {\n  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.truncated = P.trunc = function() {\n  return finalise(new this.constructor(this), this.e + 1, 1);\n};\nP.valueOf = P.toJSON = function() {\n  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  return x.isNeg() ? \"-\" + str : str;\n};\nfunction digitsToString(d) {\n  var i, k, ws, indexOfLastWord = d.length - 1, str = \"\", w = d[0];\n  if (indexOfLastWord > 0) {\n    str += w;\n    for (i = 1; i < indexOfLastWord; i++) {\n      ws = d[i] + \"\";\n      k = LOG_BASE - ws.length;\n      if (k) str += getZeroString(k);\n      str += ws;\n    }\n    w = d[i];\n    ws = w + \"\";\n    k = LOG_BASE - ws.length;\n    if (k) str += getZeroString(k);\n  } else if (w === 0) {\n    return \"0\";\n  }\n  for (; w % 10 === 0; ) w /= 10;\n  return str + w;\n}\nfunction checkInt32(i, min2, max2) {\n  if (i !== ~~i || i < min2 || i > max2) {\n    throw Error(invalidArgument + i);\n  }\n}\nfunction checkRoundingDigits(d, i, rm, repeating) {\n  var di, k, r, rd;\n  for (k = d[0]; k >= 10; k /= 10) --i;\n  if (--i < 0) {\n    i += LOG_BASE;\n    di = 0;\n  } else {\n    di = Math.ceil((i + 1) / LOG_BASE);\n    i %= LOG_BASE;\n  }\n  k = mathpow(10, LOG_BASE - i);\n  rd = d[di] % k | 0;\n  if (repeating == null) {\n    if (i < 3) {\n      if (i == 0) rd = rd / 100 | 0;\n      else if (i == 1) rd = rd / 10 | 0;\n      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;\n    } else {\n      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\n    }\n  } else {\n    if (i < 4) {\n      if (i == 0) rd = rd / 1e3 | 0;\n      else if (i == 1) rd = rd / 100 | 0;\n      else if (i == 2) rd = rd / 10 | 0;\n      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\n    } else {\n      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;\n    }\n  }\n  return r;\n}\nfunction convertBase(str, baseIn, baseOut) {\n  var j, arr = [0], arrL, i = 0, strL = str.length;\n  for (; i < strL; ) {\n    for (arrL = arr.length; arrL--; ) arr[arrL] *= baseIn;\n    arr[0] += NUMERALS.indexOf(str.charAt(i++));\n    for (j = 0; j < arr.length; j++) {\n      if (arr[j] > baseOut - 1) {\n        if (arr[j + 1] === void 0) arr[j + 1] = 0;\n        arr[j + 1] += arr[j] / baseOut | 0;\n        arr[j] %= baseOut;\n      }\n    }\n  }\n  return arr.reverse();\n}\nfunction cosine(Ctor, x) {\n  var k, len, y;\n  if (x.isZero()) return x;\n  len = x.d.length;\n  if (len < 32) {\n    k = Math.ceil(len / 3);\n    y = (1 / tinyPow(4, k)).toString();\n  } else {\n    k = 16;\n    y = \"2.3283064365386962890625e-10\";\n  }\n  Ctor.precision += k;\n  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\n  for (var i = k; i--; ) {\n    var cos2x = x.times(x);\n    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\n  }\n  Ctor.precision -= k;\n  return x;\n}\nvar divide = /* @__PURE__ */ function() {\n  function multiplyInteger(x, k, base) {\n    var temp, carry = 0, i = x.length;\n    for (x = x.slice(); i--; ) {\n      temp = x[i] * k + carry;\n      x[i] = temp % base | 0;\n      carry = temp / base | 0;\n    }\n    if (carry) x.unshift(carry);\n    return x;\n  }\n  function compare(a, b, aL, bL) {\n    var i, r;\n    if (aL != bL) {\n      r = aL > bL ? 1 : -1;\n    } else {\n      for (i = r = 0; i < aL; i++) {\n        if (a[i] != b[i]) {\n          r = a[i] > b[i] ? 1 : -1;\n          break;\n        }\n      }\n    }\n    return r;\n  }\n  function subtract(a, b, aL, base) {\n    var i = 0;\n    for (; aL--; ) {\n      a[aL] -= i;\n      i = a[aL] < b[aL] ? 1 : 0;\n      a[aL] = i * base + a[aL] - b[aL];\n    }\n    for (; !a[0] && a.length > 1; ) a.shift();\n  }\n  return function(x, y, pr, rm, dp, base) {\n    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;\n    if (!xd || !xd[0] || !yd || !yd[0]) {\n      return new Ctor(\n        // Return NaN if either NaN, or both Infinity or 0.\n        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (\n          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.\n          xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0\n        )\n      );\n    }\n    if (base) {\n      logBase = 1;\n      e = x.e - y.e;\n    } else {\n      base = BASE;\n      logBase = LOG_BASE;\n      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\n    }\n    yL = yd.length;\n    xL = xd.length;\n    q = new Ctor(sign2);\n    qd = q.d = [];\n    for (i = 0; yd[i] == (xd[i] || 0); i++) ;\n    if (yd[i] > (xd[i] || 0)) e--;\n    if (pr == null) {\n      sd = pr = Ctor.precision;\n      rm = Ctor.rounding;\n    } else if (dp) {\n      sd = pr + (x.e - y.e) + 1;\n    } else {\n      sd = pr;\n    }\n    if (sd < 0) {\n      qd.push(1);\n      more = true;\n    } else {\n      sd = sd / logBase + 2 | 0;\n      i = 0;\n      if (yL == 1) {\n        k = 0;\n        yd = yd[0];\n        sd++;\n        for (; (i < xL || k) && sd--; i++) {\n          t = k * base + (xd[i] || 0);\n          qd[i] = t / yd | 0;\n          k = t % yd | 0;\n        }\n        more = k || i < xL;\n      } else {\n        k = base / (yd[0] + 1) | 0;\n        if (k > 1) {\n          yd = multiplyInteger(yd, k, base);\n          xd = multiplyInteger(xd, k, base);\n          yL = yd.length;\n          xL = xd.length;\n        }\n        xi = yL;\n        rem = xd.slice(0, yL);\n        remL = rem.length;\n        for (; remL < yL; ) rem[remL++] = 0;\n        yz = yd.slice();\n        yz.unshift(0);\n        yd0 = yd[0];\n        if (yd[1] >= base / 2) ++yd0;\n        do {\n          k = 0;\n          cmp = compare(yd, rem, yL, remL);\n          if (cmp < 0) {\n            rem0 = rem[0];\n            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\n            k = rem0 / yd0 | 0;\n            if (k > 1) {\n              if (k >= base) k = base - 1;\n              prod = multiplyInteger(yd, k, base);\n              prodL = prod.length;\n              remL = rem.length;\n              cmp = compare(prod, rem, prodL, remL);\n              if (cmp == 1) {\n                k--;\n                subtract(prod, yL < prodL ? yz : yd, prodL, base);\n              }\n            } else {\n              if (k == 0) cmp = k = 1;\n              prod = yd.slice();\n            }\n            prodL = prod.length;\n            if (prodL < remL) prod.unshift(0);\n            subtract(rem, prod, remL, base);\n            if (cmp == -1) {\n              remL = rem.length;\n              cmp = compare(yd, rem, yL, remL);\n              if (cmp < 1) {\n                k++;\n                subtract(rem, yL < remL ? yz : yd, remL, base);\n              }\n            }\n            remL = rem.length;\n          } else if (cmp === 0) {\n            k++;\n            rem = [0];\n          }\n          qd[i++] = k;\n          if (cmp && rem[0]) {\n            rem[remL++] = xd[xi] || 0;\n          } else {\n            rem = [xd[xi]];\n            remL = 1;\n          }\n        } while ((xi++ < xL || rem[0] !== void 0) && sd--);\n        more = rem[0] !== void 0;\n      }\n      if (!qd[0]) qd.shift();\n    }\n    if (logBase == 1) {\n      q.e = e;\n      inexact = more;\n    } else {\n      for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;\n      q.e = i + e * logBase - 1;\n      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\n    }\n    return q;\n  };\n}();\nfunction finalise(x, sd, rm, isTruncated) {\n  var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;\n  out: if (sd != null) {\n    xd = x.d;\n    if (!xd) return x;\n    for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;\n    i = sd - digits;\n    if (i < 0) {\n      i += LOG_BASE;\n      j = sd;\n      w = xd[xdi = 0];\n      rd = w / mathpow(10, digits - j - 1) % 10 | 0;\n    } else {\n      xdi = Math.ceil((i + 1) / LOG_BASE);\n      k = xd.length;\n      if (xdi >= k) {\n        if (isTruncated) {\n          for (; k++ <= xdi; ) xd.push(0);\n          w = rd = 0;\n          digits = 1;\n          i %= LOG_BASE;\n          j = i - LOG_BASE + 1;\n        } else {\n          break out;\n        }\n      } else {\n        w = k = xd[xdi];\n        for (digits = 1; k >= 10; k /= 10) digits++;\n        i %= LOG_BASE;\n        j = i - LOG_BASE + digits;\n        rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\n      }\n    }\n    isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\n    roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.\n    (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n    if (sd < 1 || !xd[0]) {\n      xd.length = 0;\n      if (roundUp) {\n        sd -= x.e + 1;\n        xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\n        x.e = -sd || 0;\n      } else {\n        xd[0] = x.e = 0;\n      }\n      return x;\n    }\n    if (i == 0) {\n      xd.length = xdi;\n      k = 1;\n      xdi--;\n    } else {\n      xd.length = xdi + 1;\n      k = mathpow(10, LOG_BASE - i);\n      xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\n    }\n    if (roundUp) {\n      for (; ; ) {\n        if (xdi == 0) {\n          for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;\n          j = xd[0] += k;\n          for (k = 1; j >= 10; j /= 10) k++;\n          if (i != k) {\n            x.e++;\n            if (xd[0] == BASE) xd[0] = 1;\n          }\n          break;\n        } else {\n          xd[xdi] += k;\n          if (xd[xdi] != BASE) break;\n          xd[xdi--] = 0;\n          k = 1;\n        }\n      }\n    }\n    for (i = xd.length; xd[--i] === 0; ) xd.pop();\n  }\n  if (external) {\n    if (x.e > Ctor.maxE) {\n      x.d = null;\n      x.e = NaN;\n    } else if (x.e < Ctor.minE) {\n      x.e = 0;\n      x.d = [0];\n    }\n  }\n  return x;\n}\nfunction finiteToString(x, isExp, sd) {\n  if (!x.isFinite()) return nonFiniteToString(x);\n  var k, e = x.e, str = digitsToString(x.d), len = str.length;\n  if (isExp) {\n    if (sd && (k = sd - len) > 0) {\n      str = str.charAt(0) + \".\" + str.slice(1) + getZeroString(k);\n    } else if (len > 1) {\n      str = str.charAt(0) + \".\" + str.slice(1);\n    }\n    str = str + (x.e < 0 ? \"e\" : \"e+\") + x.e;\n  } else if (e < 0) {\n    str = \"0.\" + getZeroString(-e - 1) + str;\n    if (sd && (k = sd - len) > 0) str += getZeroString(k);\n  } else if (e >= len) {\n    str += getZeroString(e + 1 - len);\n    if (sd && (k = sd - e - 1) > 0) str = str + \".\" + getZeroString(k);\n  } else {\n    if ((k = e + 1) < len) str = str.slice(0, k) + \".\" + str.slice(k);\n    if (sd && (k = sd - len) > 0) {\n      if (e + 1 === len) str += \".\";\n      str += getZeroString(k);\n    }\n  }\n  return str;\n}\nfunction getBase10Exponent(digits, e) {\n  var w = digits[0];\n  for (e *= LOG_BASE; w >= 10; w /= 10) e++;\n  return e;\n}\nfunction getLn10(Ctor, sd, pr) {\n  if (sd > LN10_PRECISION) {\n    external = true;\n    if (pr) Ctor.precision = pr;\n    throw Error(precisionLimitExceeded);\n  }\n  return finalise(new Ctor(LN10), sd, 1, true);\n}\nfunction getPi(Ctor, sd, rm) {\n  if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\n  return finalise(new Ctor(PI), sd, rm, true);\n}\nfunction getPrecision(digits) {\n  var w = digits.length - 1, len = w * LOG_BASE + 1;\n  w = digits[w];\n  if (w) {\n    for (; w % 10 == 0; w /= 10) len--;\n    for (w = digits[0]; w >= 10; w /= 10) len++;\n  }\n  return len;\n}\nfunction getZeroString(k) {\n  var zs = \"\";\n  for (; k--; ) zs += \"0\";\n  return zs;\n}\nfunction intPow(Ctor, x, n, pr) {\n  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);\n  external = false;\n  for (; ; ) {\n    if (n % 2) {\n      r = r.times(x);\n      if (truncate(r.d, k)) isTruncated = true;\n    }\n    n = mathfloor(n / 2);\n    if (n === 0) {\n      n = r.d.length - 1;\n      if (isTruncated && r.d[n] === 0) ++r.d[n];\n      break;\n    }\n    x = x.times(x);\n    truncate(x.d, k);\n  }\n  external = true;\n  return r;\n}\nfunction isOdd(n) {\n  return n.d[n.d.length - 1] & 1;\n}\nfunction maxOrMin(Ctor, args, n) {\n  var k, y, x = new Ctor(args[0]), i = 0;\n  for (; ++i < args.length; ) {\n    y = new Ctor(args[i]);\n    if (!y.s) {\n      x = y;\n      break;\n    }\n    k = x.cmp(y);\n    if (k === n || k === 0 && x.s === n) {\n      x = y;\n    }\n  }\n  return x;\n}\nfunction naturalExponential(x, sd) {\n  var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n  if (!x.d || !x.d[0] || x.e > 17) {\n    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);\n  }\n  if (sd == null) {\n    external = false;\n    wpr = pr;\n  } else {\n    wpr = sd;\n  }\n  t = new Ctor(0.03125);\n  while (x.e > -2) {\n    x = x.times(t);\n    k += 5;\n  }\n  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\n  wpr += guard;\n  denominator = pow2 = sum2 = new Ctor(1);\n  Ctor.precision = wpr;\n  for (; ; ) {\n    pow2 = finalise(pow2.times(x), wpr, 1);\n    denominator = denominator.times(++i);\n    t = sum2.plus(divide(pow2, denominator, wpr, 1));\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {\n      j = k;\n      while (j--) sum2 = finalise(sum2.times(sum2), wpr, 1);\n      if (sd == null) {\n        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {\n          Ctor.precision = wpr += 10;\n          denominator = pow2 = t = new Ctor(1);\n          i = 0;\n          rep++;\n        } else {\n          return finalise(sum2, Ctor.precision = pr, rm, external = true);\n        }\n      } else {\n        Ctor.precision = pr;\n        return sum2;\n      }\n    }\n    sum2 = t;\n  }\n}\nfunction naturalLogarithm(y, sd) {\n  var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\n    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\n  }\n  if (sd == null) {\n    external = false;\n    wpr = pr;\n  } else {\n    wpr = sd;\n  }\n  Ctor.precision = wpr += guard;\n  c = digitsToString(xd);\n  c0 = c.charAt(0);\n  if (Math.abs(e = x.e) < 15e14) {\n    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\n      x = x.times(y);\n      c = digitsToString(x.d);\n      c0 = c.charAt(0);\n      n++;\n    }\n    e = x.e;\n    if (c0 > 1) {\n      x = new Ctor(\"0.\" + c);\n      e++;\n    } else {\n      x = new Ctor(c0 + \".\" + c.slice(1));\n    }\n  } else {\n    t = getLn10(Ctor, wpr + 2, pr).times(e + \"\");\n    x = naturalLogarithm(new Ctor(c0 + \".\" + c.slice(1)), wpr - guard).plus(t);\n    Ctor.precision = pr;\n    return sd == null ? finalise(x, pr, rm, external = true) : x;\n  }\n  x1 = x;\n  sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\n  x2 = finalise(x.times(x), wpr, 1);\n  denominator = 3;\n  for (; ; ) {\n    numerator = finalise(numerator.times(x2), wpr, 1);\n    t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {\n      sum2 = sum2.times(2);\n      if (e !== 0) sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + \"\"));\n      sum2 = divide(sum2, new Ctor(n), wpr, 1);\n      if (sd == null) {\n        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {\n          Ctor.precision = wpr += guard;\n          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\n          x2 = finalise(x.times(x), wpr, 1);\n          denominator = rep = 1;\n        } else {\n          return finalise(sum2, Ctor.precision = pr, rm, external = true);\n        }\n      } else {\n        Ctor.precision = pr;\n        return sum2;\n      }\n    }\n    sum2 = t;\n    denominator += 2;\n  }\n}\nfunction nonFiniteToString(x) {\n  return String(x.s * x.s / 0);\n}\nfunction parseDecimal(x, str) {\n  var e, i, len;\n  if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n  if ((i = str.search(/e/i)) > 0) {\n    if (e < 0) e = i;\n    e += +str.slice(i + 1);\n    str = str.substring(0, i);\n  } else if (e < 0) {\n    e = str.length;\n  }\n  for (i = 0; str.charCodeAt(i) === 48; i++) ;\n  for (len = str.length; str.charCodeAt(len - 1) === 48; --len) ;\n  str = str.slice(i, len);\n  if (str) {\n    len -= i;\n    x.e = e = e - i - 1;\n    x.d = [];\n    i = (e + 1) % LOG_BASE;\n    if (e < 0) i += LOG_BASE;\n    if (i < len) {\n      if (i) x.d.push(+str.slice(0, i));\n      for (len -= LOG_BASE; i < len; ) x.d.push(+str.slice(i, i += LOG_BASE));\n      str = str.slice(i);\n      i = LOG_BASE - str.length;\n    } else {\n      i -= len;\n    }\n    for (; i--; ) str += \"0\";\n    x.d.push(+str);\n    if (external) {\n      if (x.e > x.constructor.maxE) {\n        x.d = null;\n        x.e = NaN;\n      } else if (x.e < x.constructor.minE) {\n        x.e = 0;\n        x.d = [0];\n      }\n    }\n  } else {\n    x.e = 0;\n    x.d = [0];\n  }\n  return x;\n}\nfunction parseOther(x, str) {\n  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\n  if (str.indexOf(\"_\") > -1) {\n    str = str.replace(/(\\d)_(?=\\d)/g, \"$1\");\n    if (isDecimal.test(str)) return parseDecimal(x, str);\n  } else if (str === \"Infinity\" || str === \"NaN\") {\n    if (!+str) x.s = NaN;\n    x.e = NaN;\n    x.d = null;\n    return x;\n  }\n  if (isHex.test(str)) {\n    base = 16;\n    str = str.toLowerCase();\n  } else if (isBinary.test(str)) {\n    base = 2;\n  } else if (isOctal.test(str)) {\n    base = 8;\n  } else {\n    throw Error(invalidArgument + str);\n  }\n  i = str.search(/p/i);\n  if (i > 0) {\n    p = +str.slice(i + 1);\n    str = str.substring(2, i);\n  } else {\n    str = str.slice(2);\n  }\n  i = str.indexOf(\".\");\n  isFloat = i >= 0;\n  Ctor = x.constructor;\n  if (isFloat) {\n    str = str.replace(\".\", \"\");\n    len = str.length;\n    i = len - i;\n    divisor = intPow(Ctor, new Ctor(base), i, i * 2);\n  }\n  xd = convertBase(str, base, BASE);\n  xe = xd.length - 1;\n  for (i = xe; xd[i] === 0; --i) xd.pop();\n  if (i < 0) return new Ctor(x.s * 0);\n  x.e = getBase10Exponent(xd, xe);\n  x.d = xd;\n  external = false;\n  if (isFloat) x = divide(x, divisor, len * 4);\n  if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\n  external = true;\n  return x;\n}\nfunction sine(Ctor, x) {\n  var k, len = x.d.length;\n  if (len < 3) {\n    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\n  }\n  k = 1.4 * Math.sqrt(len);\n  k = k > 16 ? 16 : k | 0;\n  x = x.times(1 / tinyPow(5, k));\n  x = taylorSeries(Ctor, 2, x, x);\n  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n  for (; k--; ) {\n    sin2_x = x.times(x);\n    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\n  }\n  return x;\n}\nfunction taylorSeries(Ctor, n, x, y, isHyperbolic) {\n  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);\n  external = false;\n  x2 = x.times(x);\n  u = new Ctor(y);\n  for (; ; ) {\n    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\n    u = isHyperbolic ? y.plus(t) : y.minus(t);\n    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\n    t = u.plus(y);\n    if (t.d[k] !== void 0) {\n      for (j = k; t.d[j] === u.d[j] && j--; ) ;\n      if (j == -1) break;\n    }\n    j = u;\n    u = y;\n    y = t;\n    t = j;\n    i++;\n  }\n  external = true;\n  t.d.length = k + 1;\n  return t;\n}\nfunction tinyPow(b, e) {\n  var n = b;\n  while (--e) n *= b;\n  return n;\n}\nfunction toLessThanHalfPi(Ctor, x) {\n  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);\n  x = x.abs();\n  if (x.lte(halfPi)) {\n    quadrant = isNeg ? 4 : 1;\n    return x;\n  }\n  t = x.divToInt(pi);\n  if (t.isZero()) {\n    quadrant = isNeg ? 3 : 2;\n  } else {\n    x = x.minus(t.times(pi));\n    if (x.lte(halfPi)) {\n      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;\n      return x;\n    }\n    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;\n  }\n  return x.minus(pi).abs();\n}\nfunction toStringBinary(x, baseOut, sd, rm) {\n  var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;\n  if (isExp) {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;\n    else checkInt32(rm, 0, 8);\n  } else {\n    sd = Ctor.precision;\n    rm = Ctor.rounding;\n  }\n  if (!x.isFinite()) {\n    str = nonFiniteToString(x);\n  } else {\n    str = finiteToString(x);\n    i = str.indexOf(\".\");\n    if (isExp) {\n      base = 2;\n      if (baseOut == 16) {\n        sd = sd * 4 - 3;\n      } else if (baseOut == 8) {\n        sd = sd * 3 - 2;\n      }\n    } else {\n      base = baseOut;\n    }\n    if (i >= 0) {\n      str = str.replace(\".\", \"\");\n      y = new Ctor(1);\n      y.e = str.length - i;\n      y.d = convertBase(finiteToString(y), 10, base);\n      y.e = y.d.length;\n    }\n    xd = convertBase(str, 10, base);\n    e = len = xd.length;\n    for (; xd[--len] == 0; ) xd.pop();\n    if (!xd[0]) {\n      str = isExp ? \"0p+0\" : \"0\";\n    } else {\n      if (i < 0) {\n        e--;\n      } else {\n        x = new Ctor(x);\n        x.d = xd;\n        x.e = e;\n        x = divide(x, y, sd, rm, 0, base);\n        xd = x.d;\n        e = x.e;\n        roundUp = inexact;\n      }\n      i = xd[sd];\n      k = base / 2;\n      roundUp = roundUp || xd[sd + 1] !== void 0;\n      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));\n      xd.length = sd;\n      if (roundUp) {\n        for (; ++xd[--sd] > base - 1; ) {\n          xd[sd] = 0;\n          if (!sd) {\n            ++e;\n            xd.unshift(1);\n          }\n        }\n      }\n      for (len = xd.length; !xd[len - 1]; --len) ;\n      for (i = 0, str = \"\"; i < len; i++) str += NUMERALS.charAt(xd[i]);\n      if (isExp) {\n        if (len > 1) {\n          if (baseOut == 16 || baseOut == 8) {\n            i = baseOut == 16 ? 4 : 3;\n            for (--len; len % i; len++) str += \"0\";\n            xd = convertBase(str, base, baseOut);\n            for (len = xd.length; !xd[len - 1]; --len) ;\n            for (i = 1, str = \"1.\"; i < len; i++) str += NUMERALS.charAt(xd[i]);\n          } else {\n            str = str.charAt(0) + \".\" + str.slice(1);\n          }\n        }\n        str = str + (e < 0 ? \"p\" : \"p+\") + e;\n      } else if (e < 0) {\n        for (; ++e; ) str = \"0\" + str;\n        str = \"0.\" + str;\n      } else {\n        if (++e > len) for (e -= len; e--; ) str += \"0\";\n        else if (e < len) str = str.slice(0, e) + \".\" + str.slice(e);\n      }\n    }\n    str = (baseOut == 16 ? \"0x\" : baseOut == 2 ? \"0b\" : baseOut == 8 ? \"0o\" : \"\") + str;\n  }\n  return x.s < 0 ? \"-\" + str : str;\n}\nfunction truncate(arr, len) {\n  if (arr.length > len) {\n    arr.length = len;\n    return true;\n  }\n}\nfunction abs(x) {\n  return new this(x).abs();\n}\nfunction acos(x) {\n  return new this(x).acos();\n}\nfunction acosh(x) {\n  return new this(x).acosh();\n}\nfunction add(x, y) {\n  return new this(x).plus(y);\n}\nfunction asin(x) {\n  return new this(x).asin();\n}\nfunction asinh(x) {\n  return new this(x).asinh();\n}\nfunction atan(x) {\n  return new this(x).atan();\n}\nfunction atanh(x) {\n  return new this(x).atanh();\n}\nfunction atan2(y, x) {\n  y = new this(y);\n  x = new this(x);\n  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;\n  if (!y.s || !x.s) {\n    r = new this(NaN);\n  } else if (!y.d && !x.d) {\n    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\n    r.s = y.s;\n  } else if (!x.d || y.isZero()) {\n    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\n    r.s = y.s;\n  } else if (!y.d || x.isZero()) {\n    r = getPi(this, wpr, 1).times(0.5);\n    r.s = y.s;\n  } else if (x.s < 0) {\n    this.precision = wpr;\n    this.rounding = 1;\n    r = this.atan(divide(y, x, wpr, 1));\n    x = getPi(this, wpr, 1);\n    this.precision = pr;\n    this.rounding = rm;\n    r = y.s < 0 ? r.minus(x) : r.plus(x);\n  } else {\n    r = this.atan(divide(y, x, wpr, 1));\n  }\n  return r;\n}\nfunction cbrt(x) {\n  return new this(x).cbrt();\n}\nfunction ceil(x) {\n  return finalise(x = new this(x), x.e + 1, 2);\n}\nfunction clamp(x, min2, max2) {\n  return new this(x).clamp(min2, max2);\n}\nfunction config(obj) {\n  if (!obj || typeof obj !== \"object\") throw Error(decimalError + \"Object expected\");\n  var i, p, v, useDefaults = obj.defaults === true, ps = [\n    \"precision\",\n    1,\n    MAX_DIGITS,\n    \"rounding\",\n    0,\n    8,\n    \"toExpNeg\",\n    -EXP_LIMIT,\n    0,\n    \"toExpPos\",\n    0,\n    EXP_LIMIT,\n    \"maxE\",\n    0,\n    EXP_LIMIT,\n    \"minE\",\n    -EXP_LIMIT,\n    0,\n    \"modulo\",\n    0,\n    9\n  ];\n  for (i = 0; i < ps.length; i += 3) {\n    if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];\n    if ((v = obj[p]) !== void 0) {\n      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\n      else throw Error(invalidArgument + p + \": \" + v);\n    }\n  }\n  if (p = \"crypto\", useDefaults) this[p] = DEFAULTS[p];\n  if ((v = obj[p]) !== void 0) {\n    if (v === true || v === false || v === 0 || v === 1) {\n      if (v) {\n        if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n          this[p] = true;\n        } else {\n          throw Error(cryptoUnavailable);\n        }\n      } else {\n        this[p] = false;\n      }\n    } else {\n      throw Error(invalidArgument + p + \": \" + v);\n    }\n  }\n  return this;\n}\nfunction cos(x) {\n  return new this(x).cos();\n}\nfunction cosh(x) {\n  return new this(x).cosh();\n}\nfunction clone(obj) {\n  var i, p, ps;\n  function Decimal2(v) {\n    var e, i2, t, x = this;\n    if (!(x instanceof Decimal2)) return new Decimal2(v);\n    x.constructor = Decimal2;\n    if (isDecimalInstance(v)) {\n      x.s = v.s;\n      if (external) {\n        if (!v.d || v.e > Decimal2.maxE) {\n          x.e = NaN;\n          x.d = null;\n        } else if (v.e < Decimal2.minE) {\n          x.e = 0;\n          x.d = [0];\n        } else {\n          x.e = v.e;\n          x.d = v.d.slice();\n        }\n      } else {\n        x.e = v.e;\n        x.d = v.d ? v.d.slice() : v.d;\n      }\n      return;\n    }\n    t = typeof v;\n    if (t === \"number\") {\n      if (v === 0) {\n        x.s = 1 / v < 0 ? -1 : 1;\n        x.e = 0;\n        x.d = [0];\n        return;\n      }\n      if (v < 0) {\n        v = -v;\n        x.s = -1;\n      } else {\n        x.s = 1;\n      }\n      if (v === ~~v && v < 1e7) {\n        for (e = 0, i2 = v; i2 >= 10; i2 /= 10) e++;\n        if (external) {\n          if (e > Decimal2.maxE) {\n            x.e = NaN;\n            x.d = null;\n          } else if (e < Decimal2.minE) {\n            x.e = 0;\n            x.d = [0];\n          } else {\n            x.e = e;\n            x.d = [v];\n          }\n        } else {\n          x.e = e;\n          x.d = [v];\n        }\n        return;\n      }\n      if (v * 0 !== 0) {\n        if (!v) x.s = NaN;\n        x.e = NaN;\n        x.d = null;\n        return;\n      }\n      return parseDecimal(x, v.toString());\n    }\n    if (t === \"string\") {\n      if ((i2 = v.charCodeAt(0)) === 45) {\n        v = v.slice(1);\n        x.s = -1;\n      } else {\n        if (i2 === 43) v = v.slice(1);\n        x.s = 1;\n      }\n      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\n    }\n    if (t === \"bigint\") {\n      if (v < 0) {\n        v = -v;\n        x.s = -1;\n      } else {\n        x.s = 1;\n      }\n      return parseDecimal(x, v.toString());\n    }\n    throw Error(invalidArgument + v);\n  }\n  Decimal2.prototype = P;\n  Decimal2.ROUND_UP = 0;\n  Decimal2.ROUND_DOWN = 1;\n  Decimal2.ROUND_CEIL = 2;\n  Decimal2.ROUND_FLOOR = 3;\n  Decimal2.ROUND_HALF_UP = 4;\n  Decimal2.ROUND_HALF_DOWN = 5;\n  Decimal2.ROUND_HALF_EVEN = 6;\n  Decimal2.ROUND_HALF_CEIL = 7;\n  Decimal2.ROUND_HALF_FLOOR = 8;\n  Decimal2.EUCLID = 9;\n  Decimal2.config = Decimal2.set = config;\n  Decimal2.clone = clone;\n  Decimal2.isDecimal = isDecimalInstance;\n  Decimal2.abs = abs;\n  Decimal2.acos = acos;\n  Decimal2.acosh = acosh;\n  Decimal2.add = add;\n  Decimal2.asin = asin;\n  Decimal2.asinh = asinh;\n  Decimal2.atan = atan;\n  Decimal2.atanh = atanh;\n  Decimal2.atan2 = atan2;\n  Decimal2.cbrt = cbrt;\n  Decimal2.ceil = ceil;\n  Decimal2.clamp = clamp;\n  Decimal2.cos = cos;\n  Decimal2.cosh = cosh;\n  Decimal2.div = div;\n  Decimal2.exp = exp;\n  Decimal2.floor = floor;\n  Decimal2.hypot = hypot;\n  Decimal2.ln = ln;\n  Decimal2.log = log;\n  Decimal2.log10 = log10;\n  Decimal2.log2 = log2;\n  Decimal2.max = max;\n  Decimal2.min = min;\n  Decimal2.mod = mod;\n  Decimal2.mul = mul;\n  Decimal2.pow = pow;\n  Decimal2.random = random;\n  Decimal2.round = round;\n  Decimal2.sign = sign;\n  Decimal2.sin = sin;\n  Decimal2.sinh = sinh;\n  Decimal2.sqrt = sqrt;\n  Decimal2.sub = sub;\n  Decimal2.sum = sum;\n  Decimal2.tan = tan;\n  Decimal2.tanh = tanh;\n  Decimal2.trunc = trunc;\n  if (obj === void 0) obj = {};\n  if (obj) {\n    if (obj.defaults !== true) {\n      ps = [\"precision\", \"rounding\", \"toExpNeg\", \"toExpPos\", \"maxE\", \"minE\", \"modulo\", \"crypto\"];\n      for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\n    }\n  }\n  Decimal2.config(obj);\n  return Decimal2;\n}\nfunction div(x, y) {\n  return new this(x).div(y);\n}\nfunction exp(x) {\n  return new this(x).exp();\n}\nfunction floor(x) {\n  return finalise(x = new this(x), x.e + 1, 3);\n}\nfunction hypot() {\n  var i, n, t = new this(0);\n  external = false;\n  for (i = 0; i < arguments.length; ) {\n    n = new this(arguments[i++]);\n    if (!n.d) {\n      if (n.s) {\n        external = true;\n        return new this(1 / 0);\n      }\n      t = n;\n    } else if (t.d) {\n      t = t.plus(n.times(n));\n    }\n  }\n  external = true;\n  return t.sqrt();\n}\nfunction isDecimalInstance(obj) {\n  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\n}\nfunction ln(x) {\n  return new this(x).ln();\n}\nfunction log(x, y) {\n  return new this(x).log(y);\n}\nfunction log2(x) {\n  return new this(x).log(2);\n}\nfunction log10(x) {\n  return new this(x).log(10);\n}\nfunction max() {\n  return maxOrMin(this, arguments, -1);\n}\nfunction min() {\n  return maxOrMin(this, arguments, 1);\n}\nfunction mod(x, y) {\n  return new this(x).mod(y);\n}\nfunction mul(x, y) {\n  return new this(x).mul(y);\n}\nfunction pow(x, y) {\n  return new this(x).pow(y);\n}\nfunction random(sd) {\n  var d, e, k, n, i = 0, r = new this(1), rd = [];\n  if (sd === void 0) sd = this.precision;\n  else checkInt32(sd, 1, MAX_DIGITS);\n  k = Math.ceil(sd / LOG_BASE);\n  if (!this.crypto) {\n    for (; i < k; ) rd[i++] = Math.random() * 1e7 | 0;\n  } else if (crypto.getRandomValues) {\n    d = crypto.getRandomValues(new Uint32Array(k));\n    for (; i < k; ) {\n      n = d[i];\n      if (n >= 429e7) {\n        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\n      } else {\n        rd[i++] = n % 1e7;\n      }\n    }\n  } else if (crypto.randomBytes) {\n    d = crypto.randomBytes(k *= 4);\n    for (; i < k; ) {\n      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);\n      if (n >= 214e7) {\n        crypto.randomBytes(4).copy(d, i);\n      } else {\n        rd.push(n % 1e7);\n        i += 4;\n      }\n    }\n    i = k / 4;\n  } else {\n    throw Error(cryptoUnavailable);\n  }\n  k = rd[--i];\n  sd %= LOG_BASE;\n  if (k && sd) {\n    n = mathpow(10, LOG_BASE - sd);\n    rd[i] = (k / n | 0) * n;\n  }\n  for (; rd[i] === 0; i--) rd.pop();\n  if (i < 0) {\n    e = 0;\n    rd = [0];\n  } else {\n    e = -1;\n    for (; rd[0] === 0; e -= LOG_BASE) rd.shift();\n    for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;\n    if (k < LOG_BASE) e -= LOG_BASE - k;\n  }\n  r.e = e;\n  r.d = rd;\n  return r;\n}\nfunction round(x) {\n  return finalise(x = new this(x), x.e + 1, this.rounding);\n}\nfunction sign(x) {\n  x = new this(x);\n  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;\n}\nfunction sin(x) {\n  return new this(x).sin();\n}\nfunction sinh(x) {\n  return new this(x).sinh();\n}\nfunction sqrt(x) {\n  return new this(x).sqrt();\n}\nfunction sub(x, y) {\n  return new this(x).sub(y);\n}\nfunction sum() {\n  var i = 0, args = arguments, x = new this(args[i]);\n  external = false;\n  for (; x.s && ++i < args.length; ) x = x.plus(args[i]);\n  external = true;\n  return finalise(x, this.precision, this.rounding);\n}\nfunction tan(x) {\n  return new this(x).tan();\n}\nfunction tanh(x) {\n  return new this(x).tanh();\n}\nfunction trunc(x) {\n  return finalise(x = new this(x), x.e + 1, 1);\n}\nP[Symbol.for(\"nodejs.util.inspect.custom\")] = P.toString;\nP[Symbol.toStringTag] = \"Decimal\";\nvar Decimal = P.constructor = clone(DEFAULTS);\nLN10 = new Decimal(LN10);\nPI = new Decimal(PI);\n\n// ../../node_modules/.pnpm/sql-template-tag@5.2.1/node_modules/sql-template-tag/dist/index.js\nvar Sql = class _Sql {\n  constructor(rawStrings, rawValues) {\n    if (rawStrings.length - 1 !== rawValues.length) {\n      if (rawStrings.length === 0) {\n        throw new TypeError(\"Expected at least 1 string\");\n      }\n      throw new TypeError(`Expected ${rawStrings.length} strings to have ${rawStrings.length - 1} values`);\n    }\n    const valuesLength = rawValues.reduce((len, value) => len + (value instanceof _Sql ? value.values.length : 1), 0);\n    this.values = new Array(valuesLength);\n    this.strings = new Array(valuesLength + 1);\n    this.strings[0] = rawStrings[0];\n    let i = 0, pos = 0;\n    while (i < rawValues.length) {\n      const child = rawValues[i++];\n      const rawString = rawStrings[i];\n      if (child instanceof _Sql) {\n        this.strings[pos] += child.strings[0];\n        let childIndex = 0;\n        while (childIndex < child.values.length) {\n          this.values[pos++] = child.values[childIndex++];\n          this.strings[pos] = child.strings[childIndex];\n        }\n        this.strings[pos] += rawString;\n      } else {\n        this.values[pos++] = child;\n        this.strings[pos] = rawString;\n      }\n    }\n  }\n  get sql() {\n    const len = this.strings.length;\n    let i = 1;\n    let value = this.strings[0];\n    while (i < len)\n      value += `?${this.strings[i++]}`;\n    return value;\n  }\n  get statement() {\n    const len = this.strings.length;\n    let i = 1;\n    let value = this.strings[0];\n    while (i < len)\n      value += `:${i}${this.strings[i++]}`;\n    return value;\n  }\n  get text() {\n    const len = this.strings.length;\n    let i = 1;\n    let value = this.strings[0];\n    while (i < len)\n      value += `$${i}${this.strings[i++]}`;\n    return value;\n  }\n  inspect() {\n    return {\n      sql: this.sql,\n      statement: this.statement,\n      text: this.text,\n      values: this.values\n    };\n  }\n};\nfunction join(values, separator = \",\", prefix = \"\", suffix = \"\") {\n  if (values.length === 0) {\n    throw new TypeError(\"Expected `join([])` to be called with an array of multiple elements, but got an empty array\");\n  }\n  return new Sql([prefix, ...Array(values.length - 1).fill(separator), suffix], values);\n}\nfunction raw(value) {\n  return new Sql([value], []);\n}\nvar empty = raw(\"\");\nfunction sql(strings, ...values) {\n  return new Sql(strings, values);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n/*! Bundled license information:\n\ndecimal.js/decimal.mjs:\n  (*!\n   *  decimal.js v10.5.0\n   *  An arbitrary-precision Decimal type for JavaScript.\n   *  https://github.com/MikeMcl/decimal.js\n   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>\n   *  MIT Licence\n   *)\n*/\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHByaXNtYS9jbGllbnQtcnVudGltZS11dGlscy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCLGFBQWE7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUE0QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsb0JBQW9CO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQkFBZ0I7QUFDMUQsTUFBTTtBQUNOLDhDQUE4QyxxQkFBcUIsR0FBRyxnQkFBZ0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlLEVBQUU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQyxzQkFBc0IsT0FBTztBQUM3QjtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCLFNBQVMsYUFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTLGNBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVTtBQUNuQiw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQW1CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQjtBQUN4Qyx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUMsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBLGtDQUFrQyxjQUFjO0FBQ2hELG9DQUFvQyxTQUFTO0FBQzdDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixlQUFlLEtBQUs7QUFDcEI7QUFDQSxRQUFRO0FBQ1Isc0NBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsSUFBSTtBQUNKO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsYUFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxXQUFXLGFBQWE7QUFDeEIsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBCQUEwQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1CQUFtQixrQkFBa0IsdUJBQXVCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUUsRUFBRSxrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsRUFBRSxFQUFFLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0F5Qkw7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iYWNrZW5kLy4vbm9kZV9tb2R1bGVzL0BwcmlzbWEvY2xpZW50LXJ1bnRpbWUtdXRpbHMvZGlzdC9pbmRleC5qcz9iYjY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZDIpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZDIpO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBpbmRleF9leHBvcnRzID0ge307XG5fX2V4cG9ydChpbmRleF9leHBvcnRzLCB7XG4gIEFueU51bGw6ICgpID0+IEFueU51bGwsXG4gIEFueU51bGxDbGFzczogKCkgPT4gQW55TnVsbENsYXNzLFxuICBEYk51bGw6ICgpID0+IERiTnVsbCxcbiAgRGJOdWxsQ2xhc3M6ICgpID0+IERiTnVsbENsYXNzLFxuICBEZWNpbWFsOiAoKSA9PiBEZWNpbWFsLFxuICBKc29uTnVsbDogKCkgPT4gSnNvbk51bGwsXG4gIEpzb25OdWxsQ2xhc3M6ICgpID0+IEpzb25OdWxsQ2xhc3MsXG4gIE51bGxUeXBlczogKCkgPT4gTnVsbFR5cGVzLFxuICBPYmplY3RFbnVtVmFsdWU6ICgpID0+IE9iamVjdEVudW1WYWx1ZSxcbiAgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcjogKCkgPT4gUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcixcbiAgUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3I6ICgpID0+IFByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yLFxuICBQcmlzbWFDbGllbnRSdXN0RXJyb3I6ICgpID0+IFByaXNtYUNsaWVudFJ1c3RFcnJvcixcbiAgUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3I6ICgpID0+IFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yLFxuICBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yOiAoKSA9PiBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yLFxuICBQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3I6ICgpID0+IFByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcixcbiAgU3FsOiAoKSA9PiBTcWwsXG4gIGVtcHR5OiAoKSA9PiBlbXB0eSxcbiAgaGFzQmF0Y2hJbmRleDogKCkgPT4gaGFzQmF0Y2hJbmRleCxcbiAgaXNBbnlOdWxsOiAoKSA9PiBpc0FueU51bGwsXG4gIGlzRGJOdWxsOiAoKSA9PiBpc0RiTnVsbCxcbiAgaXNKc29uTnVsbDogKCkgPT4gaXNKc29uTnVsbCxcbiAgam9pbjogKCkgPT4gam9pbixcbiAgcmF3OiAoKSA9PiByYXcsXG4gIHNxbDogKCkgPT4gc3FsXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGluZGV4X2V4cG9ydHMpO1xuXG4vLyBzcmMvZXJyb3JzL0Vycm9yV2l0aEJhdGNoSW5kZXgudHNcbmZ1bmN0aW9uIGhhc0JhdGNoSW5kZXgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZVtcImJhdGNoUmVxdWVzdElkeFwiXSA9PT0gXCJudW1iZXJcIjtcbn1cblxuLy8gc3JjL2Vycm9ycy9zZXRDbGFzc05hbWUudHNcbmZ1bmN0aW9uIHNldENsYXNzTmFtZShjbGFzc09iamVjdCwgbmFtZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NPYmplY3QsIFwibmFtZVwiLCB7XG4gICAgdmFsdWU6IG5hbWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBzcmMvZXJyb3JzL1ByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IudHNcbnZhciBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yID0gY2xhc3MgX1ByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNsaWVudFZlcnNpb247XG4gIGVycm9yQ29kZTtcbiAgcmV0cnlhYmxlO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjbGllbnRWZXJzaW9uLCBlcnJvckNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3JcIjtcbiAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBjbGllbnRWZXJzaW9uO1xuICAgIHRoaXMuZXJyb3JDb2RlID0gZXJyb3JDb2RlO1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF9QcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yKTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvclwiO1xuICB9XG59O1xuc2V0Q2xhc3NOYW1lKFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IsIFwiUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvclwiKTtcblxuLy8gc3JjL2Vycm9ycy9QcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvci50c1xudmFyIFByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvZGU7XG4gIG1ldGE7XG4gIGNsaWVudFZlcnNpb247XG4gIGJhdGNoUmVxdWVzdElkeDtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgeyBjb2RlLCBjbGllbnRWZXJzaW9uLCBtZXRhLCBiYXRjaFJlcXVlc3RJZHggfSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3JcIjtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IGNsaWVudFZlcnNpb247XG4gICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXRjaFJlcXVlc3RJZHhcIiwge1xuICAgICAgdmFsdWU6IGJhdGNoUmVxdWVzdElkeCxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3JcIjtcbiAgfVxufTtcbnNldENsYXNzTmFtZShQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvciwgXCJQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvclwiKTtcblxuLy8gc3JjL2Vycm9ycy9sb2cudHNcbmZ1bmN0aW9uIGdldEJhY2t0cmFjZShsb2czKSB7XG4gIGlmIChsb2czLmZpZWxkcz8ubWVzc2FnZSkge1xuICAgIGxldCBzdHIgPSBsb2czLmZpZWxkcz8ubWVzc2FnZTtcbiAgICBpZiAobG9nMy5maWVsZHM/LmZpbGUpIHtcbiAgICAgIHN0ciArPSBgIGluICR7bG9nMy5maWVsZHMuZmlsZX1gO1xuICAgICAgaWYgKGxvZzMuZmllbGRzPy5saW5lKSB7XG4gICAgICAgIHN0ciArPSBgOiR7bG9nMy5maWVsZHMubGluZX1gO1xuICAgICAgfVxuICAgICAgaWYgKGxvZzMuZmllbGRzPy5jb2x1bW4pIHtcbiAgICAgICAgc3RyICs9IGA6JHtsb2czLmZpZWxkcy5jb2x1bW59YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxvZzMuZmllbGRzPy5yZWFzb24pIHtcbiAgICAgIHN0ciArPSBgXG4ke2xvZzMuZmllbGRzPy5yZWFzb259YDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICByZXR1cm4gXCJVbmtub3duIGVycm9yXCI7XG59XG5mdW5jdGlvbiBpc1BhbmljKGVycikge1xuICByZXR1cm4gZXJyLmZpZWxkcz8ubWVzc2FnZSA9PT0gXCJQQU5JQ1wiO1xufVxuXG4vLyBzcmMvZXJyb3JzL1ByaXNtYUNsaWVudFJ1c3RFcnJvci50c1xudmFyIFByaXNtYUNsaWVudFJ1c3RFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjbGllbnRWZXJzaW9uO1xuICBfaXNQYW5pYztcbiAgY29uc3RydWN0b3IoeyBjbGllbnRWZXJzaW9uLCBlcnJvciB9KSB7XG4gICAgY29uc3QgYmFja3RyYWNlID0gZ2V0QmFja3RyYWNlKGVycm9yKTtcbiAgICBzdXBlcihiYWNrdHJhY2UgPz8gXCJVbmtub3duIGVycm9yXCIpO1xuICAgIHRoaXMuX2lzUGFuaWMgPSBpc1BhbmljKGVycm9yKTtcbiAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBjbGllbnRWZXJzaW9uO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJQcmlzbWFDbGllbnRSdXN0RXJyb3JcIjtcbiAgfVxuICBpc1BhbmljKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1BhbmljO1xuICB9XG59O1xuc2V0Q2xhc3NOYW1lKFByaXNtYUNsaWVudFJ1c3RFcnJvciwgXCJQcmlzbWFDbGllbnRSdXN0RXJyb3JcIik7XG5cbi8vIHNyYy9lcnJvcnMvUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IudHNcbnZhciBQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjbGllbnRWZXJzaW9uO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjbGllbnRWZXJzaW9uKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvclwiO1xuICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IGNsaWVudFZlcnNpb247XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIlByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yXCI7XG4gIH1cbn07XG5zZXRDbGFzc05hbWUoUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IsIFwiUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3JcIik7XG5cbi8vIHNyYy9lcnJvcnMvUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvci50c1xudmFyIFByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY2xpZW50VmVyc2lvbjtcbiAgYmF0Y2hSZXF1ZXN0SWR4O1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB7IGNsaWVudFZlcnNpb24sIGJhdGNoUmVxdWVzdElkeCB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yXCI7XG4gICAgdGhpcy5jbGllbnRWZXJzaW9uID0gY2xpZW50VmVyc2lvbjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXRjaFJlcXVlc3RJZHhcIiwge1xuICAgICAgdmFsdWU6IGJhdGNoUmVxdWVzdElkeCxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvclwiO1xuICB9XG59O1xuc2V0Q2xhc3NOYW1lKFByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IsIFwiUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvclwiKTtcblxuLy8gc3JjL2Vycm9ycy9QcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IudHNcbnZhciBQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgbmFtZSA9IFwiUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yXCI7XG4gIGNsaWVudFZlcnNpb247XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHsgY2xpZW50VmVyc2lvbiB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jbGllbnRWZXJzaW9uID0gY2xpZW50VmVyc2lvbjtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yXCI7XG4gIH1cbn07XG5zZXRDbGFzc05hbWUoUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yLCBcIlByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvclwiKTtcblxuLy8gc3JjL251bGxUeXBlcy50c1xudmFyIHNlY3JldCA9IFN5bWJvbCgpO1xudmFyIHJlcHJlc2VudGF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIE9iamVjdEVudW1WYWx1ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYXJnKSB7XG4gICAgaWYgKGFyZyA9PT0gc2VjcmV0KSB7XG4gICAgICByZXByZXNlbnRhdGlvbnMuc2V0KHRoaXMsIGBQcmlzbWEuJHt0aGlzLl9nZXROYW1lKCl9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcHJlc2VudGF0aW9ucy5zZXQodGhpcywgYG5ldyBQcmlzbWEuJHt0aGlzLl9nZXROYW1lc3BhY2UoKX0uJHt0aGlzLl9nZXROYW1lKCl9KClgKTtcbiAgICB9XG4gIH1cbiAgX2dldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gcmVwcmVzZW50YXRpb25zLmdldCh0aGlzKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNldENsYXNzTmFtZTIoY2xhc3NPYmplY3QsIG5hbWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzT2JqZWN0LCBcIm5hbWVcIiwge1xuICAgIHZhbHVlOiBuYW1lLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cbnZhciBOdWxsVHlwZXNFbnVtVmFsdWUgPSBjbGFzcyBleHRlbmRzIE9iamVjdEVudW1WYWx1ZSB7XG4gIF9nZXROYW1lc3BhY2UoKSB7XG4gICAgcmV0dXJuIFwiTnVsbFR5cGVzXCI7XG4gIH1cbn07XG52YXIgRGJOdWxsQ2xhc3MgPSBjbGFzcyBleHRlbmRzIE51bGxUeXBlc0VudW1WYWx1ZSB7XG4gIC8vIFBoYW50b20gcHJpdmF0ZSBwcm9wZXJ0eSB0byBwcmV2ZW50IHN0cnVjdHVyYWwgdHlwZSBlcXVhbGl0eVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXByaXZhdGUtY2xhc3MtbWVtYmVyc1xuICAjX2JyYW5kX0RiTnVsbDtcbn07XG5zZXRDbGFzc05hbWUyKERiTnVsbENsYXNzLCBcIkRiTnVsbFwiKTtcbnZhciBKc29uTnVsbENsYXNzID0gY2xhc3MgZXh0ZW5kcyBOdWxsVHlwZXNFbnVtVmFsdWUge1xuICAvLyBQaGFudG9tIHByaXZhdGUgcHJvcGVydHkgdG8gcHJldmVudCBzdHJ1Y3R1cmFsIHR5cGUgZXF1YWxpdHlcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1wcml2YXRlLWNsYXNzLW1lbWJlcnNcbiAgI19icmFuZF9Kc29uTnVsbDtcbn07XG5zZXRDbGFzc05hbWUyKEpzb25OdWxsQ2xhc3MsIFwiSnNvbk51bGxcIik7XG52YXIgQW55TnVsbENsYXNzID0gY2xhc3MgZXh0ZW5kcyBOdWxsVHlwZXNFbnVtVmFsdWUge1xuICAvLyBQaGFudG9tIHByaXZhdGUgcHJvcGVydHkgdG8gcHJldmVudCBzdHJ1Y3R1cmFsIHR5cGUgZXF1YWxpdHlcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1wcml2YXRlLWNsYXNzLW1lbWJlcnNcbiAgI19icmFuZF9BbnlOdWxsO1xufTtcbnNldENsYXNzTmFtZTIoQW55TnVsbENsYXNzLCBcIkFueU51bGxcIik7XG52YXIgTnVsbFR5cGVzID0ge1xuICBEYk51bGw6IERiTnVsbENsYXNzLFxuICBKc29uTnVsbDogSnNvbk51bGxDbGFzcyxcbiAgQW55TnVsbDogQW55TnVsbENsYXNzXG59O1xudmFyIERiTnVsbCA9IG5ldyBEYk51bGxDbGFzcyhzZWNyZXQpO1xudmFyIEpzb25OdWxsID0gbmV3IEpzb25OdWxsQ2xhc3Moc2VjcmV0KTtcbnZhciBBbnlOdWxsID0gbmV3IEFueU51bGxDbGFzcyhzZWNyZXQpO1xuZnVuY3Rpb24gaXNEYk51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBEYk51bGw7XG59XG5mdW5jdGlvbiBpc0pzb25OdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gSnNvbk51bGw7XG59XG5mdW5jdGlvbiBpc0FueU51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBBbnlOdWxsO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZGVjaW1hbC5qc0AxMC41LjAvbm9kZV9tb2R1bGVzL2RlY2ltYWwuanMvZGVjaW1hbC5tanNcbnZhciBFWFBfTElNSVQgPSA5ZTE1O1xudmFyIE1BWF9ESUdJVFMgPSAxZTk7XG52YXIgTlVNRVJBTFMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbnZhciBMTjEwID0gXCIyLjMwMjU4NTA5Mjk5NDA0NTY4NDAxNzk5MTQ1NDY4NDM2NDIwNzYwMTEwMTQ4ODYyODc3Mjk3NjAzMzMyNzkwMDk2NzU3MjYwOTY3NzM1MjQ4MDIzNTk5NzIwNTA4OTU5ODI5ODM0MTk2Nzc4NDA0MjI4NjI0ODYzMzQwOTUyNTQ2NTA4MjgwNjc1NjY2NjI4NzM2OTA5ODc4MTY4OTQ4MjkwNzIwODMyNTU1NDY4MDg0Mzc5OTg5NDgyNjIzMzE5ODUyODM5MzUwNTMwODk2NTM3NzczMjYyODg0NjE2MzM2NjIyMjI4NzY5ODIxOTg4Njc0NjU0MzY2NzQ3NDQwNDI0MzI3NDM2NTE1NTA0ODkzNDMxNDkzOTM5MTQ3OTYxOTQwNDQwMDIyMjEwNTEwMTcxNDE3NDgwMDM2ODgwODQwMTI2NDcwODA2ODU1Njc3NDMyMTYyMjgzNTUyMjAxMTQ4MDQ2NjM3MTU2NTkxMjEzNzM0NTA3NDc4NTY5NDc2ODM0NjM2MTY3OTIxMDE4MDY0NDUwNzA2NDgwMDAyNzc1MDI2ODQ5MTY3NDY1NTA1ODY4NTY5MzU2NzM0MjA2NzA1ODExMzY0MjkyMjQ1NTQ0MDU3NTg5MjU3MjQyMDgyNDEzMTQ2OTU2ODkwMTY3NTg5NDAyNTY3NzYzMTEzNTY5MTkyOTIwMzMzNzY1ODcxNDE2NjAyMzAxMDU3MDMwODk2MzQ1NzIwNzU0NDAzNzA4NDc0Njk5NDAxNjgyNjkyODI4MDg0ODExODQyODkzMTQ4NDg1MjQ5NDg2NDQ4NzE5Mjc4MDk2NzYyNzEyNzU3NzUzOTcwMjc2Njg2MDU5NTI0OTY3MTY2NzQxODM0ODU3MDQ0MjI1MDcxOTc5NjUwMDQ3MTQ5NTEwNTA0OTIyMTQ3NzY1Njc2MzY5Mzg2NjI5NzY5Nzk1MjIxMTA3MTgyNjQ1NDk3MzQ3NzI2NjI0MjU3MDk0MjkzMjI1ODI3OTg1MDI1ODU1MDk3ODUyNjUzODMyMDc2MDY3MjYzMTcxNjQzMDk1MDU5OTUwODc4MDc1MjM3MTAzMzMxMDExOTc4NTc1NDczMzE1NDE0MjE4MDg0Mjc1NDM4NjM1OTE3NzgxMTcwNTQzMDk4Mjc0ODIzODUwNDU2NDgwMTkwOTU2MTAyOTkyOTE4MjQzMTgyMzc1MjUzNTc3MDk3NTA1Mzk1NjUxODc2OTc1MTAzNzQ5NzA4ODg2OTIxODAyMDUxODkzMzk1MDcyMzg1MzkyMDUxNDQ2MzQxOTcyNjUyODcyODY5NjUxMTA4NjI1NzE0OTIxOTg4NDk5Nzg3NDg4NzM3NzEzNDU2ODYyMDkxNjcwNThcIjtcbnZhciBQSSA9IFwiMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjA5NzQ5NDQ1OTIzMDc4MTY0MDYyODYyMDg5OTg2MjgwMzQ4MjUzNDIxMTcwNjc5ODIxNDgwODY1MTMyODIzMDY2NDcwOTM4NDQ2MDk1NTA1ODIyMzE3MjUzNTk0MDgxMjg0ODExMTc0NTAyODQxMDI3MDE5Mzg1MjExMDU1NTk2NDQ2MjI5NDg5NTQ5MzAzODE5NjQ0Mjg4MTA5NzU2NjU5MzM0NDYxMjg0NzU2NDgyMzM3ODY3ODMxNjUyNzEyMDE5MDkxNDU2NDg1NjY5MjM0NjAzNDg2MTA0NTQzMjY2NDgyMTMzOTM2MDcyNjAyNDkxNDEyNzM3MjQ1ODcwMDY2MDYzMTU1ODgxNzQ4ODE1MjA5MjA5NjI4MjkyNTQwOTE3MTUzNjQzNjc4OTI1OTAzNjAwMTEzMzA1MzA1NDg4MjA0NjY1MjEzODQxNDY5NTE5NDE1MTE2MDk0MzMwNTcyNzAzNjU3NTk1OTE5NTMwOTIxODYxMTczODE5MzI2MTE3OTMxMDUxMTg1NDgwNzQ0NjIzNzk5NjI3NDk1NjczNTE4ODU3NTI3MjQ4OTEyMjc5MzgxODMwMTE5NDkxMjk4MzM2NzMzNjI0NDA2NTY2NDMwODYwMjEzOTQ5NDYzOTUyMjQ3MzcxOTA3MDIxNzk4NjA5NDM3MDI3NzA1MzkyMTcxNzYyOTMxNzY3NTIzODQ2NzQ4MTg0Njc2Njk0MDUxMzIwMDA1NjgxMjcxNDUyNjM1NjA4Mjc3ODU3NzEzNDI3NTc3ODk2MDkxNzM2MzcxNzg3MjE0Njg0NDA5MDEyMjQ5NTM0MzAxNDY1NDk1ODUzNzEwNTA3OTIyNzk2ODkyNTg5MjM1NDIwMTk5NTYxMTIxMjkwMjE5NjA4NjQwMzQ0MTgxNTk4MTM2Mjk3NzQ3NzEzMDk5NjA1MTg3MDcyMTEzNDk5OTk5OTgzNzI5NzgwNDk5NTEwNTk3MzE3MzI4MTYwOTYzMTg1OTUwMjQ0NTk0NTUzNDY5MDgzMDI2NDI1MjIzMDgyNTMzNDQ2ODUwMzUyNjE5MzExODgxNzEwMTAwMDMxMzc4Mzg3NTI4ODY1ODc1MzMyMDgzODE0MjA2MTcxNzc2NjkxNDczMDM1OTgyNTM0OTA0Mjg3NTU0Njg3MzExNTk1NjI4NjM4ODIzNTM3ODc1OTM3NTE5NTc3ODE4NTc3ODA1MzIxNzEyMjY4MDY2MTMwMDE5Mjc4NzY2MTExOTU5MDkyMTY0MjAxOTg5MzgwOTUyNTcyMDEwNjU0ODU4NjMyNzg5XCI7XG52YXIgREVGQVVMVFMgPSB7XG4gIC8vIFRoZXNlIHZhbHVlcyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgc3RhdGVkIHJhbmdlcyAoaW5jbHVzaXZlKS5cbiAgLy8gTW9zdCBvZiB0aGVzZSB2YWx1ZXMgY2FuIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgdGhlIGBEZWNpbWFsLmNvbmZpZ2AgbWV0aG9kLlxuICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgYSBjYWxjdWxhdGlvbiBvciBiYXNlIGNvbnZlcnNpb24uXG4gIC8vIEUuZy4gYERlY2ltYWwuY29uZmlnKHsgcHJlY2lzaW9uOiAyMCB9KTtgXG4gIHByZWNpc2lvbjogMjAsXG4gIC8vIDEgdG8gTUFYX0RJR0lUU1xuICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gYHByZWNpc2lvbmAuXG4gIC8vXG4gIC8vIFJPVU5EX1VQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cbiAgLy8gUk9VTkRfRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cbiAgLy8gUk9VTkRfQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxuICAvLyBST1VORF9GTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXG4gIC8vIFJPVU5EX0hBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXG4gIC8vIFJPVU5EX0hBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cbiAgLy8gUk9VTkRfSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxuICAvLyBST1VORF9IQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxuICAvLyBST1VORF9IQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxuICAvL1xuICAvLyBFLmcuXG4gIC8vIGBEZWNpbWFsLnJvdW5kaW5nID0gNDtgXG4gIC8vIGBEZWNpbWFsLnJvdW5kaW5nID0gRGVjaW1hbC5ST1VORF9IQUxGX1VQO2BcbiAgcm91bmRpbmc6IDQsXG4gIC8vIDAgdG8gOFxuICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxuICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cbiAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cbiAgLy9cbiAgLy8gVVAgICAgICAgICAwIFRoZSByZW1haW5kZXIgaXMgcG9zaXRpdmUgaWYgdGhlIGRpdmlkZW5kIGlzIG5lZ2F0aXZlLCBlbHNlIGlzIG5lZ2F0aXZlLlxuICAvLyBET1dOICAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQgKEphdmFTY3JpcHQgJSkuXG4gIC8vIEZMT09SICAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXG4gIC8vIEhBTEZfRVZFTiAgNiBUaGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxuICAvLyBFVUNMSUQgICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLiBBbHdheXMgcG9zaXRpdmUuXG4gIC8vXG4gIC8vIFRydW5jYXRlZCBkaXZpc2lvbiAoMSksIGZsb29yZWQgZGl2aXNpb24gKDMpLCB0aGUgSUVFRSA3NTQgcmVtYWluZGVyICg2KSwgYW5kIEV1Y2xpZGlhblxuICAvLyBkaXZpc2lvbiAoOSkgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi4gVGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvXG4gIC8vIGJlIHVzZWQsIGJ1dCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cbiAgbW9kdWxvOiAxLFxuICAvLyAwIHRvIDlcbiAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIGB0b1N0cmluZ2AgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAgLy8gSmF2YVNjcmlwdCBudW1iZXJzOiAtN1xuICB0b0V4cE5lZzogLTcsXG4gIC8vIDAgdG8gLUVYUF9MSU1JVFxuICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIGB0b1N0cmluZ2AgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cbiAgLy8gSmF2YVNjcmlwdCBudW1iZXJzOiAyMVxuICB0b0V4cFBvczogMjEsXG4gIC8vIDAgdG8gRVhQX0xJTUlUXG4gIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cbiAgLy8gSmF2YVNjcmlwdCBudW1iZXJzOiAtMzI0ICAoNWUtMzI0KVxuICBtaW5FOiAtRVhQX0xJTUlULFxuICAvLyAtMSB0byAtRVhQX0xJTUlUXG4gIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IHZhbHVlLCBhYm92ZSB3aGljaCBvdmVyZmxvdyB0byBJbmZpbml0eSBvY2N1cnMuXG4gIC8vIEphdmFTY3JpcHQgbnVtYmVyczogMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXG4gIG1heEU6IEVYUF9MSU1JVCxcbiAgLy8gMSB0byBFWFBfTElNSVRcbiAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxuICBjcnlwdG86IGZhbHNlXG4gIC8vIHRydWUvZmFsc2Vcbn07XG52YXIgaW5leGFjdDtcbnZhciBxdWFkcmFudDtcbnZhciBleHRlcm5hbCA9IHRydWU7XG52YXIgZGVjaW1hbEVycm9yID0gXCJbRGVjaW1hbEVycm9yXSBcIjtcbnZhciBpbnZhbGlkQXJndW1lbnQgPSBkZWNpbWFsRXJyb3IgKyBcIkludmFsaWQgYXJndW1lbnQ6IFwiO1xudmFyIHByZWNpc2lvbkxpbWl0RXhjZWVkZWQgPSBkZWNpbWFsRXJyb3IgKyBcIlByZWNpc2lvbiBsaW1pdCBleGNlZWRlZFwiO1xudmFyIGNyeXB0b1VuYXZhaWxhYmxlID0gZGVjaW1hbEVycm9yICsgXCJjcnlwdG8gdW5hdmFpbGFibGVcIjtcbnZhciB0YWcgPSBcIltvYmplY3QgRGVjaW1hbF1cIjtcbnZhciBtYXRoZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIG1hdGhwb3cgPSBNYXRoLnBvdztcbnZhciBpc0JpbmFyeSA9IC9eMGIoWzAxXSsoXFwuWzAxXSopP3xcXC5bMDFdKykocFsrLV0/XFxkKyk/JC9pO1xudmFyIGlzSGV4ID0gL14weChbMC05YS1mXSsoXFwuWzAtOWEtZl0qKT98XFwuWzAtOWEtZl0rKShwWystXT9cXGQrKT8kL2k7XG52YXIgaXNPY3RhbCA9IC9eMG8oWzAtN10rKFxcLlswLTddKik/fFxcLlswLTddKykocFsrLV0/XFxkKyk/JC9pO1xudmFyIGlzRGVjaW1hbCA9IC9eKFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaTtcbnZhciBCQVNFID0gMWU3O1xudmFyIExPR19CQVNFID0gNztcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcbnZhciBMTjEwX1BSRUNJU0lPTiA9IExOMTAubGVuZ3RoIC0gMTtcbnZhciBQSV9QUkVDSVNJT04gPSBQSS5sZW5ndGggLSAxO1xudmFyIFAgPSB7IHRvU3RyaW5nVGFnOiB0YWcgfTtcblAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG4gIGlmICh4LnMgPCAwKSB4LnMgPSAxO1xuICByZXR1cm4gZmluYWxpc2UoeCk7XG59O1xuUC5jZWlsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmaW5hbGlzZShuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgdGhpcy5lICsgMSwgMik7XG59O1xuUC5jbGFtcGVkVG8gPSBQLmNsYW1wID0gZnVuY3Rpb24obWluMiwgbWF4Mikge1xuICB2YXIgaywgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBtaW4yID0gbmV3IEN0b3IobWluMik7XG4gIG1heDIgPSBuZXcgQ3RvcihtYXgyKTtcbiAgaWYgKCFtaW4yLnMgfHwgIW1heDIucykgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmIChtaW4yLmd0KG1heDIpKSB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBtYXgyKTtcbiAgayA9IHguY21wKG1pbjIpO1xuICByZXR1cm4gayA8IDAgPyBtaW4yIDogeC5jbXAobWF4MikgPiAwID8gbWF4MiA6IG5ldyBDdG9yKHgpO1xufTtcblAuY29tcGFyZWRUbyA9IFAuY21wID0gZnVuY3Rpb24oeSkge1xuICB2YXIgaSwgaiwgeGRMLCB5ZEwsIHggPSB0aGlzLCB4ZCA9IHguZCwgeWQgPSAoeSA9IG5ldyB4LmNvbnN0cnVjdG9yKHkpKS5kLCB4cyA9IHgucywgeXMgPSB5LnM7XG4gIGlmICgheGQgfHwgIXlkKSB7XG4gICAgcmV0dXJuICF4cyB8fCAheXMgPyBOYU4gOiB4cyAhPT0geXMgPyB4cyA6IHhkID09PSB5ZCA/IDAgOiAheGQgXiB4cyA8IDAgPyAxIDogLTE7XG4gIH1cbiAgaWYgKCF4ZFswXSB8fCAheWRbMF0pIHJldHVybiB4ZFswXSA/IHhzIDogeWRbMF0gPyAteXMgOiAwO1xuICBpZiAoeHMgIT09IHlzKSByZXR1cm4geHM7XG4gIGlmICh4LmUgIT09IHkuZSkgcmV0dXJuIHguZSA+IHkuZSBeIHhzIDwgMCA/IDEgOiAtMTtcbiAgeGRMID0geGQubGVuZ3RoO1xuICB5ZEwgPSB5ZC5sZW5ndGg7XG4gIGZvciAoaSA9IDAsIGogPSB4ZEwgPCB5ZEwgPyB4ZEwgOiB5ZEw7IGkgPCBqOyArK2kpIHtcbiAgICBpZiAoeGRbaV0gIT09IHlkW2ldKSByZXR1cm4geGRbaV0gPiB5ZFtpXSBeIHhzIDwgMCA/IDEgOiAtMTtcbiAgfVxuICByZXR1cm4geGRMID09PSB5ZEwgPyAwIDogeGRMID4geWRMIF4geHMgPCAwID8gMSA6IC0xO1xufTtcblAuY29zaW5lID0gUC5jb3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguZCkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmICgheC5kWzBdKSByZXR1cm4gbmV3IEN0b3IoMSk7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KHguZSwgeC5zZCgpKSArIExPR19CQVNFO1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgeCA9IGNvc2luZShDdG9yLCB0b0xlc3NUaGFuSGFsZlBpKEN0b3IsIHgpKTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPT0gMiB8fCBxdWFkcmFudCA9PSAzID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XG59O1xuUC5jdWJlUm9vdCA9IFAuY2JydCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZSwgbSwgbiwgciwgcmVwLCBzLCBzZCwgdCwgdDMsIHQzcGx1c3gsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4LmlzRmluaXRlKCkgfHwgeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICBzID0geC5zICogbWF0aHBvdyh4LnMgKiB4LCAxIC8gMyk7XG4gIGlmICghcyB8fCBNYXRoLmFicyhzKSA9PSAxIC8gMCkge1xuICAgIG4gPSBkaWdpdHNUb1N0cmluZyh4LmQpO1xuICAgIGUgPSB4LmU7XG4gICAgaWYgKHMgPSAoZSAtIG4ubGVuZ3RoICsgMSkgJSAzKSBuICs9IHMgPT0gMSB8fCBzID09IC0yID8gXCIwXCIgOiBcIjAwXCI7XG4gICAgcyA9IG1hdGhwb3cobiwgMSAvIDMpO1xuICAgIGUgPSBtYXRoZmxvb3IoKGUgKyAxKSAvIDMpIC0gKGUgJSAzID09IChlIDwgMCA/IC0xIDogMikpO1xuICAgIGlmIChzID09IDEgLyAwKSB7XG4gICAgICBuID0gXCI1ZVwiICsgZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xuICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKFwiZVwiKSArIDEpICsgZTtcbiAgICB9XG4gICAgciA9IG5ldyBDdG9yKG4pO1xuICAgIHIucyA9IHgucztcbiAgfSBlbHNlIHtcbiAgICByID0gbmV3IEN0b3Iocy50b1N0cmluZygpKTtcbiAgfVxuICBzZCA9IChlID0gQ3Rvci5wcmVjaXNpb24pICsgMztcbiAgZm9yICg7IDsgKSB7XG4gICAgdCA9IHI7XG4gICAgdDMgPSB0LnRpbWVzKHQpLnRpbWVzKHQpO1xuICAgIHQzcGx1c3ggPSB0My5wbHVzKHgpO1xuICAgIHIgPSBkaXZpZGUodDNwbHVzeC5wbHVzKHgpLnRpbWVzKHQpLCB0M3BsdXN4LnBsdXModDMpLCBzZCArIDIsIDEpO1xuICAgIGlmIChkaWdpdHNUb1N0cmluZyh0LmQpLnNsaWNlKDAsIHNkKSA9PT0gKG4gPSBkaWdpdHNUb1N0cmluZyhyLmQpKS5zbGljZSgwLCBzZCkpIHtcbiAgICAgIG4gPSBuLnNsaWNlKHNkIC0gMywgc2QgKyAxKTtcbiAgICAgIGlmIChuID09IFwiOTk5OVwiIHx8ICFyZXAgJiYgbiA9PSBcIjQ5OTlcIikge1xuICAgICAgICBpZiAoIXJlcCkge1xuICAgICAgICAgIGZpbmFsaXNlKHQsIGUgKyAxLCAwKTtcbiAgICAgICAgICBpZiAodC50aW1lcyh0KS50aW1lcyh0KS5lcSh4KSkge1xuICAgICAgICAgICAgciA9IHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2QgKz0gNDtcbiAgICAgICAgcmVwID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09IFwiNVwiKSB7XG4gICAgICAgICAgZmluYWxpc2UociwgZSArIDEsIDEpO1xuICAgICAgICAgIG0gPSAhci50aW1lcyhyKS50aW1lcyhyKS5lcSh4KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4gZmluYWxpc2UociwgZSwgQ3Rvci5yb3VuZGluZywgbSk7XG59O1xuUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdywgZCA9IHRoaXMuZCwgbiA9IE5hTjtcbiAgaWYgKGQpIHtcbiAgICB3ID0gZC5sZW5ndGggLSAxO1xuICAgIG4gPSAodyAtIG1hdGhmbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XG4gICAgdyA9IGRbd107XG4gICAgaWYgKHcpIGZvciAoOyB3ICUgMTAgPT0gMDsgdyAvPSAxMCkgbi0tO1xuICAgIGlmIChuIDwgMCkgbiA9IDA7XG4gIH1cbiAgcmV0dXJuIG47XG59O1xuUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uKHkpIHtcbiAgcmV0dXJuIGRpdmlkZSh0aGlzLCBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih5KSk7XG59O1xuUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmRpdlRvSW50ID0gZnVuY3Rpb24oeSkge1xuICB2YXIgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICByZXR1cm4gZmluYWxpc2UoZGl2aWRlKHgsIG5ldyBDdG9yKHkpLCAwLCAxLCAxKSwgQ3Rvci5wcmVjaXNpb24sIEN0b3Iucm91bmRpbmcpO1xufTtcblAuZXF1YWxzID0gUC5lcSA9IGZ1bmN0aW9uKHkpIHtcbiAgcmV0dXJuIHRoaXMuY21wKHkpID09PSAwO1xufTtcblAuZmxvb3IgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCB0aGlzLmUgKyAxLCAzKTtcbn07XG5QLmdyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uKHkpIHtcbiAgcmV0dXJuIHRoaXMuY21wKHkpID4gMDtcbn07XG5QLmdyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBrID0gdGhpcy5jbXAoeSk7XG4gIHJldHVybiBrID09IDEgfHwgayA9PT0gMDtcbn07XG5QLmh5cGVyYm9saWNDb3NpbmUgPSBQLmNvc2ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGssIG4sIHByLCBybSwgbGVuLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIG9uZSA9IG5ldyBDdG9yKDEpO1xuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKHgucyA/IDEgLyAwIDogTmFOKTtcbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBvbmU7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KHguZSwgeC5zZCgpKSArIDQ7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICBsZW4gPSB4LmQubGVuZ3RoO1xuICBpZiAobGVuIDwgMzIpIHtcbiAgICBrID0gTWF0aC5jZWlsKGxlbiAvIDMpO1xuICAgIG4gPSAoMSAvIHRpbnlQb3coNCwgaykpLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgayA9IDE2O1xuICAgIG4gPSBcIjIuMzI4MzA2NDM2NTM4Njk2Mjg5MDYyNWUtMTBcIjtcbiAgfVxuICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDEsIHgudGltZXMobiksIG5ldyBDdG9yKDEpLCB0cnVlKTtcbiAgdmFyIGNvc2gyX3gsIGkgPSBrLCBkOCA9IG5ldyBDdG9yKDgpO1xuICBmb3IgKDsgaS0tOyApIHtcbiAgICBjb3NoMl94ID0geC50aW1lcyh4KTtcbiAgICB4ID0gb25lLm1pbnVzKGNvc2gyX3gudGltZXMoZDgubWludXMoY29zaDJfeC50aW1lcyhkOCkpKSk7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXNlKHgsIEN0b3IucHJlY2lzaW9uID0gcHIsIEN0b3Iucm91bmRpbmcgPSBybSwgdHJ1ZSk7XG59O1xuUC5oeXBlcmJvbGljU2luZSA9IFAuc2luaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaywgcHIsIHJtLCBsZW4sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4LmlzRmluaXRlKCkgfHwgeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyA0O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgbGVuID0geC5kLmxlbmd0aDtcbiAgaWYgKGxlbiA8IDMpIHtcbiAgICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGsgPSAxLjQgKiBNYXRoLnNxcnQobGVuKTtcbiAgICBrID0gayA+IDE2ID8gMTYgOiBrIHwgMDtcbiAgICB4ID0geC50aW1lcygxIC8gdGlueVBvdyg1LCBrKSk7XG4gICAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4LCB0cnVlKTtcbiAgICB2YXIgc2luaDJfeCwgZDUgPSBuZXcgQ3Rvcig1KSwgZDE2ID0gbmV3IEN0b3IoMTYpLCBkMjAgPSBuZXcgQ3RvcigyMCk7XG4gICAgZm9yICg7IGstLTsgKSB7XG4gICAgICBzaW5oMl94ID0geC50aW1lcyh4KTtcbiAgICAgIHggPSB4LnRpbWVzKGQ1LnBsdXMoc2luaDJfeC50aW1lcyhkMTYudGltZXMoc2luaDJfeCkucGx1cyhkMjApKSkpO1xuICAgIH1cbiAgfVxuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiBmaW5hbGlzZSh4LCBwciwgcm0sIHRydWUpO1xufTtcblAuaHlwZXJib2xpY1RhbmdlbnQgPSBQLnRhbmggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKHgucyk7XG4gIGlmICh4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDc7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICByZXR1cm4gZGl2aWRlKHguc2luaCgpLCB4LmNvc2goKSwgQ3Rvci5wcmVjaXNpb24gPSBwciwgQ3Rvci5yb3VuZGluZyA9IHJtKTtcbn07XG5QLmludmVyc2VDb3NpbmUgPSBQLmFjb3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvciwgayA9IHguYWJzKCkuY21wKDEpLCBwciA9IEN0b3IucHJlY2lzaW9uLCBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGlmIChrICE9PSAtMSkge1xuICAgIHJldHVybiBrID09PSAwID8geC5pc05lZygpID8gZ2V0UGkoQ3RvciwgcHIsIHJtKSA6IG5ldyBDdG9yKDApIDogbmV3IEN0b3IoTmFOKTtcbiAgfVxuICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyA2O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgeCA9IG5ldyBDdG9yKDEpLm1pbnVzKHgpLmRpdih4LnBsdXMoMSkpLnNxcnQoKS5hdGFuKCk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIHgudGltZXMoMik7XG59O1xuUC5pbnZlcnNlSHlwZXJib2xpY0Nvc2luZSA9IFAuYWNvc2ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoeC5sdGUoMSkpIHJldHVybiBuZXcgQ3Rvcih4LmVxKDEpID8gMCA6IE5hTik7XG4gIGlmICgheC5pc0Zpbml0ZSgpKSByZXR1cm4gbmV3IEN0b3IoeCk7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KE1hdGguYWJzKHguZSksIHguc2QoKSkgKyA0O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgeCA9IHgudGltZXMoeCkubWludXMoMSkuc3FydCgpLnBsdXMoeCk7XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4geC5sbigpO1xufTtcblAuaW52ZXJzZUh5cGVyYm9saWNTaW5lID0gUC5hc2luaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcHIsIHJtLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgMiAqIE1hdGgubWF4KE1hdGguYWJzKHguZSksIHguc2QoKSkgKyA2O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgeCA9IHgudGltZXMoeCkucGx1cygxKS5zcXJ0KCkucGx1cyh4KTtcbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiB4LmxuKCk7XG59O1xuUC5pbnZlcnNlSHlwZXJib2xpY1RhbmdlbnQgPSBQLmF0YW5oID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwciwgcm0sIHdwciwgeHNkLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheC5pc0Zpbml0ZSgpKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgaWYgKHguZSA+PSAwKSByZXR1cm4gbmV3IEN0b3IoeC5hYnMoKS5lcSgxKSA/IHgucyAvIDAgOiB4LmlzWmVybygpID8geCA6IE5hTik7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgeHNkID0geC5zZCgpO1xuICBpZiAoTWF0aC5tYXgoeHNkLCBwcikgPCAyICogLXguZSAtIDEpIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgcHIsIHJtLCB0cnVlKTtcbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgPSB4c2QgLSB4LmU7XG4gIHggPSBkaXZpZGUoeC5wbHVzKDEpLCBuZXcgQ3RvcigxKS5taW51cyh4KSwgd3ByICsgcHIsIDEpO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNDtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIHggPSB4LmxuKCk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIHgudGltZXMoMC41KTtcbn07XG5QLmludmVyc2VTaW5lID0gUC5hc2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYWxmUGksIGssIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBrID0geC5hYnMoKS5jbXAoMSk7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgaWYgKGsgIT09IC0xKSB7XG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIGhhbGZQaSA9IGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XG4gICAgICBoYWxmUGkucyA9IHgucztcbiAgICAgIHJldHVybiBoYWxmUGk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICB9XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyA2O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgeCA9IHguZGl2KG5ldyBDdG9yKDEpLm1pbnVzKHgudGltZXMoeCkpLnNxcnQoKS5wbHVzKDEpKS5hdGFuKCk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIHgudGltZXMoMik7XG59O1xuUC5pbnZlcnNlVGFuZ2VudCA9IFAuYXRhbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaSwgaiwgaywgbiwgcHgsIHQsIHIsIHdwciwgeDIsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvciwgcHIgPSBDdG9yLnByZWNpc2lvbiwgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBpZiAoIXguaXNGaW5pdGUoKSkge1xuICAgIGlmICgheC5zKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgICBpZiAocHIgKyA0IDw9IFBJX1BSRUNJU0lPTikge1xuICAgICAgciA9IGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XG4gICAgICByLnMgPSB4LnM7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeC5pc1plcm8oKSkge1xuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgfSBlbHNlIGlmICh4LmFicygpLmVxKDEpICYmIHByICsgNCA8PSBQSV9QUkVDSVNJT04pIHtcbiAgICByID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC4yNSk7XG4gICAgci5zID0geC5zO1xuICAgIHJldHVybiByO1xuICB9XG4gIEN0b3IucHJlY2lzaW9uID0gd3ByID0gcHIgKyAxMDtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIGsgPSBNYXRoLm1pbigyOCwgd3ByIC8gTE9HX0JBU0UgKyAyIHwgMCk7XG4gIGZvciAoaSA9IGs7IGk7IC0taSkgeCA9IHguZGl2KHgudGltZXMoeCkucGx1cygxKS5zcXJ0KCkucGx1cygxKSk7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIGogPSBNYXRoLmNlaWwod3ByIC8gTE9HX0JBU0UpO1xuICBuID0gMTtcbiAgeDIgPSB4LnRpbWVzKHgpO1xuICByID0gbmV3IEN0b3IoeCk7XG4gIHB4ID0geDtcbiAgZm9yICg7IGkgIT09IC0xOyApIHtcbiAgICBweCA9IHB4LnRpbWVzKHgyKTtcbiAgICB0ID0gci5taW51cyhweC5kaXYobiArPSAyKSk7XG4gICAgcHggPSBweC50aW1lcyh4Mik7XG4gICAgciA9IHQucGx1cyhweC5kaXYobiArPSAyKSk7XG4gICAgaWYgKHIuZFtqXSAhPT0gdm9pZCAwKSBmb3IgKGkgPSBqOyByLmRbaV0gPT09IHQuZFtpXSAmJiBpLS07ICkgO1xuICB9XG4gIGlmIChrKSByID0gci50aW1lcygyIDw8IGsgLSAxKTtcbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4gZmluYWxpc2UociwgQ3Rvci5wcmVjaXNpb24gPSBwciwgQ3Rvci5yb3VuZGluZyA9IHJtLCB0cnVlKTtcbn07XG5QLmlzRmluaXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIXRoaXMuZDtcbn07XG5QLmlzSW50ZWdlciA9IFAuaXNJbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhdGhpcy5kICYmIG1hdGhmbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkgPiB0aGlzLmQubGVuZ3RoIC0gMjtcbn07XG5QLmlzTmFOID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5zO1xufTtcblAuaXNOZWdhdGl2ZSA9IFAuaXNOZWcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucyA8IDA7XG59O1xuUC5pc1Bvc2l0aXZlID0gUC5pc1BvcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zID4gMDtcbn07XG5QLmlzWmVybyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISF0aGlzLmQgJiYgdGhpcy5kWzBdID09PSAwO1xufTtcblAubGVzc1RoYW4gPSBQLmx0ID0gZnVuY3Rpb24oeSkge1xuICByZXR1cm4gdGhpcy5jbXAoeSkgPCAwO1xufTtcblAubGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uKHkpIHtcbiAgcmV0dXJuIHRoaXMuY21wKHkpIDwgMTtcbn07XG5QLmxvZ2FyaXRobSA9IFAubG9nID0gZnVuY3Rpb24oYmFzZSkge1xuICB2YXIgaXNCYXNlMTAsIGQsIGRlbm9taW5hdG9yLCBrLCBpbmYsIG51bSwgc2QsIHIsIGFyZyA9IHRoaXMsIEN0b3IgPSBhcmcuY29uc3RydWN0b3IsIHByID0gQ3Rvci5wcmVjaXNpb24sIHJtID0gQ3Rvci5yb3VuZGluZywgZ3VhcmQgPSA1O1xuICBpZiAoYmFzZSA9PSBudWxsKSB7XG4gICAgYmFzZSA9IG5ldyBDdG9yKDEwKTtcbiAgICBpc0Jhc2UxMCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgYmFzZSA9IG5ldyBDdG9yKGJhc2UpO1xuICAgIGQgPSBiYXNlLmQ7XG4gICAgaWYgKGJhc2UucyA8IDAgfHwgIWQgfHwgIWRbMF0gfHwgYmFzZS5lcSgxKSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gICAgaXNCYXNlMTAgPSBiYXNlLmVxKDEwKTtcbiAgfVxuICBkID0gYXJnLmQ7XG4gIGlmIChhcmcucyA8IDAgfHwgIWQgfHwgIWRbMF0gfHwgYXJnLmVxKDEpKSB7XG4gICAgcmV0dXJuIG5ldyBDdG9yKGQgJiYgIWRbMF0gPyAtMSAvIDAgOiBhcmcucyAhPSAxID8gTmFOIDogZCA/IDAgOiAxIC8gMCk7XG4gIH1cbiAgaWYgKGlzQmFzZTEwKSB7XG4gICAgaWYgKGQubGVuZ3RoID4gMSkge1xuICAgICAgaW5mID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChrID0gZFswXTsgayAlIDEwID09PSAwOyApIGsgLz0gMTA7XG4gICAgICBpbmYgPSBrICE9PSAxO1xuICAgIH1cbiAgfVxuICBleHRlcm5hbCA9IGZhbHNlO1xuICBzZCA9IHByICsgZ3VhcmQ7XG4gIG51bSA9IG5hdHVyYWxMb2dhcml0aG0oYXJnLCBzZCk7XG4gIGRlbm9taW5hdG9yID0gaXNCYXNlMTAgPyBnZXRMbjEwKEN0b3IsIHNkICsgMTApIDogbmF0dXJhbExvZ2FyaXRobShiYXNlLCBzZCk7XG4gIHIgPSBkaXZpZGUobnVtLCBkZW5vbWluYXRvciwgc2QsIDEpO1xuICBpZiAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhyLmQsIGsgPSBwciwgcm0pKSB7XG4gICAgZG8ge1xuICAgICAgc2QgKz0gMTA7XG4gICAgICBudW0gPSBuYXR1cmFsTG9nYXJpdGhtKGFyZywgc2QpO1xuICAgICAgZGVub21pbmF0b3IgPSBpc0Jhc2UxMCA/IGdldExuMTAoQ3Rvciwgc2QgKyAxMCkgOiBuYXR1cmFsTG9nYXJpdGhtKGJhc2UsIHNkKTtcbiAgICAgIHIgPSBkaXZpZGUobnVtLCBkZW5vbWluYXRvciwgc2QsIDEpO1xuICAgICAgaWYgKCFpbmYpIHtcbiAgICAgICAgaWYgKCtkaWdpdHNUb1N0cmluZyhyLmQpLnNsaWNlKGsgKyAxLCBrICsgMTUpICsgMSA9PSAxZTE0KSB7XG4gICAgICAgICAgciA9IGZpbmFsaXNlKHIsIHByICsgMSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhyLmQsIGsgKz0gMTAsIHJtKSk7XG4gIH1cbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4gZmluYWxpc2UociwgcHIsIHJtKTtcbn07XG5QLm1pbnVzID0gUC5zdWIgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBkLCBlLCBpLCBqLCBrLCBsZW4sIHByLCBybSwgeGQsIHhlLCB4TFR5LCB5ZCwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICB5ID0gbmV3IEN0b3IoeSk7XG4gIGlmICgheC5kIHx8ICF5LmQpIHtcbiAgICBpZiAoIXgucyB8fCAheS5zKSB5ID0gbmV3IEN0b3IoTmFOKTtcbiAgICBlbHNlIGlmICh4LmQpIHkucyA9IC15LnM7XG4gICAgZWxzZSB5ID0gbmV3IEN0b3IoeS5kIHx8IHgucyAhPT0geS5zID8geCA6IE5hTik7XG4gICAgcmV0dXJuIHk7XG4gIH1cbiAgaWYgKHgucyAhPSB5LnMpIHtcbiAgICB5LnMgPSAteS5zO1xuICAgIHJldHVybiB4LnBsdXMoeSk7XG4gIH1cbiAgeGQgPSB4LmQ7XG4gIHlkID0geS5kO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGlmICgheGRbMF0gfHwgIXlkWzBdKSB7XG4gICAgaWYgKHlkWzBdKSB5LnMgPSAteS5zO1xuICAgIGVsc2UgaWYgKHhkWzBdKSB5ID0gbmV3IEN0b3IoeCk7XG4gICAgZWxzZSByZXR1cm4gbmV3IEN0b3Iocm0gPT09IDMgPyAtMCA6IDApO1xuICAgIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xuICB9XG4gIGUgPSBtYXRoZmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xuICB4ZSA9IG1hdGhmbG9vcih4LmUgLyBMT0dfQkFTRSk7XG4gIHhkID0geGQuc2xpY2UoKTtcbiAgayA9IHhlIC0gZTtcbiAgaWYgKGspIHtcbiAgICB4TFR5ID0gayA8IDA7XG4gICAgaWYgKHhMVHkpIHtcbiAgICAgIGQgPSB4ZDtcbiAgICAgIGsgPSAtaztcbiAgICAgIGxlbiA9IHlkLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IHlkO1xuICAgICAgZSA9IHhlO1xuICAgICAgbGVuID0geGQubGVuZ3RoO1xuICAgIH1cbiAgICBpID0gTWF0aC5tYXgoTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpLCBsZW4pICsgMjtcbiAgICBpZiAoayA+IGkpIHtcbiAgICAgIGsgPSBpO1xuICAgICAgZC5sZW5ndGggPSAxO1xuICAgIH1cbiAgICBkLnJldmVyc2UoKTtcbiAgICBmb3IgKGkgPSBrOyBpLS07ICkgZC5wdXNoKDApO1xuICAgIGQucmV2ZXJzZSgpO1xuICB9IGVsc2Uge1xuICAgIGkgPSB4ZC5sZW5ndGg7XG4gICAgbGVuID0geWQubGVuZ3RoO1xuICAgIHhMVHkgPSBpIDwgbGVuO1xuICAgIGlmICh4TFR5KSBsZW4gPSBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHhkW2ldICE9IHlkW2ldKSB7XG4gICAgICAgIHhMVHkgPSB4ZFtpXSA8IHlkW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgayA9IDA7XG4gIH1cbiAgaWYgKHhMVHkpIHtcbiAgICBkID0geGQ7XG4gICAgeGQgPSB5ZDtcbiAgICB5ZCA9IGQ7XG4gICAgeS5zID0gLXkucztcbiAgfVxuICBsZW4gPSB4ZC5sZW5ndGg7XG4gIGZvciAoaSA9IHlkLmxlbmd0aCAtIGxlbjsgaSA+IDA7IC0taSkgeGRbbGVuKytdID0gMDtcbiAgZm9yIChpID0geWQubGVuZ3RoOyBpID4gazsgKSB7XG4gICAgaWYgKHhkWy0taV0gPCB5ZFtpXSkge1xuICAgICAgZm9yIChqID0gaTsgaiAmJiB4ZFstLWpdID09PSAwOyApIHhkW2pdID0gQkFTRSAtIDE7XG4gICAgICAtLXhkW2pdO1xuICAgICAgeGRbaV0gKz0gQkFTRTtcbiAgICB9XG4gICAgeGRbaV0gLT0geWRbaV07XG4gIH1cbiAgZm9yICg7IHhkWy0tbGVuXSA9PT0gMDsgKSB4ZC5wb3AoKTtcbiAgZm9yICg7IHhkWzBdID09PSAwOyB4ZC5zaGlmdCgpKSAtLWU7XG4gIGlmICgheGRbMF0pIHJldHVybiBuZXcgQ3RvcihybSA9PT0gMyA/IC0wIDogMCk7XG4gIHkuZCA9IHhkO1xuICB5LmUgPSBnZXRCYXNlMTBFeHBvbmVudCh4ZCwgZSk7XG4gIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xufTtcblAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBxLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIHkgPSBuZXcgQ3Rvcih5KTtcbiAgaWYgKCF4LmQgfHwgIXkucyB8fCB5LmQgJiYgIXkuZFswXSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmICgheS5kIHx8IHguZCAmJiAheC5kWzBdKSB7XG4gICAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBDdG9yLnByZWNpc2lvbiwgQ3Rvci5yb3VuZGluZyk7XG4gIH1cbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgaWYgKEN0b3IubW9kdWxvID09IDkpIHtcbiAgICBxID0gZGl2aWRlKHgsIHkuYWJzKCksIDAsIDMsIDEpO1xuICAgIHEucyAqPSB5LnM7XG4gIH0gZWxzZSB7XG4gICAgcSA9IGRpdmlkZSh4LCB5LCAwLCBDdG9yLm1vZHVsbywgMSk7XG4gIH1cbiAgcSA9IHEudGltZXMoeSk7XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIHgubWludXMocSk7XG59O1xuUC5uYXR1cmFsRXhwb25lbnRpYWwgPSBQLmV4cCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmF0dXJhbEV4cG9uZW50aWFsKHRoaXMpO1xufTtcblAubmF0dXJhbExvZ2FyaXRobSA9IFAubG4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5hdHVyYWxMb2dhcml0aG0odGhpcyk7XG59O1xuUC5uZWdhdGVkID0gUC5uZWcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgeC5zID0gLXgucztcbiAgcmV0dXJuIGZpbmFsaXNlKHgpO1xufTtcblAucGx1cyA9IFAuYWRkID0gZnVuY3Rpb24oeSkge1xuICB2YXIgY2FycnksIGQsIGUsIGksIGssIGxlbiwgcHIsIHJtLCB4ZCwgeWQsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgeSA9IG5ldyBDdG9yKHkpO1xuICBpZiAoIXguZCB8fCAheS5kKSB7XG4gICAgaWYgKCF4LnMgfHwgIXkucykgeSA9IG5ldyBDdG9yKE5hTik7XG4gICAgZWxzZSBpZiAoIXguZCkgeSA9IG5ldyBDdG9yKHkuZCB8fCB4LnMgPT09IHkucyA/IHggOiBOYU4pO1xuICAgIHJldHVybiB5O1xuICB9XG4gIGlmICh4LnMgIT0geS5zKSB7XG4gICAgeS5zID0gLXkucztcbiAgICByZXR1cm4geC5taW51cyh5KTtcbiAgfVxuICB4ZCA9IHguZDtcbiAgeWQgPSB5LmQ7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgaWYgKCF4ZFswXSB8fCAheWRbMF0pIHtcbiAgICBpZiAoIXlkWzBdKSB5ID0gbmV3IEN0b3IoeCk7XG4gICAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgcHIsIHJtKSA6IHk7XG4gIH1cbiAgayA9IG1hdGhmbG9vcih4LmUgLyBMT0dfQkFTRSk7XG4gIGUgPSBtYXRoZmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xuICB4ZCA9IHhkLnNsaWNlKCk7XG4gIGkgPSBrIC0gZTtcbiAgaWYgKGkpIHtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIGQgPSB4ZDtcbiAgICAgIGkgPSAtaTtcbiAgICAgIGxlbiA9IHlkLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IHlkO1xuICAgICAgZSA9IGs7XG4gICAgICBsZW4gPSB4ZC5sZW5ndGg7XG4gICAgfVxuICAgIGsgPSBNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSk7XG4gICAgbGVuID0gayA+IGxlbiA/IGsgKyAxIDogbGVuICsgMTtcbiAgICBpZiAoaSA+IGxlbikge1xuICAgICAgaSA9IGxlbjtcbiAgICAgIGQubGVuZ3RoID0gMTtcbiAgICB9XG4gICAgZC5yZXZlcnNlKCk7XG4gICAgZm9yICg7IGktLTsgKSBkLnB1c2goMCk7XG4gICAgZC5yZXZlcnNlKCk7XG4gIH1cbiAgbGVuID0geGQubGVuZ3RoO1xuICBpID0geWQubGVuZ3RoO1xuICBpZiAobGVuIC0gaSA8IDApIHtcbiAgICBpID0gbGVuO1xuICAgIGQgPSB5ZDtcbiAgICB5ZCA9IHhkO1xuICAgIHhkID0gZDtcbiAgfVxuICBmb3IgKGNhcnJ5ID0gMDsgaTsgKSB7XG4gICAgY2FycnkgPSAoeGRbLS1pXSA9IHhkW2ldICsgeWRbaV0gKyBjYXJyeSkgLyBCQVNFIHwgMDtcbiAgICB4ZFtpXSAlPSBCQVNFO1xuICB9XG4gIGlmIChjYXJyeSkge1xuICAgIHhkLnVuc2hpZnQoY2FycnkpO1xuICAgICsrZTtcbiAgfVxuICBmb3IgKGxlbiA9IHhkLmxlbmd0aDsgeGRbLS1sZW5dID09IDA7ICkgeGQucG9wKCk7XG4gIHkuZCA9IHhkO1xuICB5LmUgPSBnZXRCYXNlMTBFeHBvbmVudCh4ZCwgZSk7XG4gIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xufTtcblAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uKHopIHtcbiAgdmFyIGssIHggPSB0aGlzO1xuICBpZiAoeiAhPT0gdm9pZCAwICYmIHogIT09ICEheiAmJiB6ICE9PSAxICYmIHogIT09IDApIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHopO1xuICBpZiAoeC5kKSB7XG4gICAgayA9IGdldFByZWNpc2lvbih4LmQpO1xuICAgIGlmICh6ICYmIHguZSArIDEgPiBrKSBrID0geC5lICsgMTtcbiAgfSBlbHNlIHtcbiAgICBrID0gTmFOO1xuICB9XG4gIHJldHVybiBrO1xufTtcblAucm91bmQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCB4LmUgKyAxLCBDdG9yLnJvdW5kaW5nKTtcbn07XG5QLnNpbmUgPSBQLnNpbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcHIsIHJtLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheC5pc0Zpbml0ZSgpKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgTE9HX0JBU0U7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICB4ID0gc2luZShDdG9yLCB0b0xlc3NUaGFuSGFsZlBpKEN0b3IsIHgpKTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPiAyID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XG59O1xuUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtLCBuLCBzZCwgciwgcmVwLCB0LCB4ID0gdGhpcywgZCA9IHguZCwgZSA9IHguZSwgcyA9IHgucywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmIChzICE9PSAxIHx8ICFkIHx8ICFkWzBdKSB7XG4gICAgcmV0dXJuIG5ldyBDdG9yKCFzIHx8IHMgPCAwICYmICghZCB8fCBkWzBdKSA/IE5hTiA6IGQgPyB4IDogMSAvIDApO1xuICB9XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIHMgPSBNYXRoLnNxcnQoK3gpO1xuICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcbiAgICBuID0gZGlnaXRzVG9TdHJpbmcoZCk7XG4gICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9IFwiMFwiO1xuICAgIHMgPSBNYXRoLnNxcnQobik7XG4gICAgZSA9IG1hdGhmbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xuICAgIGlmIChzID09IDEgLyAwKSB7XG4gICAgICBuID0gXCI1ZVwiICsgZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xuICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKFwiZVwiKSArIDEpICsgZTtcbiAgICB9XG4gICAgciA9IG5ldyBDdG9yKG4pO1xuICB9IGVsc2Uge1xuICAgIHIgPSBuZXcgQ3RvcihzLnRvU3RyaW5nKCkpO1xuICB9XG4gIHNkID0gKGUgPSBDdG9yLnByZWNpc2lvbikgKyAzO1xuICBmb3IgKDsgOyApIHtcbiAgICB0ID0gcjtcbiAgICByID0gdC5wbHVzKGRpdmlkZSh4LCB0LCBzZCArIDIsIDEpKS50aW1lcygwLjUpO1xuICAgIGlmIChkaWdpdHNUb1N0cmluZyh0LmQpLnNsaWNlKDAsIHNkKSA9PT0gKG4gPSBkaWdpdHNUb1N0cmluZyhyLmQpKS5zbGljZSgwLCBzZCkpIHtcbiAgICAgIG4gPSBuLnNsaWNlKHNkIC0gMywgc2QgKyAxKTtcbiAgICAgIGlmIChuID09IFwiOTk5OVwiIHx8ICFyZXAgJiYgbiA9PSBcIjQ5OTlcIikge1xuICAgICAgICBpZiAoIXJlcCkge1xuICAgICAgICAgIGZpbmFsaXNlKHQsIGUgKyAxLCAwKTtcbiAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xuICAgICAgICAgICAgciA9IHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2QgKz0gNDtcbiAgICAgICAgcmVwID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09IFwiNVwiKSB7XG4gICAgICAgICAgZmluYWxpc2UociwgZSArIDEsIDEpO1xuICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4gZmluYWxpc2UociwgZSwgQ3Rvci5yb3VuZGluZywgbSk7XG59O1xuUC50YW5nZW50ID0gUC50YW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmICh4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDEwO1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgeCA9IHguc2luKCk7XG4gIHgucyA9IDE7XG4gIHggPSBkaXZpZGUoeCwgbmV3IEN0b3IoMSkubWludXMoeC50aW1lcyh4KSkuc3FydCgpLCBwciArIDEwLCAwKTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPT0gMiB8fCBxdWFkcmFudCA9PSA0ID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XG59O1xuUC50aW1lcyA9IFAubXVsID0gZnVuY3Rpb24oeSkge1xuICB2YXIgY2FycnksIGUsIGksIGssIHIsIHJMLCB0LCB4ZEwsIHlkTCwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCB4ZCA9IHguZCwgeWQgPSAoeSA9IG5ldyBDdG9yKHkpKS5kO1xuICB5LnMgKj0geC5zO1xuICBpZiAoIXhkIHx8ICF4ZFswXSB8fCAheWQgfHwgIXlkWzBdKSB7XG4gICAgcmV0dXJuIG5ldyBDdG9yKCF5LnMgfHwgeGQgJiYgIXhkWzBdICYmICF5ZCB8fCB5ZCAmJiAheWRbMF0gJiYgIXhkID8gTmFOIDogIXhkIHx8ICF5ZCA/IHkucyAvIDAgOiB5LnMgKiAwKTtcbiAgfVxuICBlID0gbWF0aGZsb29yKHguZSAvIExPR19CQVNFKSArIG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XG4gIHhkTCA9IHhkLmxlbmd0aDtcbiAgeWRMID0geWQubGVuZ3RoO1xuICBpZiAoeGRMIDwgeWRMKSB7XG4gICAgciA9IHhkO1xuICAgIHhkID0geWQ7XG4gICAgeWQgPSByO1xuICAgIHJMID0geGRMO1xuICAgIHhkTCA9IHlkTDtcbiAgICB5ZEwgPSByTDtcbiAgfVxuICByID0gW107XG4gIHJMID0geGRMICsgeWRMO1xuICBmb3IgKGkgPSByTDsgaS0tOyApIHIucHVzaCgwKTtcbiAgZm9yIChpID0geWRMOyAtLWkgPj0gMDsgKSB7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoayA9IHhkTCArIGk7IGsgPiBpOyApIHtcbiAgICAgIHQgPSByW2tdICsgeWRbaV0gKiB4ZFtrIC0gaSAtIDFdICsgY2Fycnk7XG4gICAgICByW2stLV0gPSB0ICUgQkFTRSB8IDA7XG4gICAgICBjYXJyeSA9IHQgLyBCQVNFIHwgMDtcbiAgICB9XG4gICAgcltrXSA9IChyW2tdICsgY2FycnkpICUgQkFTRSB8IDA7XG4gIH1cbiAgZm9yICg7ICFyWy0tckxdOyApIHIucG9wKCk7XG4gIGlmIChjYXJyeSkgKytlO1xuICBlbHNlIHIuc2hpZnQoKTtcbiAgeS5kID0gcjtcbiAgeS5lID0gZ2V0QmFzZTEwRXhwb25lbnQociwgZSk7XG4gIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIEN0b3IucHJlY2lzaW9uLCBDdG9yLnJvdW5kaW5nKSA6IHk7XG59O1xuUC50b0JpbmFyeSA9IGZ1bmN0aW9uKHNkLCBybSkge1xuICByZXR1cm4gdG9TdHJpbmdCaW5hcnkodGhpcywgMiwgc2QsIHJtKTtcbn07XG5QLnRvRGVjaW1hbFBsYWNlcyA9IFAudG9EUCA9IGZ1bmN0aW9uKGRwLCBybSkge1xuICB2YXIgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICB4ID0gbmV3IEN0b3IoeCk7XG4gIGlmIChkcCA9PT0gdm9pZCAwKSByZXR1cm4geDtcbiAgY2hlY2tJbnQzMihkcCwgMCwgTUFYX0RJR0lUUyk7XG4gIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGVsc2UgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gIHJldHVybiBmaW5hbGlzZSh4LCBkcCArIHguZSArIDEsIHJtKTtcbn07XG5QLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbihkcCwgcm0pIHtcbiAgdmFyIHN0ciwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoZHAgPT09IHZvaWQgMCkge1xuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGNoZWNrSW50MzIoZHAsIDAsIE1BWF9ESUdJVFMpO1xuICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcbiAgICB4ID0gZmluYWxpc2UobmV3IEN0b3IoeCksIGRwICsgMSwgcm0pO1xuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHRydWUsIGRwICsgMSk7XG4gIH1cbiAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/IFwiLVwiICsgc3RyIDogc3RyO1xufTtcblAudG9GaXhlZCA9IGZ1bmN0aW9uKGRwLCBybSkge1xuICB2YXIgc3RyLCB5LCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmIChkcCA9PT0gdm9pZCAwKSB7XG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCk7XG4gIH0gZWxzZSB7XG4gICAgY2hlY2tJbnQzMihkcCwgMCwgTUFYX0RJR0lUUyk7XG4gICAgaWYgKHJtID09PSB2b2lkIDApIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xuICAgIHkgPSBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeSwgZmFsc2UsIGRwICsgeS5lICsgMSk7XG4gIH1cbiAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/IFwiLVwiICsgc3RyIDogc3RyO1xufTtcblAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uKG1heEQpIHtcbiAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGssIG4sIG4wLCBuMSwgcHIsIHEsIHIsIHggPSB0aGlzLCB4ZCA9IHguZCwgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheGQpIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgbjEgPSBkMCA9IG5ldyBDdG9yKDEpO1xuICBkMSA9IG4wID0gbmV3IEN0b3IoMCk7XG4gIGQgPSBuZXcgQ3RvcihkMSk7XG4gIGUgPSBkLmUgPSBnZXRQcmVjaXNpb24oeGQpIC0geC5lIC0gMTtcbiAgayA9IGUgJSBMT0dfQkFTRTtcbiAgZC5kWzBdID0gbWF0aHBvdygxMCwgayA8IDAgPyBMT0dfQkFTRSArIGsgOiBrKTtcbiAgaWYgKG1heEQgPT0gbnVsbCkge1xuICAgIG1heEQgPSBlID4gMCA/IGQgOiBuMTtcbiAgfSBlbHNlIHtcbiAgICBuID0gbmV3IEN0b3IobWF4RCk7XG4gICAgaWYgKCFuLmlzSW50KCkgfHwgbi5sdChuMSkpIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIG4pO1xuICAgIG1heEQgPSBuLmd0KGQpID8gZSA+IDAgPyBkIDogbjEgOiBuO1xuICB9XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIG4gPSBuZXcgQ3RvcihkaWdpdHNUb1N0cmluZyh4ZCkpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBDdG9yLnByZWNpc2lvbiA9IGUgPSB4ZC5sZW5ndGggKiBMT0dfQkFTRSAqIDI7XG4gIGZvciAoOyA7ICkge1xuICAgIHEgPSBkaXZpZGUobiwgZCwgMCwgMSwgMSk7XG4gICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcbiAgICBpZiAoZDIuY21wKG1heEQpID09IDEpIGJyZWFrO1xuICAgIGQwID0gZDE7XG4gICAgZDEgPSBkMjtcbiAgICBkMiA9IG4xO1xuICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyKSk7XG4gICAgbjAgPSBkMjtcbiAgICBkMiA9IGQ7XG4gICAgZCA9IG4ubWludXMocS50aW1lcyhkMikpO1xuICAgIG4gPSBkMjtcbiAgfVxuICBkMiA9IGRpdmlkZShtYXhELm1pbnVzKGQwKSwgZDEsIDAsIDEsIDEpO1xuICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcbiAgZDAgPSBkMC5wbHVzKGQyLnRpbWVzKGQxKSk7XG4gIG4wLnMgPSBuMS5zID0geC5zO1xuICByID0gZGl2aWRlKG4xLCBkMSwgZSwgMSkubWludXMoeCkuYWJzKCkuY21wKGRpdmlkZShuMCwgZDAsIGUsIDEpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiByO1xufTtcblAudG9IZXhhZGVjaW1hbCA9IFAudG9IZXggPSBmdW5jdGlvbihzZCwgcm0pIHtcbiAgcmV0dXJuIHRvU3RyaW5nQmluYXJ5KHRoaXMsIDE2LCBzZCwgcm0pO1xufTtcblAudG9OZWFyZXN0ID0gZnVuY3Rpb24oeSwgcm0pIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgeCA9IG5ldyBDdG9yKHgpO1xuICBpZiAoeSA9PSBudWxsKSB7XG4gICAgaWYgKCF4LmQpIHJldHVybiB4O1xuICAgIHkgPSBuZXcgQ3RvcigxKTtcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIH0gZWxzZSB7XG4gICAgeSA9IG5ldyBDdG9yKHkpO1xuICAgIGlmIChybSA9PT0gdm9pZCAwKSB7XG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoZWNrSW50MzIocm0sIDAsIDgpO1xuICAgIH1cbiAgICBpZiAoIXguZCkgcmV0dXJuIHkucyA/IHggOiB5O1xuICAgIGlmICgheS5kKSB7XG4gICAgICBpZiAoeS5zKSB5LnMgPSB4LnM7XG4gICAgICByZXR1cm4geTtcbiAgICB9XG4gIH1cbiAgaWYgKHkuZFswXSkge1xuICAgIGV4dGVybmFsID0gZmFsc2U7XG4gICAgeCA9IGRpdmlkZSh4LCB5LCAwLCBybSwgMSkudGltZXMoeSk7XG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xuICAgIGZpbmFsaXNlKHgpO1xuICB9IGVsc2Uge1xuICAgIHkucyA9IHgucztcbiAgICB4ID0geTtcbiAgfVxuICByZXR1cm4geDtcbn07XG5QLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiArdGhpcztcbn07XG5QLnRvT2N0YWwgPSBmdW5jdGlvbihzZCwgcm0pIHtcbiAgcmV0dXJuIHRvU3RyaW5nQmluYXJ5KHRoaXMsIDgsIHNkLCBybSk7XG59O1xuUC50b1Bvd2VyID0gUC5wb3cgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBlLCBrLCBwciwgciwgcm0sIHMsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvciwgeW4gPSArKHkgPSBuZXcgQ3Rvcih5KSk7XG4gIGlmICgheC5kIHx8ICF5LmQgfHwgIXguZFswXSB8fCAheS5kWzBdKSByZXR1cm4gbmV3IEN0b3IobWF0aHBvdygreCwgeW4pKTtcbiAgeCA9IG5ldyBDdG9yKHgpO1xuICBpZiAoeC5lcSgxKSkgcmV0dXJuIHg7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgaWYgKHkuZXEoMSkpIHJldHVybiBmaW5hbGlzZSh4LCBwciwgcm0pO1xuICBlID0gbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcbiAgaWYgKGUgPj0geS5kLmxlbmd0aCAtIDEgJiYgKGsgPSB5biA8IDAgPyAteW4gOiB5bikgPD0gTUFYX1NBRkVfSU5URUdFUikge1xuICAgIHIgPSBpbnRQb3coQ3RvciwgeCwgaywgcHIpO1xuICAgIHJldHVybiB5LnMgPCAwID8gbmV3IEN0b3IoMSkuZGl2KHIpIDogZmluYWxpc2UociwgcHIsIHJtKTtcbiAgfVxuICBzID0geC5zO1xuICBpZiAocyA8IDApIHtcbiAgICBpZiAoZSA8IHkuZC5sZW5ndGggLSAxKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgICBpZiAoKHkuZFtlXSAmIDEpID09IDApIHMgPSAxO1xuICAgIGlmICh4LmUgPT0gMCAmJiB4LmRbMF0gPT0gMSAmJiB4LmQubGVuZ3RoID09IDEpIHtcbiAgICAgIHgucyA9IHM7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gIH1cbiAgayA9IG1hdGhwb3coK3gsIHluKTtcbiAgZSA9IGsgPT0gMCB8fCAhaXNGaW5pdGUoaykgPyBtYXRoZmxvb3IoeW4gKiAoTWF0aC5sb2coXCIwLlwiICsgZGlnaXRzVG9TdHJpbmcoeC5kKSkgLyBNYXRoLkxOMTAgKyB4LmUgKyAxKSkgOiBuZXcgQ3RvcihrICsgXCJcIikuZTtcbiAgaWYgKGUgPiBDdG9yLm1heEUgKyAxIHx8IGUgPCBDdG9yLm1pbkUgLSAxKSByZXR1cm4gbmV3IEN0b3IoZSA+IDAgPyBzIC8gMCA6IDApO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICBDdG9yLnJvdW5kaW5nID0geC5zID0gMTtcbiAgayA9IE1hdGgubWluKDEyLCAoZSArIFwiXCIpLmxlbmd0aCk7XG4gIHIgPSBuYXR1cmFsRXhwb25lbnRpYWwoeS50aW1lcyhuYXR1cmFsTG9nYXJpdGhtKHgsIHByICsgaykpLCBwcik7XG4gIGlmIChyLmQpIHtcbiAgICByID0gZmluYWxpc2UociwgcHIgKyA1LCAxKTtcbiAgICBpZiAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhyLmQsIHByLCBybSkpIHtcbiAgICAgIGUgPSBwciArIDEwO1xuICAgICAgciA9IGZpbmFsaXNlKG5hdHVyYWxFeHBvbmVudGlhbCh5LnRpbWVzKG5hdHVyYWxMb2dhcml0aG0oeCwgZSArIGspKSwgZSksIGUgKyA1LCAxKTtcbiAgICAgIGlmICgrZGlnaXRzVG9TdHJpbmcoci5kKS5zbGljZShwciArIDEsIHByICsgMTUpICsgMSA9PSAxZTE0KSB7XG4gICAgICAgIHIgPSBmaW5hbGlzZShyLCBwciArIDEsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByLnMgPSBzO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIHByLCBybSk7XG59O1xuUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uKHNkLCBybSkge1xuICB2YXIgc3RyLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmIChzZCA9PT0gdm9pZCAwKSB7XG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xuICB9IGVsc2Uge1xuICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xuICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcbiAgICB4ID0gZmluYWxpc2UobmV3IEN0b3IoeCksIHNkLCBybSk7XG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgc2QgPD0geC5lIHx8IHguZSA8PSBDdG9yLnRvRXhwTmVnLCBzZCk7XG4gIH1cbiAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/IFwiLVwiICsgc3RyIDogc3RyO1xufTtcblAudG9TaWduaWZpY2FudERpZ2l0cyA9IFAudG9TRCA9IGZ1bmN0aW9uKHNkLCBybSkge1xuICB2YXIgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoc2QgPT09IHZvaWQgMCkge1xuICAgIHNkID0gQ3Rvci5wcmVjaXNpb247XG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICB9IGVsc2Uge1xuICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xuICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcbiAgfVxuICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoeCksIHNkLCBybSk7XG59O1xuUC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB4LmUgPD0gQ3Rvci50b0V4cE5lZyB8fCB4LmUgPj0gQ3Rvci50b0V4cFBvcyk7XG4gIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyBcIi1cIiArIHN0ciA6IHN0cjtcbn07XG5QLnRydW5jYXRlZCA9IFAudHJ1bmMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCB0aGlzLmUgKyAxLCAxKTtcbn07XG5QLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB4LmUgPD0gQ3Rvci50b0V4cE5lZyB8fCB4LmUgPj0gQ3Rvci50b0V4cFBvcyk7XG4gIHJldHVybiB4LmlzTmVnKCkgPyBcIi1cIiArIHN0ciA6IHN0cjtcbn07XG5mdW5jdGlvbiBkaWdpdHNUb1N0cmluZyhkKSB7XG4gIHZhciBpLCBrLCB3cywgaW5kZXhPZkxhc3RXb3JkID0gZC5sZW5ndGggLSAxLCBzdHIgPSBcIlwiLCB3ID0gZFswXTtcbiAgaWYgKGluZGV4T2ZMYXN0V29yZCA+IDApIHtcbiAgICBzdHIgKz0gdztcbiAgICBmb3IgKGkgPSAxOyBpIDwgaW5kZXhPZkxhc3RXb3JkOyBpKyspIHtcbiAgICAgIHdzID0gZFtpXSArIFwiXCI7XG4gICAgICBrID0gTE9HX0JBU0UgLSB3cy5sZW5ndGg7XG4gICAgICBpZiAoaykgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XG4gICAgICBzdHIgKz0gd3M7XG4gICAgfVxuICAgIHcgPSBkW2ldO1xuICAgIHdzID0gdyArIFwiXCI7XG4gICAgayA9IExPR19CQVNFIC0gd3MubGVuZ3RoO1xuICAgIGlmIChrKSBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcbiAgfSBlbHNlIGlmICh3ID09PSAwKSB7XG4gICAgcmV0dXJuIFwiMFwiO1xuICB9XG4gIGZvciAoOyB3ICUgMTAgPT09IDA7ICkgdyAvPSAxMDtcbiAgcmV0dXJuIHN0ciArIHc7XG59XG5mdW5jdGlvbiBjaGVja0ludDMyKGksIG1pbjIsIG1heDIpIHtcbiAgaWYgKGkgIT09IH5+aSB8fCBpIDwgbWluMiB8fCBpID4gbWF4Mikge1xuICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIGkpO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja1JvdW5kaW5nRGlnaXRzKGQsIGksIHJtLCByZXBlYXRpbmcpIHtcbiAgdmFyIGRpLCBrLCByLCByZDtcbiAgZm9yIChrID0gZFswXTsgayA+PSAxMDsgayAvPSAxMCkgLS1pO1xuICBpZiAoLS1pIDwgMCkge1xuICAgIGkgKz0gTE9HX0JBU0U7XG4gICAgZGkgPSAwO1xuICB9IGVsc2Uge1xuICAgIGRpID0gTWF0aC5jZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XG4gICAgaSAlPSBMT0dfQkFTRTtcbiAgfVxuICBrID0gbWF0aHBvdygxMCwgTE9HX0JBU0UgLSBpKTtcbiAgcmQgPSBkW2RpXSAlIGsgfCAwO1xuICBpZiAocmVwZWF0aW5nID09IG51bGwpIHtcbiAgICBpZiAoaSA8IDMpIHtcbiAgICAgIGlmIChpID09IDApIHJkID0gcmQgLyAxMDAgfCAwO1xuICAgICAgZWxzZSBpZiAoaSA9PSAxKSByZCA9IHJkIC8gMTAgfCAwO1xuICAgICAgciA9IHJtIDwgNCAmJiByZCA9PSA5OTk5OSB8fCBybSA+IDMgJiYgcmQgPT0gNDk5OTkgfHwgcmQgPT0gNWU0IHx8IHJkID09IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSAocm0gPCA0ICYmIHJkICsgMSA9PSBrIHx8IHJtID4gMyAmJiByZCArIDEgPT0gayAvIDIpICYmIChkW2RpICsgMV0gLyBrIC8gMTAwIHwgMCkgPT0gbWF0aHBvdygxMCwgaSAtIDIpIC0gMSB8fCAocmQgPT0gayAvIDIgfHwgcmQgPT0gMCkgJiYgKGRbZGkgKyAxXSAvIGsgLyAxMDAgfCAwKSA9PSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaSA8IDQpIHtcbiAgICAgIGlmIChpID09IDApIHJkID0gcmQgLyAxZTMgfCAwO1xuICAgICAgZWxzZSBpZiAoaSA9PSAxKSByZCA9IHJkIC8gMTAwIHwgMDtcbiAgICAgIGVsc2UgaWYgKGkgPT0gMikgcmQgPSByZCAvIDEwIHwgMDtcbiAgICAgIHIgPSAocmVwZWF0aW5nIHx8IHJtIDwgNCkgJiYgcmQgPT0gOTk5OSB8fCAhcmVwZWF0aW5nICYmIHJtID4gMyAmJiByZCA9PSA0OTk5O1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gKChyZXBlYXRpbmcgfHwgcm0gPCA0KSAmJiByZCArIDEgPT0gayB8fCAhcmVwZWF0aW5nICYmIHJtID4gMyAmJiByZCArIDEgPT0gayAvIDIpICYmIChkW2RpICsgMV0gLyBrIC8gMWUzIHwgMCkgPT0gbWF0aHBvdygxMCwgaSAtIDMpIC0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBjb252ZXJ0QmFzZShzdHIsIGJhc2VJbiwgYmFzZU91dCkge1xuICB2YXIgaiwgYXJyID0gWzBdLCBhcnJMLCBpID0gMCwgc3RyTCA9IHN0ci5sZW5ndGg7XG4gIGZvciAoOyBpIDwgc3RyTDsgKSB7XG4gICAgZm9yIChhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyApIGFyclthcnJMXSAqPSBiYXNlSW47XG4gICAgYXJyWzBdICs9IE5VTUVSQUxTLmluZGV4T2Yoc3RyLmNoYXJBdChpKyspKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcbiAgICAgICAgaWYgKGFycltqICsgMV0gPT09IHZvaWQgMCkgYXJyW2ogKyAxXSA9IDA7XG4gICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XG4gICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIGNvc2luZShDdG9yLCB4KSB7XG4gIHZhciBrLCBsZW4sIHk7XG4gIGlmICh4LmlzWmVybygpKSByZXR1cm4geDtcbiAgbGVuID0geC5kLmxlbmd0aDtcbiAgaWYgKGxlbiA8IDMyKSB7XG4gICAgayA9IE1hdGguY2VpbChsZW4gLyAzKTtcbiAgICB5ID0gKDEgLyB0aW55UG93KDQsIGspKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIGsgPSAxNjtcbiAgICB5ID0gXCIyLjMyODMwNjQzNjUzODY5NjI4OTA2MjVlLTEwXCI7XG4gIH1cbiAgQ3Rvci5wcmVjaXNpb24gKz0gaztcbiAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAxLCB4LnRpbWVzKHkpLCBuZXcgQ3RvcigxKSk7XG4gIGZvciAodmFyIGkgPSBrOyBpLS07ICkge1xuICAgIHZhciBjb3MyeCA9IHgudGltZXMoeCk7XG4gICAgeCA9IGNvczJ4LnRpbWVzKGNvczJ4KS5taW51cyhjb3MyeCkudGltZXMoOCkucGx1cygxKTtcbiAgfVxuICBDdG9yLnByZWNpc2lvbiAtPSBrO1xuICByZXR1cm4geDtcbn1cbnZhciBkaXZpZGUgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG11bHRpcGx5SW50ZWdlcih4LCBrLCBiYXNlKSB7XG4gICAgdmFyIHRlbXAsIGNhcnJ5ID0gMCwgaSA9IHgubGVuZ3RoO1xuICAgIGZvciAoeCA9IHguc2xpY2UoKTsgaS0tOyApIHtcbiAgICAgIHRlbXAgPSB4W2ldICogayArIGNhcnJ5O1xuICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlIHwgMDtcbiAgICAgIGNhcnJ5ID0gdGVtcCAvIGJhc2UgfCAwO1xuICAgIH1cbiAgICBpZiAoY2FycnkpIHgudW5zaGlmdChjYXJyeSk7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcbiAgICB2YXIgaSwgcjtcbiAgICBpZiAoYUwgIT0gYkwpIHtcbiAgICAgIHIgPSBhTCA+IGJMID8gMSA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSByID0gMDsgaSA8IGFMOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xuICAgICAgICAgIHIgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgYUwtLTsgKSB7XG4gICAgICBhW2FMXSAtPSBpO1xuICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcbiAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xuICAgIH1cbiAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOyApIGEuc2hpZnQoKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oeCwgeSwgcHIsIHJtLCBkcCwgYmFzZSkge1xuICAgIHZhciBjbXAsIGUsIGksIGssIGxvZ0Jhc2UsIG1vcmUsIHByb2QsIHByb2RMLCBxLCBxZCwgcmVtLCByZW1MLCByZW0wLCBzZCwgdCwgeGksIHhMLCB5ZDAsIHlMLCB5eiwgQ3RvciA9IHguY29uc3RydWN0b3IsIHNpZ24yID0geC5zID09IHkucyA/IDEgOiAtMSwgeGQgPSB4LmQsIHlkID0geS5kO1xuICAgIGlmICgheGQgfHwgIXhkWzBdIHx8ICF5ZCB8fCAheWRbMF0pIHtcbiAgICAgIHJldHVybiBuZXcgQ3RvcihcbiAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgTmFOLCBvciBib3RoIEluZmluaXR5IG9yIDAuXG4gICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGQgPyB5ZCAmJiB4ZFswXSA9PSB5ZFswXSA6ICF5ZCkgPyBOYU4gOiAoXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIDAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIDAuXG4gICAgICAgICAgeGQgJiYgeGRbMF0gPT0gMCB8fCAheWQgPyBzaWduMiAqIDAgOiBzaWduMiAvIDBcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGJhc2UpIHtcbiAgICAgIGxvZ0Jhc2UgPSAxO1xuICAgICAgZSA9IHguZSAtIHkuZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZSA9IEJBU0U7XG4gICAgICBsb2dCYXNlID0gTE9HX0JBU0U7XG4gICAgICBlID0gbWF0aGZsb29yKHguZSAvIGxvZ0Jhc2UpIC0gbWF0aGZsb29yKHkuZSAvIGxvZ0Jhc2UpO1xuICAgIH1cbiAgICB5TCA9IHlkLmxlbmd0aDtcbiAgICB4TCA9IHhkLmxlbmd0aDtcbiAgICBxID0gbmV3IEN0b3Ioc2lnbjIpO1xuICAgIHFkID0gcS5kID0gW107XG4gICAgZm9yIChpID0gMDsgeWRbaV0gPT0gKHhkW2ldIHx8IDApOyBpKyspIDtcbiAgICBpZiAoeWRbaV0gPiAoeGRbaV0gfHwgMCkpIGUtLTtcbiAgICBpZiAocHIgPT0gbnVsbCkge1xuICAgICAgc2QgPSBwciA9IEN0b3IucHJlY2lzaW9uO1xuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgIH0gZWxzZSBpZiAoZHApIHtcbiAgICAgIHNkID0gcHIgKyAoeC5lIC0geS5lKSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNkID0gcHI7XG4gICAgfVxuICAgIGlmIChzZCA8IDApIHtcbiAgICAgIHFkLnB1c2goMSk7XG4gICAgICBtb3JlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2QgPSBzZCAvIGxvZ0Jhc2UgKyAyIHwgMDtcbiAgICAgIGkgPSAwO1xuICAgICAgaWYgKHlMID09IDEpIHtcbiAgICAgICAgayA9IDA7XG4gICAgICAgIHlkID0geWRbMF07XG4gICAgICAgIHNkKys7XG4gICAgICAgIGZvciAoOyAoaSA8IHhMIHx8IGspICYmIHNkLS07IGkrKykge1xuICAgICAgICAgIHQgPSBrICogYmFzZSArICh4ZFtpXSB8fCAwKTtcbiAgICAgICAgICBxZFtpXSA9IHQgLyB5ZCB8IDA7XG4gICAgICAgICAgayA9IHQgJSB5ZCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbW9yZSA9IGsgfHwgaSA8IHhMO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayA9IGJhc2UgLyAoeWRbMF0gKyAxKSB8IDA7XG4gICAgICAgIGlmIChrID4gMSkge1xuICAgICAgICAgIHlkID0gbXVsdGlwbHlJbnRlZ2VyKHlkLCBrLCBiYXNlKTtcbiAgICAgICAgICB4ZCA9IG11bHRpcGx5SW50ZWdlcih4ZCwgaywgYmFzZSk7XG4gICAgICAgICAgeUwgPSB5ZC5sZW5ndGg7XG4gICAgICAgICAgeEwgPSB4ZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgeGkgPSB5TDtcbiAgICAgICAgcmVtID0geGQuc2xpY2UoMCwgeUwpO1xuICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgKSByZW1bcmVtTCsrXSA9IDA7XG4gICAgICAgIHl6ID0geWQuc2xpY2UoKTtcbiAgICAgICAgeXoudW5zaGlmdCgwKTtcbiAgICAgICAgeWQwID0geWRbMF07XG4gICAgICAgIGlmICh5ZFsxXSA+PSBiYXNlIC8gMikgKyt5ZDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBrID0gMDtcbiAgICAgICAgICBjbXAgPSBjb21wYXJlKHlkLCByZW0sIHlMLCByZW1MKTtcbiAgICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcbiAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xuICAgICAgICAgICAgayA9IHJlbTAgLyB5ZDAgfCAwO1xuICAgICAgICAgICAgaWYgKGsgPiAxKSB7XG4gICAgICAgICAgICAgIGlmIChrID49IGJhc2UpIGsgPSBiYXNlIC0gMTtcbiAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5SW50ZWdlcih5ZCwgaywgYmFzZSk7XG4gICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xuICAgICAgICAgICAgICBjbXAgPSBjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpO1xuICAgICAgICAgICAgICBpZiAoY21wID09IDEpIHtcbiAgICAgICAgICAgICAgICBrLS07XG4gICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWQsIHByb2RMLCBiYXNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGsgPT0gMCkgY21wID0gayA9IDE7XG4gICAgICAgICAgICAgIHByb2QgPSB5ZC5zbGljZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QudW5zaGlmdCgwKTtcbiAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgcHJvZCwgcmVtTCwgYmFzZSk7XG4gICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xuICAgICAgICAgICAgICBjbXAgPSBjb21wYXJlKHlkLCByZW0sIHlMLCByZW1MKTtcbiAgICAgICAgICAgICAgaWYgKGNtcCA8IDEpIHtcbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCB5TCA8IHJlbUwgPyB5eiA6IHlkLCByZW1MLCBiYXNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIHJlbSA9IFswXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcWRbaSsrXSA9IGs7XG4gICAgICAgICAgaWYgKGNtcCAmJiByZW1bMF0pIHtcbiAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGRbeGldIHx8IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbSA9IFt4ZFt4aV1dO1xuICAgICAgICAgICAgcmVtTCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPT0gdm9pZCAwKSAmJiBzZC0tKTtcbiAgICAgICAgbW9yZSA9IHJlbVswXSAhPT0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgaWYgKCFxZFswXSkgcWQuc2hpZnQoKTtcbiAgICB9XG4gICAgaWYgKGxvZ0Jhc2UgPT0gMSkge1xuICAgICAgcS5lID0gZTtcbiAgICAgIGluZXhhY3QgPSBtb3JlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAxLCBrID0gcWRbMF07IGsgPj0gMTA7IGsgLz0gMTApIGkrKztcbiAgICAgIHEuZSA9IGkgKyBlICogbG9nQmFzZSAtIDE7XG4gICAgICBmaW5hbGlzZShxLCBkcCA/IHByICsgcS5lICsgMSA6IHByLCBybSwgbW9yZSk7XG4gICAgfVxuICAgIHJldHVybiBxO1xuICB9O1xufSgpO1xuZnVuY3Rpb24gZmluYWxpc2UoeCwgc2QsIHJtLCBpc1RydW5jYXRlZCkge1xuICB2YXIgZGlnaXRzLCBpLCBqLCBrLCByZCwgcm91bmRVcCwgdywgeGQsIHhkaSwgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIG91dDogaWYgKHNkICE9IG51bGwpIHtcbiAgICB4ZCA9IHguZDtcbiAgICBpZiAoIXhkKSByZXR1cm4geDtcbiAgICBmb3IgKGRpZ2l0cyA9IDEsIGsgPSB4ZFswXTsgayA+PSAxMDsgayAvPSAxMCkgZGlnaXRzKys7XG4gICAgaSA9IHNkIC0gZGlnaXRzO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgaSArPSBMT0dfQkFTRTtcbiAgICAgIGogPSBzZDtcbiAgICAgIHcgPSB4ZFt4ZGkgPSAwXTtcbiAgICAgIHJkID0gdyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSAlIDEwIHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgeGRpID0gTWF0aC5jZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XG4gICAgICBrID0geGQubGVuZ3RoO1xuICAgICAgaWYgKHhkaSA+PSBrKSB7XG4gICAgICAgIGlmIChpc1RydW5jYXRlZCkge1xuICAgICAgICAgIGZvciAoOyBrKysgPD0geGRpOyApIHhkLnB1c2goMCk7XG4gICAgICAgICAgdyA9IHJkID0gMDtcbiAgICAgICAgICBkaWdpdHMgPSAxO1xuICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XG4gICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWsgb3V0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3ID0gayA9IHhkW3hkaV07XG4gICAgICAgIGZvciAoZGlnaXRzID0gMTsgayA+PSAxMDsgayAvPSAxMCkgZGlnaXRzKys7XG4gICAgICAgIGkgJT0gTE9HX0JBU0U7XG4gICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkaWdpdHM7XG4gICAgICAgIHJkID0gaiA8IDAgPyAwIDogdyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSAlIDEwIHwgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaXNUcnVuY2F0ZWQgPSBpc1RydW5jYXRlZCB8fCBzZCA8IDAgfHwgeGRbeGRpICsgMV0gIT09IHZvaWQgMCB8fCAoaiA8IDAgPyB3IDogdyAlIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSk7XG4gICAgcm91bmRVcCA9IHJtIDwgNCA/IChyZCB8fCBpc1RydW5jYXRlZCkgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgaXNUcnVuY2F0ZWQgfHwgcm0gPT0gNiAmJiAvLyBDaGVjayB3aGV0aGVyIHRoZSBkaWdpdCB0byB0aGUgbGVmdCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgb2RkLlxuICAgIChpID4gMCA/IGogPiAwID8gdyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGopIDogMCA6IHhkW3hkaSAtIDFdKSAlIDEwICYgMSB8fCBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XG4gICAgaWYgKHNkIDwgMSB8fCAheGRbMF0pIHtcbiAgICAgIHhkLmxlbmd0aCA9IDA7XG4gICAgICBpZiAocm91bmRVcCkge1xuICAgICAgICBzZCAtPSB4LmUgKyAxO1xuICAgICAgICB4ZFswXSA9IG1hdGhwb3coMTAsIChMT0dfQkFTRSAtIHNkICUgTE9HX0JBU0UpICUgTE9HX0JBU0UpO1xuICAgICAgICB4LmUgPSAtc2QgfHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhkWzBdID0geC5lID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBpZiAoaSA9PSAwKSB7XG4gICAgICB4ZC5sZW5ndGggPSB4ZGk7XG4gICAgICBrID0gMTtcbiAgICAgIHhkaS0tO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ZC5sZW5ndGggPSB4ZGkgKyAxO1xuICAgICAgayA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gaSk7XG4gICAgICB4ZFt4ZGldID0gaiA+IDAgPyAodyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGopICUgbWF0aHBvdygxMCwgaikgfCAwKSAqIGsgOiAwO1xuICAgIH1cbiAgICBpZiAocm91bmRVcCkge1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIGlmICh4ZGkgPT0gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4ZFswXTsgaiA+PSAxMDsgaiAvPSAxMCkgaSsrO1xuICAgICAgICAgIGogPSB4ZFswXSArPSBrO1xuICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTApIGsrKztcbiAgICAgICAgICBpZiAoaSAhPSBrKSB7XG4gICAgICAgICAgICB4LmUrKztcbiAgICAgICAgICAgIGlmICh4ZFswXSA9PSBCQVNFKSB4ZFswXSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhkW3hkaV0gKz0gaztcbiAgICAgICAgICBpZiAoeGRbeGRpXSAhPSBCQVNFKSBicmVhaztcbiAgICAgICAgICB4ZFt4ZGktLV0gPSAwO1xuICAgICAgICAgIGsgPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IHhkLmxlbmd0aDsgeGRbLS1pXSA9PT0gMDsgKSB4ZC5wb3AoKTtcbiAgfVxuICBpZiAoZXh0ZXJuYWwpIHtcbiAgICBpZiAoeC5lID4gQ3Rvci5tYXhFKSB7XG4gICAgICB4LmQgPSBudWxsO1xuICAgICAgeC5lID0gTmFOO1xuICAgIH0gZWxzZSBpZiAoeC5lIDwgQ3Rvci5taW5FKSB7XG4gICAgICB4LmUgPSAwO1xuICAgICAgeC5kID0gWzBdO1xuICAgIH1cbiAgfVxuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIGZpbml0ZVRvU3RyaW5nKHgsIGlzRXhwLCBzZCkge1xuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5vbkZpbml0ZVRvU3RyaW5nKHgpO1xuICB2YXIgaywgZSA9IHguZSwgc3RyID0gZGlnaXRzVG9TdHJpbmcoeC5kKSwgbGVuID0gc3RyLmxlbmd0aDtcbiAgaWYgKGlzRXhwKSB7XG4gICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMCkge1xuICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKSArIFwiLlwiICsgc3RyLnNsaWNlKDEpICsgZ2V0WmVyb1N0cmluZyhrKTtcbiAgICB9IGVsc2UgaWYgKGxlbiA+IDEpIHtcbiAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyBcIi5cIiArIHN0ci5zbGljZSgxKTtcbiAgICB9XG4gICAgc3RyID0gc3RyICsgKHguZSA8IDAgPyBcImVcIiA6IFwiZStcIikgKyB4LmU7XG4gIH0gZWxzZSBpZiAoZSA8IDApIHtcbiAgICBzdHIgPSBcIjAuXCIgKyBnZXRaZXJvU3RyaW5nKC1lIC0gMSkgKyBzdHI7XG4gICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMCkgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XG4gIH0gZWxzZSBpZiAoZSA+PSBsZW4pIHtcbiAgICBzdHIgKz0gZ2V0WmVyb1N0cmluZyhlICsgMSAtIGxlbik7XG4gICAgaWYgKHNkICYmIChrID0gc2QgLSBlIC0gMSkgPiAwKSBzdHIgPSBzdHIgKyBcIi5cIiArIGdldFplcm9TdHJpbmcoayk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKChrID0gZSArIDEpIDwgbGVuKSBzdHIgPSBzdHIuc2xpY2UoMCwgaykgKyBcIi5cIiArIHN0ci5zbGljZShrKTtcbiAgICBpZiAoc2QgJiYgKGsgPSBzZCAtIGxlbikgPiAwKSB7XG4gICAgICBpZiAoZSArIDEgPT09IGxlbikgc3RyICs9IFwiLlwiO1xuICAgICAgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBnZXRCYXNlMTBFeHBvbmVudChkaWdpdHMsIGUpIHtcbiAgdmFyIHcgPSBkaWdpdHNbMF07XG4gIGZvciAoZSAqPSBMT0dfQkFTRTsgdyA+PSAxMDsgdyAvPSAxMCkgZSsrO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGdldExuMTAoQ3Rvciwgc2QsIHByKSB7XG4gIGlmIChzZCA+IExOMTBfUFJFQ0lTSU9OKSB7XG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xuICAgIGlmIChwcikgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgICB0aHJvdyBFcnJvcihwcmVjaXNpb25MaW1pdEV4Y2VlZGVkKTtcbiAgfVxuICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoTE4xMCksIHNkLCAxLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGdldFBpKEN0b3IsIHNkLCBybSkge1xuICBpZiAoc2QgPiBQSV9QUkVDSVNJT04pIHRocm93IEVycm9yKHByZWNpc2lvbkxpbWl0RXhjZWVkZWQpO1xuICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoUEkpLCBzZCwgcm0sIHRydWUpO1xufVxuZnVuY3Rpb24gZ2V0UHJlY2lzaW9uKGRpZ2l0cykge1xuICB2YXIgdyA9IGRpZ2l0cy5sZW5ndGggLSAxLCBsZW4gPSB3ICogTE9HX0JBU0UgKyAxO1xuICB3ID0gZGlnaXRzW3ddO1xuICBpZiAodykge1xuICAgIGZvciAoOyB3ICUgMTAgPT0gMDsgdyAvPSAxMCkgbGVuLS07XG4gICAgZm9yICh3ID0gZGlnaXRzWzBdOyB3ID49IDEwOyB3IC89IDEwKSBsZW4rKztcbiAgfVxuICByZXR1cm4gbGVuO1xufVxuZnVuY3Rpb24gZ2V0WmVyb1N0cmluZyhrKSB7XG4gIHZhciB6cyA9IFwiXCI7XG4gIGZvciAoOyBrLS07ICkgenMgKz0gXCIwXCI7XG4gIHJldHVybiB6cztcbn1cbmZ1bmN0aW9uIGludFBvdyhDdG9yLCB4LCBuLCBwcikge1xuICB2YXIgaXNUcnVuY2F0ZWQsIHIgPSBuZXcgQ3RvcigxKSwgayA9IE1hdGguY2VpbChwciAvIExPR19CQVNFICsgNCk7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIGZvciAoOyA7ICkge1xuICAgIGlmIChuICUgMikge1xuICAgICAgciA9IHIudGltZXMoeCk7XG4gICAgICBpZiAodHJ1bmNhdGUoci5kLCBrKSkgaXNUcnVuY2F0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBuID0gbWF0aGZsb29yKG4gLyAyKTtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgbiA9IHIuZC5sZW5ndGggLSAxO1xuICAgICAgaWYgKGlzVHJ1bmNhdGVkICYmIHIuZFtuXSA9PT0gMCkgKytyLmRbbl07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgeCA9IHgudGltZXMoeCk7XG4gICAgdHJ1bmNhdGUoeC5kLCBrKTtcbiAgfVxuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gaXNPZGQobikge1xuICByZXR1cm4gbi5kW24uZC5sZW5ndGggLSAxXSAmIDE7XG59XG5mdW5jdGlvbiBtYXhPck1pbihDdG9yLCBhcmdzLCBuKSB7XG4gIHZhciBrLCB5LCB4ID0gbmV3IEN0b3IoYXJnc1swXSksIGkgPSAwO1xuICBmb3IgKDsgKytpIDwgYXJncy5sZW5ndGg7ICkge1xuICAgIHkgPSBuZXcgQ3RvcihhcmdzW2ldKTtcbiAgICBpZiAoIXkucykge1xuICAgICAgeCA9IHk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgayA9IHguY21wKHkpO1xuICAgIGlmIChrID09PSBuIHx8IGsgPT09IDAgJiYgeC5zID09PSBuKSB7XG4gICAgICB4ID0geTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBuYXR1cmFsRXhwb25lbnRpYWwoeCwgc2QpIHtcbiAgdmFyIGRlbm9taW5hdG9yLCBndWFyZCwgaiwgcG93Miwgc3VtMiwgdCwgd3ByLCByZXAgPSAwLCBpID0gMCwgayA9IDAsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBybSA9IEN0b3Iucm91bmRpbmcsIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIGlmICgheC5kIHx8ICF4LmRbMF0gfHwgeC5lID4gMTcpIHtcbiAgICByZXR1cm4gbmV3IEN0b3IoeC5kID8gIXguZFswXSA/IDEgOiB4LnMgPCAwID8gMCA6IDEgLyAwIDogeC5zID8geC5zIDwgMCA/IDAgOiB4IDogMCAvIDApO1xuICB9XG4gIGlmIChzZCA9PSBudWxsKSB7XG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgICB3cHIgPSBwcjtcbiAgfSBlbHNlIHtcbiAgICB3cHIgPSBzZDtcbiAgfVxuICB0ID0gbmV3IEN0b3IoMC4wMzEyNSk7XG4gIHdoaWxlICh4LmUgPiAtMikge1xuICAgIHggPSB4LnRpbWVzKHQpO1xuICAgIGsgKz0gNTtcbiAgfVxuICBndWFyZCA9IE1hdGgubG9nKG1hdGhwb3coMiwgaykpIC8gTWF0aC5MTjEwICogMiArIDUgfCAwO1xuICB3cHIgKz0gZ3VhcmQ7XG4gIGRlbm9taW5hdG9yID0gcG93MiA9IHN1bTIgPSBuZXcgQ3RvcigxKTtcbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHI7XG4gIGZvciAoOyA7ICkge1xuICAgIHBvdzIgPSBmaW5hbGlzZShwb3cyLnRpbWVzKHgpLCB3cHIsIDEpO1xuICAgIGRlbm9taW5hdG9yID0gZGVub21pbmF0b3IudGltZXMoKytpKTtcbiAgICB0ID0gc3VtMi5wbHVzKGRpdmlkZShwb3cyLCBkZW5vbWluYXRvciwgd3ByLCAxKSk7XG4gICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgd3ByKSA9PT0gZGlnaXRzVG9TdHJpbmcoc3VtMi5kKS5zbGljZSgwLCB3cHIpKSB7XG4gICAgICBqID0gaztcbiAgICAgIHdoaWxlIChqLS0pIHN1bTIgPSBmaW5hbGlzZShzdW0yLnRpbWVzKHN1bTIpLCB3cHIsIDEpO1xuICAgICAgaWYgKHNkID09IG51bGwpIHtcbiAgICAgICAgaWYgKHJlcCA8IDMgJiYgY2hlY2tSb3VuZGluZ0RpZ2l0cyhzdW0yLmQsIHdwciAtIGd1YXJkLCBybSwgcmVwKSkge1xuICAgICAgICAgIEN0b3IucHJlY2lzaW9uID0gd3ByICs9IDEwO1xuICAgICAgICAgIGRlbm9taW5hdG9yID0gcG93MiA9IHQgPSBuZXcgQ3RvcigxKTtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgICByZXArKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmluYWxpc2Uoc3VtMiwgQ3Rvci5wcmVjaXNpb24gPSBwciwgcm0sIGV4dGVybmFsID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gICAgICAgIHJldHVybiBzdW0yO1xuICAgICAgfVxuICAgIH1cbiAgICBzdW0yID0gdDtcbiAgfVxufVxuZnVuY3Rpb24gbmF0dXJhbExvZ2FyaXRobSh5LCBzZCkge1xuICB2YXIgYywgYzAsIGRlbm9taW5hdG9yLCBlLCBudW1lcmF0b3IsIHJlcCwgc3VtMiwgdCwgd3ByLCB4MSwgeDIsIG4gPSAxLCBndWFyZCA9IDEwLCB4ID0geSwgeGQgPSB4LmQsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBybSA9IEN0b3Iucm91bmRpbmcsIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIGlmICh4LnMgPCAwIHx8ICF4ZCB8fCAheGRbMF0gfHwgIXguZSAmJiB4ZFswXSA9PSAxICYmIHhkLmxlbmd0aCA9PSAxKSB7XG4gICAgcmV0dXJuIG5ldyBDdG9yKHhkICYmICF4ZFswXSA/IC0xIC8gMCA6IHgucyAhPSAxID8gTmFOIDogeGQgPyAwIDogeCk7XG4gIH1cbiAgaWYgKHNkID09IG51bGwpIHtcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xuICAgIHdwciA9IHByO1xuICB9IGVsc2Uge1xuICAgIHdwciA9IHNkO1xuICB9XG4gIEN0b3IucHJlY2lzaW9uID0gd3ByICs9IGd1YXJkO1xuICBjID0gZGlnaXRzVG9TdHJpbmcoeGQpO1xuICBjMCA9IGMuY2hhckF0KDApO1xuICBpZiAoTWF0aC5hYnMoZSA9IHguZSkgPCAxNWUxNCkge1xuICAgIHdoaWxlIChjMCA8IDcgJiYgYzAgIT0gMSB8fCBjMCA9PSAxICYmIGMuY2hhckF0KDEpID4gMykge1xuICAgICAgeCA9IHgudGltZXMoeSk7XG4gICAgICBjID0gZGlnaXRzVG9TdHJpbmcoeC5kKTtcbiAgICAgIGMwID0gYy5jaGFyQXQoMCk7XG4gICAgICBuKys7XG4gICAgfVxuICAgIGUgPSB4LmU7XG4gICAgaWYgKGMwID4gMSkge1xuICAgICAgeCA9IG5ldyBDdG9yKFwiMC5cIiArIGMpO1xuICAgICAgZSsrO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gbmV3IEN0b3IoYzAgKyBcIi5cIiArIGMuc2xpY2UoMSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0ID0gZ2V0TG4xMChDdG9yLCB3cHIgKyAyLCBwcikudGltZXMoZSArIFwiXCIpO1xuICAgIHggPSBuYXR1cmFsTG9nYXJpdGhtKG5ldyBDdG9yKGMwICsgXCIuXCIgKyBjLnNsaWNlKDEpKSwgd3ByIC0gZ3VhcmQpLnBsdXModCk7XG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgICByZXR1cm4gc2QgPT0gbnVsbCA/IGZpbmFsaXNlKHgsIHByLCBybSwgZXh0ZXJuYWwgPSB0cnVlKSA6IHg7XG4gIH1cbiAgeDEgPSB4O1xuICBzdW0yID0gbnVtZXJhdG9yID0geCA9IGRpdmlkZSh4Lm1pbnVzKDEpLCB4LnBsdXMoMSksIHdwciwgMSk7XG4gIHgyID0gZmluYWxpc2UoeC50aW1lcyh4KSwgd3ByLCAxKTtcbiAgZGVub21pbmF0b3IgPSAzO1xuICBmb3IgKDsgOyApIHtcbiAgICBudW1lcmF0b3IgPSBmaW5hbGlzZShudW1lcmF0b3IudGltZXMoeDIpLCB3cHIsIDEpO1xuICAgIHQgPSBzdW0yLnBsdXMoZGl2aWRlKG51bWVyYXRvciwgbmV3IEN0b3IoZGVub21pbmF0b3IpLCB3cHIsIDEpKTtcbiAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCB3cHIpID09PSBkaWdpdHNUb1N0cmluZyhzdW0yLmQpLnNsaWNlKDAsIHdwcikpIHtcbiAgICAgIHN1bTIgPSBzdW0yLnRpbWVzKDIpO1xuICAgICAgaWYgKGUgIT09IDApIHN1bTIgPSBzdW0yLnBsdXMoZ2V0TG4xMChDdG9yLCB3cHIgKyAyLCBwcikudGltZXMoZSArIFwiXCIpKTtcbiAgICAgIHN1bTIgPSBkaXZpZGUoc3VtMiwgbmV3IEN0b3IobiksIHdwciwgMSk7XG4gICAgICBpZiAoc2QgPT0gbnVsbCkge1xuICAgICAgICBpZiAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhzdW0yLmQsIHdwciAtIGd1YXJkLCBybSwgcmVwKSkge1xuICAgICAgICAgIEN0b3IucHJlY2lzaW9uID0gd3ByICs9IGd1YXJkO1xuICAgICAgICAgIHQgPSBudW1lcmF0b3IgPSB4ID0gZGl2aWRlKHgxLm1pbnVzKDEpLCB4MS5wbHVzKDEpLCB3cHIsIDEpO1xuICAgICAgICAgIHgyID0gZmluYWxpc2UoeC50aW1lcyh4KSwgd3ByLCAxKTtcbiAgICAgICAgICBkZW5vbWluYXRvciA9IHJlcCA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmFsaXNlKHN1bTIsIEN0b3IucHJlY2lzaW9uID0gcHIsIHJtLCBleHRlcm5hbCA9IHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICAgICAgICByZXR1cm4gc3VtMjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VtMiA9IHQ7XG4gICAgZGVub21pbmF0b3IgKz0gMjtcbiAgfVxufVxuZnVuY3Rpb24gbm9uRmluaXRlVG9TdHJpbmcoeCkge1xuICByZXR1cm4gU3RyaW5nKHgucyAqIHgucyAvIDApO1xufVxuZnVuY3Rpb24gcGFyc2VEZWNpbWFsKHgsIHN0cikge1xuICB2YXIgZSwgaSwgbGVuO1xuICBpZiAoKGUgPSBzdHIuaW5kZXhPZihcIi5cIikpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKFwiLlwiLCBcIlwiKTtcbiAgaWYgKChpID0gc3RyLnNlYXJjaCgvZS9pKSkgPiAwKSB7XG4gICAgaWYgKGUgPCAwKSBlID0gaTtcbiAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XG4gIH0gZWxzZSBpZiAoZSA8IDApIHtcbiAgICBlID0gc3RyLmxlbmd0aDtcbiAgfVxuICBmb3IgKGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKykgO1xuICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KGxlbiAtIDEpID09PSA0ODsgLS1sZW4pIDtcbiAgc3RyID0gc3RyLnNsaWNlKGksIGxlbik7XG4gIGlmIChzdHIpIHtcbiAgICBsZW4gLT0gaTtcbiAgICB4LmUgPSBlID0gZSAtIGkgLSAxO1xuICAgIHguZCA9IFtdO1xuICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XG4gICAgaWYgKGUgPCAwKSBpICs9IExPR19CQVNFO1xuICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICBpZiAoaSkgeC5kLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XG4gICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjsgKSB4LmQucHVzaCgrc3RyLnNsaWNlKGksIGkgKz0gTE9HX0JBU0UpKTtcbiAgICAgIHN0ciA9IHN0ci5zbGljZShpKTtcbiAgICAgIGkgPSBMT0dfQkFTRSAtIHN0ci5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkgLT0gbGVuO1xuICAgIH1cbiAgICBmb3IgKDsgaS0tOyApIHN0ciArPSBcIjBcIjtcbiAgICB4LmQucHVzaCgrc3RyKTtcbiAgICBpZiAoZXh0ZXJuYWwpIHtcbiAgICAgIGlmICh4LmUgPiB4LmNvbnN0cnVjdG9yLm1heEUpIHtcbiAgICAgICAgeC5kID0gbnVsbDtcbiAgICAgICAgeC5lID0gTmFOO1xuICAgICAgfSBlbHNlIGlmICh4LmUgPCB4LmNvbnN0cnVjdG9yLm1pbkUpIHtcbiAgICAgICAgeC5lID0gMDtcbiAgICAgICAgeC5kID0gWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB4LmUgPSAwO1xuICAgIHguZCA9IFswXTtcbiAgfVxuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIHBhcnNlT3RoZXIoeCwgc3RyKSB7XG4gIHZhciBiYXNlLCBDdG9yLCBkaXZpc29yLCBpLCBpc0Zsb2F0LCBsZW4sIHAsIHhkLCB4ZTtcbiAgaWYgKHN0ci5pbmRleE9mKFwiX1wiKSA+IC0xKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoLyhcXGQpXyg/PVxcZCkvZywgXCIkMVwiKTtcbiAgICBpZiAoaXNEZWNpbWFsLnRlc3Qoc3RyKSkgcmV0dXJuIHBhcnNlRGVjaW1hbCh4LCBzdHIpO1xuICB9IGVsc2UgaWYgKHN0ciA9PT0gXCJJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCJOYU5cIikge1xuICAgIGlmICghK3N0cikgeC5zID0gTmFOO1xuICAgIHguZSA9IE5hTjtcbiAgICB4LmQgPSBudWxsO1xuICAgIHJldHVybiB4O1xuICB9XG4gIGlmIChpc0hleC50ZXN0KHN0cikpIHtcbiAgICBiYXNlID0gMTY7XG4gICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAoaXNCaW5hcnkudGVzdChzdHIpKSB7XG4gICAgYmFzZSA9IDI7XG4gIH0gZWxzZSBpZiAoaXNPY3RhbC50ZXN0KHN0cikpIHtcbiAgICBiYXNlID0gODtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBzdHIpO1xuICB9XG4gIGkgPSBzdHIuc2VhcmNoKC9wL2kpO1xuICBpZiAoaSA+IDApIHtcbiAgICBwID0gK3N0ci5zbGljZShpICsgMSk7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygyLCBpKTtcbiAgfSBlbHNlIHtcbiAgICBzdHIgPSBzdHIuc2xpY2UoMik7XG4gIH1cbiAgaSA9IHN0ci5pbmRleE9mKFwiLlwiKTtcbiAgaXNGbG9hdCA9IGkgPj0gMDtcbiAgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmIChpc0Zsb2F0KSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoXCIuXCIsIFwiXCIpO1xuICAgIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgaSA9IGxlbiAtIGk7XG4gICAgZGl2aXNvciA9IGludFBvdyhDdG9yLCBuZXcgQ3RvcihiYXNlKSwgaSwgaSAqIDIpO1xuICB9XG4gIHhkID0gY29udmVydEJhc2Uoc3RyLCBiYXNlLCBCQVNFKTtcbiAgeGUgPSB4ZC5sZW5ndGggLSAxO1xuICBmb3IgKGkgPSB4ZTsgeGRbaV0gPT09IDA7IC0taSkgeGQucG9wKCk7XG4gIGlmIChpIDwgMCkgcmV0dXJuIG5ldyBDdG9yKHgucyAqIDApO1xuICB4LmUgPSBnZXRCYXNlMTBFeHBvbmVudCh4ZCwgeGUpO1xuICB4LmQgPSB4ZDtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgaWYgKGlzRmxvYXQpIHggPSBkaXZpZGUoeCwgZGl2aXNvciwgbGVuICogNCk7XG4gIGlmIChwKSB4ID0geC50aW1lcyhNYXRoLmFicyhwKSA8IDU0ID8gbWF0aHBvdygyLCBwKSA6IERlY2ltYWwucG93KDIsIHApKTtcbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIHNpbmUoQ3RvciwgeCkge1xuICB2YXIgaywgbGVuID0geC5kLmxlbmd0aDtcbiAgaWYgKGxlbiA8IDMpIHtcbiAgICByZXR1cm4geC5pc1plcm8oKSA/IHggOiB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCk7XG4gIH1cbiAgayA9IDEuNCAqIE1hdGguc3FydChsZW4pO1xuICBrID0gayA+IDE2ID8gMTYgOiBrIHwgMDtcbiAgeCA9IHgudGltZXMoMSAvIHRpbnlQb3coNSwgaykpO1xuICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgpO1xuICB2YXIgc2luMl94LCBkNSA9IG5ldyBDdG9yKDUpLCBkMTYgPSBuZXcgQ3RvcigxNiksIGQyMCA9IG5ldyBDdG9yKDIwKTtcbiAgZm9yICg7IGstLTsgKSB7XG4gICAgc2luMl94ID0geC50aW1lcyh4KTtcbiAgICB4ID0geC50aW1lcyhkNS5wbHVzKHNpbjJfeC50aW1lcyhkMTYudGltZXMoc2luMl94KS5taW51cyhkMjApKSkpO1xuICB9XG4gIHJldHVybiB4O1xufVxuZnVuY3Rpb24gdGF5bG9yU2VyaWVzKEN0b3IsIG4sIHgsIHksIGlzSHlwZXJib2xpYykge1xuICB2YXIgaiwgdCwgdSwgeDIsIGkgPSAxLCBwciA9IEN0b3IucHJlY2lzaW9uLCBrID0gTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICB4MiA9IHgudGltZXMoeCk7XG4gIHUgPSBuZXcgQ3Rvcih5KTtcbiAgZm9yICg7IDsgKSB7XG4gICAgdCA9IGRpdmlkZSh1LnRpbWVzKHgyKSwgbmV3IEN0b3IobisrICogbisrKSwgcHIsIDEpO1xuICAgIHUgPSBpc0h5cGVyYm9saWMgPyB5LnBsdXModCkgOiB5Lm1pbnVzKHQpO1xuICAgIHkgPSBkaXZpZGUodC50aW1lcyh4MiksIG5ldyBDdG9yKG4rKyAqIG4rKyksIHByLCAxKTtcbiAgICB0ID0gdS5wbHVzKHkpO1xuICAgIGlmICh0LmRba10gIT09IHZvaWQgMCkge1xuICAgICAgZm9yIChqID0gazsgdC5kW2pdID09PSB1LmRbal0gJiYgai0tOyApIDtcbiAgICAgIGlmIChqID09IC0xKSBicmVhaztcbiAgICB9XG4gICAgaiA9IHU7XG4gICAgdSA9IHk7XG4gICAgeSA9IHQ7XG4gICAgdCA9IGo7XG4gICAgaSsrO1xuICB9XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgdC5kLmxlbmd0aCA9IGsgKyAxO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIHRpbnlQb3coYiwgZSkge1xuICB2YXIgbiA9IGI7XG4gIHdoaWxlICgtLWUpIG4gKj0gYjtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiB0b0xlc3NUaGFuSGFsZlBpKEN0b3IsIHgpIHtcbiAgdmFyIHQsIGlzTmVnID0geC5zIDwgMCwgcGkgPSBnZXRQaShDdG9yLCBDdG9yLnByZWNpc2lvbiwgMSksIGhhbGZQaSA9IHBpLnRpbWVzKDAuNSk7XG4gIHggPSB4LmFicygpO1xuICBpZiAoeC5sdGUoaGFsZlBpKSkge1xuICAgIHF1YWRyYW50ID0gaXNOZWcgPyA0IDogMTtcbiAgICByZXR1cm4geDtcbiAgfVxuICB0ID0geC5kaXZUb0ludChwaSk7XG4gIGlmICh0LmlzWmVybygpKSB7XG4gICAgcXVhZHJhbnQgPSBpc05lZyA/IDMgOiAyO1xuICB9IGVsc2Uge1xuICAgIHggPSB4Lm1pbnVzKHQudGltZXMocGkpKTtcbiAgICBpZiAoeC5sdGUoaGFsZlBpKSkge1xuICAgICAgcXVhZHJhbnQgPSBpc09kZCh0KSA/IGlzTmVnID8gMiA6IDMgOiBpc05lZyA/IDQgOiAxO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIHF1YWRyYW50ID0gaXNPZGQodCkgPyBpc05lZyA/IDEgOiA0IDogaXNOZWcgPyAzIDogMjtcbiAgfVxuICByZXR1cm4geC5taW51cyhwaSkuYWJzKCk7XG59XG5mdW5jdGlvbiB0b1N0cmluZ0JpbmFyeSh4LCBiYXNlT3V0LCBzZCwgcm0pIHtcbiAgdmFyIGJhc2UsIGUsIGksIGssIGxlbiwgcm91bmRVcCwgc3RyLCB4ZCwgeSwgQ3RvciA9IHguY29uc3RydWN0b3IsIGlzRXhwID0gc2QgIT09IHZvaWQgMDtcbiAgaWYgKGlzRXhwKSB7XG4gICAgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XG4gICAgaWYgKHJtID09PSB2b2lkIDApIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xuICB9IGVsc2Uge1xuICAgIHNkID0gQ3Rvci5wcmVjaXNpb247XG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICB9XG4gIGlmICgheC5pc0Zpbml0ZSgpKSB7XG4gICAgc3RyID0gbm9uRmluaXRlVG9TdHJpbmcoeCk7XG4gIH0gZWxzZSB7XG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCk7XG4gICAgaSA9IHN0ci5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaXNFeHApIHtcbiAgICAgIGJhc2UgPSAyO1xuICAgICAgaWYgKGJhc2VPdXQgPT0gMTYpIHtcbiAgICAgICAgc2QgPSBzZCAqIDQgLSAzO1xuICAgICAgfSBlbHNlIGlmIChiYXNlT3V0ID09IDgpIHtcbiAgICAgICAgc2QgPSBzZCAqIDMgLSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gYmFzZU91dDtcbiAgICB9XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoXCIuXCIsIFwiXCIpO1xuICAgICAgeSA9IG5ldyBDdG9yKDEpO1xuICAgICAgeS5lID0gc3RyLmxlbmd0aCAtIGk7XG4gICAgICB5LmQgPSBjb252ZXJ0QmFzZShmaW5pdGVUb1N0cmluZyh5KSwgMTAsIGJhc2UpO1xuICAgICAgeS5lID0geS5kLmxlbmd0aDtcbiAgICB9XG4gICAgeGQgPSBjb252ZXJ0QmFzZShzdHIsIDEwLCBiYXNlKTtcbiAgICBlID0gbGVuID0geGQubGVuZ3RoO1xuICAgIGZvciAoOyB4ZFstLWxlbl0gPT0gMDsgKSB4ZC5wb3AoKTtcbiAgICBpZiAoIXhkWzBdKSB7XG4gICAgICBzdHIgPSBpc0V4cCA/IFwiMHArMFwiIDogXCIwXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICBlLS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gbmV3IEN0b3IoeCk7XG4gICAgICAgIHguZCA9IHhkO1xuICAgICAgICB4LmUgPSBlO1xuICAgICAgICB4ID0gZGl2aWRlKHgsIHksIHNkLCBybSwgMCwgYmFzZSk7XG4gICAgICAgIHhkID0geC5kO1xuICAgICAgICBlID0geC5lO1xuICAgICAgICByb3VuZFVwID0gaW5leGFjdDtcbiAgICAgIH1cbiAgICAgIGkgPSB4ZFtzZF07XG4gICAgICBrID0gYmFzZSAvIDI7XG4gICAgICByb3VuZFVwID0gcm91bmRVcCB8fCB4ZFtzZCArIDFdICE9PSB2b2lkIDA7XG4gICAgICByb3VuZFVwID0gcm0gPCA0ID8gKGkgIT09IHZvaWQgMCB8fCByb3VuZFVwKSAmJiAocm0gPT09IDAgfHwgcm0gPT09ICh4LnMgPCAwID8gMyA6IDIpKSA6IGkgPiBrIHx8IGkgPT09IGsgJiYgKHJtID09PSA0IHx8IHJvdW5kVXAgfHwgcm0gPT09IDYgJiYgeGRbc2QgLSAxXSAmIDEgfHwgcm0gPT09ICh4LnMgPCAwID8gOCA6IDcpKTtcbiAgICAgIHhkLmxlbmd0aCA9IHNkO1xuICAgICAgaWYgKHJvdW5kVXApIHtcbiAgICAgICAgZm9yICg7ICsreGRbLS1zZF0gPiBiYXNlIC0gMTsgKSB7XG4gICAgICAgICAgeGRbc2RdID0gMDtcbiAgICAgICAgICBpZiAoIXNkKSB7XG4gICAgICAgICAgICArK2U7XG4gICAgICAgICAgICB4ZC51bnNoaWZ0KDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZW4gPSB4ZC5sZW5ndGg7ICF4ZFtsZW4gLSAxXTsgLS1sZW4pIDtcbiAgICAgIGZvciAoaSA9IDAsIHN0ciA9IFwiXCI7IGkgPCBsZW47IGkrKykgc3RyICs9IE5VTUVSQUxTLmNoYXJBdCh4ZFtpXSk7XG4gICAgICBpZiAoaXNFeHApIHtcbiAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICBpZiAoYmFzZU91dCA9PSAxNiB8fCBiYXNlT3V0ID09IDgpIHtcbiAgICAgICAgICAgIGkgPSBiYXNlT3V0ID09IDE2ID8gNCA6IDM7XG4gICAgICAgICAgICBmb3IgKC0tbGVuOyBsZW4gJSBpOyBsZW4rKykgc3RyICs9IFwiMFwiO1xuICAgICAgICAgICAgeGQgPSBjb252ZXJ0QmFzZShzdHIsIGJhc2UsIGJhc2VPdXQpO1xuICAgICAgICAgICAgZm9yIChsZW4gPSB4ZC5sZW5ndGg7ICF4ZFtsZW4gLSAxXTsgLS1sZW4pIDtcbiAgICAgICAgICAgIGZvciAoaSA9IDEsIHN0ciA9IFwiMS5cIjsgaSA8IGxlbjsgaSsrKSBzdHIgKz0gTlVNRVJBTFMuY2hhckF0KHhkW2ldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKSArIFwiLlwiICsgc3RyLnNsaWNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBzdHIgKyAoZSA8IDAgPyBcInBcIiA6IFwicCtcIikgKyBlO1xuICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xuICAgICAgICBmb3IgKDsgKytlOyApIHN0ciA9IFwiMFwiICsgc3RyO1xuICAgICAgICBzdHIgPSBcIjAuXCIgKyBzdHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKytlID4gbGVuKSBmb3IgKGUgLT0gbGVuOyBlLS07ICkgc3RyICs9IFwiMFwiO1xuICAgICAgICBlbHNlIGlmIChlIDwgbGVuKSBzdHIgPSBzdHIuc2xpY2UoMCwgZSkgKyBcIi5cIiArIHN0ci5zbGljZShlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RyID0gKGJhc2VPdXQgPT0gMTYgPyBcIjB4XCIgOiBiYXNlT3V0ID09IDIgPyBcIjBiXCIgOiBiYXNlT3V0ID09IDggPyBcIjBvXCIgOiBcIlwiKSArIHN0cjtcbiAgfVxuICByZXR1cm4geC5zIDwgMCA/IFwiLVwiICsgc3RyIDogc3RyO1xufVxuZnVuY3Rpb24gdHJ1bmNhdGUoYXJyLCBsZW4pIHtcbiAgaWYgKGFyci5sZW5ndGggPiBsZW4pIHtcbiAgICBhcnIubGVuZ3RoID0gbGVuO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBhYnMoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYWJzKCk7XG59XG5mdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFjb3MoKTtcbn1cbmZ1bmN0aW9uIGFjb3NoKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFjb3NoKCk7XG59XG5mdW5jdGlvbiBhZGQoeCwgeSkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkucGx1cyh5KTtcbn1cbmZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYXNpbigpO1xufVxuZnVuY3Rpb24gYXNpbmgoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYXNpbmgoKTtcbn1cbmZ1bmN0aW9uIGF0YW4oeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYXRhbigpO1xufVxuZnVuY3Rpb24gYXRhbmgoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYXRhbmgoKTtcbn1cbmZ1bmN0aW9uIGF0YW4yKHksIHgpIHtcbiAgeSA9IG5ldyB0aGlzKHkpO1xuICB4ID0gbmV3IHRoaXMoeCk7XG4gIHZhciByLCBwciA9IHRoaXMucHJlY2lzaW9uLCBybSA9IHRoaXMucm91bmRpbmcsIHdwciA9IHByICsgNDtcbiAgaWYgKCF5LnMgfHwgIXgucykge1xuICAgIHIgPSBuZXcgdGhpcyhOYU4pO1xuICB9IGVsc2UgaWYgKCF5LmQgJiYgIXguZCkge1xuICAgIHIgPSBnZXRQaSh0aGlzLCB3cHIsIDEpLnRpbWVzKHgucyA+IDAgPyAwLjI1IDogMC43NSk7XG4gICAgci5zID0geS5zO1xuICB9IGVsc2UgaWYgKCF4LmQgfHwgeS5pc1plcm8oKSkge1xuICAgIHIgPSB4LnMgPCAwID8gZ2V0UGkodGhpcywgcHIsIHJtKSA6IG5ldyB0aGlzKDApO1xuICAgIHIucyA9IHkucztcbiAgfSBlbHNlIGlmICgheS5kIHx8IHguaXNaZXJvKCkpIHtcbiAgICByID0gZ2V0UGkodGhpcywgd3ByLCAxKS50aW1lcygwLjUpO1xuICAgIHIucyA9IHkucztcbiAgfSBlbHNlIGlmICh4LnMgPCAwKSB7XG4gICAgdGhpcy5wcmVjaXNpb24gPSB3cHI7XG4gICAgdGhpcy5yb3VuZGluZyA9IDE7XG4gICAgciA9IHRoaXMuYXRhbihkaXZpZGUoeSwgeCwgd3ByLCAxKSk7XG4gICAgeCA9IGdldFBpKHRoaXMsIHdwciwgMSk7XG4gICAgdGhpcy5wcmVjaXNpb24gPSBwcjtcbiAgICB0aGlzLnJvdW5kaW5nID0gcm07XG4gICAgciA9IHkucyA8IDAgPyByLm1pbnVzKHgpIDogci5wbHVzKHgpO1xuICB9IGVsc2Uge1xuICAgIHIgPSB0aGlzLmF0YW4oZGl2aWRlKHksIHgsIHdwciwgMSkpO1xuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gY2JydCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5jYnJ0KCk7XG59XG5mdW5jdGlvbiBjZWlsKHgpIHtcbiAgcmV0dXJuIGZpbmFsaXNlKHggPSBuZXcgdGhpcyh4KSwgeC5lICsgMSwgMik7XG59XG5mdW5jdGlvbiBjbGFtcCh4LCBtaW4yLCBtYXgyKSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5jbGFtcChtaW4yLCBtYXgyKTtcbn1cbmZ1bmN0aW9uIGNvbmZpZyhvYmopIHtcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikgdGhyb3cgRXJyb3IoZGVjaW1hbEVycm9yICsgXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gIHZhciBpLCBwLCB2LCB1c2VEZWZhdWx0cyA9IG9iai5kZWZhdWx0cyA9PT0gdHJ1ZSwgcHMgPSBbXG4gICAgXCJwcmVjaXNpb25cIixcbiAgICAxLFxuICAgIE1BWF9ESUdJVFMsXG4gICAgXCJyb3VuZGluZ1wiLFxuICAgIDAsXG4gICAgOCxcbiAgICBcInRvRXhwTmVnXCIsXG4gICAgLUVYUF9MSU1JVCxcbiAgICAwLFxuICAgIFwidG9FeHBQb3NcIixcbiAgICAwLFxuICAgIEVYUF9MSU1JVCxcbiAgICBcIm1heEVcIixcbiAgICAwLFxuICAgIEVYUF9MSU1JVCxcbiAgICBcIm1pbkVcIixcbiAgICAtRVhQX0xJTUlULFxuICAgIDAsXG4gICAgXCJtb2R1bG9cIixcbiAgICAwLFxuICAgIDlcbiAgXTtcbiAgZm9yIChpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgaWYgKHAgPSBwc1tpXSwgdXNlRGVmYXVsdHMpIHRoaXNbcF0gPSBERUZBVUxUU1twXTtcbiAgICBpZiAoKHYgPSBvYmpbcF0pICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChtYXRoZmxvb3IodikgPT09IHYgJiYgdiA+PSBwc1tpICsgMV0gJiYgdiA8PSBwc1tpICsgMl0pIHRoaXNbcF0gPSB2O1xuICAgICAgZWxzZSB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBwICsgXCI6IFwiICsgdik7XG4gICAgfVxuICB9XG4gIGlmIChwID0gXCJjcnlwdG9cIiwgdXNlRGVmYXVsdHMpIHRoaXNbcF0gPSBERUZBVUxUU1twXTtcbiAgaWYgKCh2ID0gb2JqW3BdKSAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKHYgPT09IHRydWUgfHwgdiA9PT0gZmFsc2UgfHwgdiA9PT0gMCB8fCB2ID09PSAxKSB7XG4gICAgICBpZiAodikge1xuICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSBcInVuZGVmaW5lZFwiICYmIGNyeXB0byAmJiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB8fCBjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XG4gICAgICAgICAgdGhpc1twXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoY3J5cHRvVW5hdmFpbGFibGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3BdID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHAgKyBcIjogXCIgKyB2KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBjb3MoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuY29zKCk7XG59XG5mdW5jdGlvbiBjb3NoKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmNvc2goKTtcbn1cbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuICB2YXIgaSwgcCwgcHM7XG4gIGZ1bmN0aW9uIERlY2ltYWwyKHYpIHtcbiAgICB2YXIgZSwgaTIsIHQsIHggPSB0aGlzO1xuICAgIGlmICghKHggaW5zdGFuY2VvZiBEZWNpbWFsMikpIHJldHVybiBuZXcgRGVjaW1hbDIodik7XG4gICAgeC5jb25zdHJ1Y3RvciA9IERlY2ltYWwyO1xuICAgIGlmIChpc0RlY2ltYWxJbnN0YW5jZSh2KSkge1xuICAgICAgeC5zID0gdi5zO1xuICAgICAgaWYgKGV4dGVybmFsKSB7XG4gICAgICAgIGlmICghdi5kIHx8IHYuZSA+IERlY2ltYWwyLm1heEUpIHtcbiAgICAgICAgICB4LmUgPSBOYU47XG4gICAgICAgICAgeC5kID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh2LmUgPCBEZWNpbWFsMi5taW5FKSB7XG4gICAgICAgICAgeC5lID0gMDtcbiAgICAgICAgICB4LmQgPSBbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeC5lID0gdi5lO1xuICAgICAgICAgIHguZCA9IHYuZC5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4LmUgPSB2LmU7XG4gICAgICAgIHguZCA9IHYuZCA/IHYuZC5zbGljZSgpIDogdi5kO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0ID0gdHlwZW9mIHY7XG4gICAgaWYgKHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmICh2ID09PSAwKSB7XG4gICAgICAgIHgucyA9IDEgLyB2IDwgMCA/IC0xIDogMTtcbiAgICAgICAgeC5lID0gMDtcbiAgICAgICAgeC5kID0gWzBdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodiA8IDApIHtcbiAgICAgICAgdiA9IC12O1xuICAgICAgICB4LnMgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgucyA9IDE7XG4gICAgICB9XG4gICAgICBpZiAodiA9PT0gfn52ICYmIHYgPCAxZTcpIHtcbiAgICAgICAgZm9yIChlID0gMCwgaTIgPSB2OyBpMiA+PSAxMDsgaTIgLz0gMTApIGUrKztcbiAgICAgICAgaWYgKGV4dGVybmFsKSB7XG4gICAgICAgICAgaWYgKGUgPiBEZWNpbWFsMi5tYXhFKSB7XG4gICAgICAgICAgICB4LmUgPSBOYU47XG4gICAgICAgICAgICB4LmQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZSA8IERlY2ltYWwyLm1pbkUpIHtcbiAgICAgICAgICAgIHguZSA9IDA7XG4gICAgICAgICAgICB4LmQgPSBbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHguZSA9IGU7XG4gICAgICAgICAgICB4LmQgPSBbdl07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHguZSA9IGU7XG4gICAgICAgICAgeC5kID0gW3ZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2ICogMCAhPT0gMCkge1xuICAgICAgICBpZiAoIXYpIHgucyA9IE5hTjtcbiAgICAgICAgeC5lID0gTmFOO1xuICAgICAgICB4LmQgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VEZWNpbWFsKHgsIHYudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmICh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoKGkyID0gdi5jaGFyQ29kZUF0KDApKSA9PT0gNDUpIHtcbiAgICAgICAgdiA9IHYuc2xpY2UoMSk7XG4gICAgICAgIHgucyA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGkyID09PSA0MykgdiA9IHYuc2xpY2UoMSk7XG4gICAgICAgIHgucyA9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNEZWNpbWFsLnRlc3QodikgPyBwYXJzZURlY2ltYWwoeCwgdikgOiBwYXJzZU90aGVyKHgsIHYpO1xuICAgIH1cbiAgICBpZiAodCA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgaWYgKHYgPCAwKSB7XG4gICAgICAgIHYgPSAtdjtcbiAgICAgICAgeC5zID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4LnMgPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlRGVjaW1hbCh4LCB2LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyB2KTtcbiAgfVxuICBEZWNpbWFsMi5wcm90b3R5cGUgPSBQO1xuICBEZWNpbWFsMi5ST1VORF9VUCA9IDA7XG4gIERlY2ltYWwyLlJPVU5EX0RPV04gPSAxO1xuICBEZWNpbWFsMi5ST1VORF9DRUlMID0gMjtcbiAgRGVjaW1hbDIuUk9VTkRfRkxPT1IgPSAzO1xuICBEZWNpbWFsMi5ST1VORF9IQUxGX1VQID0gNDtcbiAgRGVjaW1hbDIuUk9VTkRfSEFMRl9ET1dOID0gNTtcbiAgRGVjaW1hbDIuUk9VTkRfSEFMRl9FVkVOID0gNjtcbiAgRGVjaW1hbDIuUk9VTkRfSEFMRl9DRUlMID0gNztcbiAgRGVjaW1hbDIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XG4gIERlY2ltYWwyLkVVQ0xJRCA9IDk7XG4gIERlY2ltYWwyLmNvbmZpZyA9IERlY2ltYWwyLnNldCA9IGNvbmZpZztcbiAgRGVjaW1hbDIuY2xvbmUgPSBjbG9uZTtcbiAgRGVjaW1hbDIuaXNEZWNpbWFsID0gaXNEZWNpbWFsSW5zdGFuY2U7XG4gIERlY2ltYWwyLmFicyA9IGFicztcbiAgRGVjaW1hbDIuYWNvcyA9IGFjb3M7XG4gIERlY2ltYWwyLmFjb3NoID0gYWNvc2g7XG4gIERlY2ltYWwyLmFkZCA9IGFkZDtcbiAgRGVjaW1hbDIuYXNpbiA9IGFzaW47XG4gIERlY2ltYWwyLmFzaW5oID0gYXNpbmg7XG4gIERlY2ltYWwyLmF0YW4gPSBhdGFuO1xuICBEZWNpbWFsMi5hdGFuaCA9IGF0YW5oO1xuICBEZWNpbWFsMi5hdGFuMiA9IGF0YW4yO1xuICBEZWNpbWFsMi5jYnJ0ID0gY2JydDtcbiAgRGVjaW1hbDIuY2VpbCA9IGNlaWw7XG4gIERlY2ltYWwyLmNsYW1wID0gY2xhbXA7XG4gIERlY2ltYWwyLmNvcyA9IGNvcztcbiAgRGVjaW1hbDIuY29zaCA9IGNvc2g7XG4gIERlY2ltYWwyLmRpdiA9IGRpdjtcbiAgRGVjaW1hbDIuZXhwID0gZXhwO1xuICBEZWNpbWFsMi5mbG9vciA9IGZsb29yO1xuICBEZWNpbWFsMi5oeXBvdCA9IGh5cG90O1xuICBEZWNpbWFsMi5sbiA9IGxuO1xuICBEZWNpbWFsMi5sb2cgPSBsb2c7XG4gIERlY2ltYWwyLmxvZzEwID0gbG9nMTA7XG4gIERlY2ltYWwyLmxvZzIgPSBsb2cyO1xuICBEZWNpbWFsMi5tYXggPSBtYXg7XG4gIERlY2ltYWwyLm1pbiA9IG1pbjtcbiAgRGVjaW1hbDIubW9kID0gbW9kO1xuICBEZWNpbWFsMi5tdWwgPSBtdWw7XG4gIERlY2ltYWwyLnBvdyA9IHBvdztcbiAgRGVjaW1hbDIucmFuZG9tID0gcmFuZG9tO1xuICBEZWNpbWFsMi5yb3VuZCA9IHJvdW5kO1xuICBEZWNpbWFsMi5zaWduID0gc2lnbjtcbiAgRGVjaW1hbDIuc2luID0gc2luO1xuICBEZWNpbWFsMi5zaW5oID0gc2luaDtcbiAgRGVjaW1hbDIuc3FydCA9IHNxcnQ7XG4gIERlY2ltYWwyLnN1YiA9IHN1YjtcbiAgRGVjaW1hbDIuc3VtID0gc3VtO1xuICBEZWNpbWFsMi50YW4gPSB0YW47XG4gIERlY2ltYWwyLnRhbmggPSB0YW5oO1xuICBEZWNpbWFsMi50cnVuYyA9IHRydW5jO1xuICBpZiAob2JqID09PSB2b2lkIDApIG9iaiA9IHt9O1xuICBpZiAob2JqKSB7XG4gICAgaWYgKG9iai5kZWZhdWx0cyAhPT0gdHJ1ZSkge1xuICAgICAgcHMgPSBbXCJwcmVjaXNpb25cIiwgXCJyb3VuZGluZ1wiLCBcInRvRXhwTmVnXCIsIFwidG9FeHBQb3NcIiwgXCJtYXhFXCIsIFwibWluRVwiLCBcIm1vZHVsb1wiLCBcImNyeXB0b1wiXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBwcy5sZW5ndGg7ICkgaWYgKCFvYmouaGFzT3duUHJvcGVydHkocCA9IHBzW2krK10pKSBvYmpbcF0gPSB0aGlzW3BdO1xuICAgIH1cbiAgfVxuICBEZWNpbWFsMi5jb25maWcob2JqKTtcbiAgcmV0dXJuIERlY2ltYWwyO1xufVxuZnVuY3Rpb24gZGl2KHgsIHkpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmRpdih5KTtcbn1cbmZ1bmN0aW9uIGV4cCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5leHAoKTtcbn1cbmZ1bmN0aW9uIGZsb29yKHgpIHtcbiAgcmV0dXJuIGZpbmFsaXNlKHggPSBuZXcgdGhpcyh4KSwgeC5lICsgMSwgMyk7XG59XG5mdW5jdGlvbiBoeXBvdCgpIHtcbiAgdmFyIGksIG4sIHQgPSBuZXcgdGhpcygwKTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICkge1xuICAgIG4gPSBuZXcgdGhpcyhhcmd1bWVudHNbaSsrXSk7XG4gICAgaWYgKCFuLmQpIHtcbiAgICAgIGlmIChuLnMpIHtcbiAgICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoMSAvIDApO1xuICAgICAgfVxuICAgICAgdCA9IG47XG4gICAgfSBlbHNlIGlmICh0LmQpIHtcbiAgICAgIHQgPSB0LnBsdXMobi50aW1lcyhuKSk7XG4gICAgfVxuICB9XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIHQuc3FydCgpO1xufVxuZnVuY3Rpb24gaXNEZWNpbWFsSW5zdGFuY2Uob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBEZWNpbWFsIHx8IG9iaiAmJiBvYmoudG9TdHJpbmdUYWcgPT09IHRhZyB8fCBmYWxzZTtcbn1cbmZ1bmN0aW9uIGxuKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmxuKCk7XG59XG5mdW5jdGlvbiBsb2coeCwgeSkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkubG9nKHkpO1xufVxuZnVuY3Rpb24gbG9nMih4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5sb2coMik7XG59XG5mdW5jdGlvbiBsb2cxMCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5sb2coMTApO1xufVxuZnVuY3Rpb24gbWF4KCkge1xuICByZXR1cm4gbWF4T3JNaW4odGhpcywgYXJndW1lbnRzLCAtMSk7XG59XG5mdW5jdGlvbiBtaW4oKSB7XG4gIHJldHVybiBtYXhPck1pbih0aGlzLCBhcmd1bWVudHMsIDEpO1xufVxuZnVuY3Rpb24gbW9kKHgsIHkpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLm1vZCh5KTtcbn1cbmZ1bmN0aW9uIG11bCh4LCB5KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5tdWwoeSk7XG59XG5mdW5jdGlvbiBwb3coeCwgeSkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkucG93KHkpO1xufVxuZnVuY3Rpb24gcmFuZG9tKHNkKSB7XG4gIHZhciBkLCBlLCBrLCBuLCBpID0gMCwgciA9IG5ldyB0aGlzKDEpLCByZCA9IFtdO1xuICBpZiAoc2QgPT09IHZvaWQgMCkgc2QgPSB0aGlzLnByZWNpc2lvbjtcbiAgZWxzZSBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcbiAgayA9IE1hdGguY2VpbChzZCAvIExPR19CQVNFKTtcbiAgaWYgKCF0aGlzLmNyeXB0bykge1xuICAgIGZvciAoOyBpIDwgazsgKSByZFtpKytdID0gTWF0aC5yYW5kb20oKSAqIDFlNyB8IDA7XG4gIH0gZWxzZSBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIGQgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrKSk7XG4gICAgZm9yICg7IGkgPCBrOyApIHtcbiAgICAgIG4gPSBkW2ldO1xuICAgICAgaWYgKG4gPj0gNDI5ZTcpIHtcbiAgICAgICAgZFtpXSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJkW2krK10gPSBuICUgMWU3O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcbiAgICBkID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNCk7XG4gICAgZm9yICg7IGkgPCBrOyApIHtcbiAgICAgIG4gPSBkW2ldICsgKGRbaSArIDFdIDw8IDgpICsgKGRbaSArIDJdIDw8IDE2KSArICgoZFtpICsgM10gJiAxMjcpIDw8IDI0KTtcbiAgICAgIGlmIChuID49IDIxNGU3KSB7XG4gICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg0KS5jb3B5KGQsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmQucHVzaChuICUgMWU3KTtcbiAgICAgICAgaSArPSA0O1xuICAgICAgfVxuICAgIH1cbiAgICBpID0gayAvIDQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoY3J5cHRvVW5hdmFpbGFibGUpO1xuICB9XG4gIGsgPSByZFstLWldO1xuICBzZCAlPSBMT0dfQkFTRTtcbiAgaWYgKGsgJiYgc2QpIHtcbiAgICBuID0gbWF0aHBvdygxMCwgTE9HX0JBU0UgLSBzZCk7XG4gICAgcmRbaV0gPSAoayAvIG4gfCAwKSAqIG47XG4gIH1cbiAgZm9yICg7IHJkW2ldID09PSAwOyBpLS0pIHJkLnBvcCgpO1xuICBpZiAoaSA8IDApIHtcbiAgICBlID0gMDtcbiAgICByZCA9IFswXTtcbiAgfSBlbHNlIHtcbiAgICBlID0gLTE7XG4gICAgZm9yICg7IHJkWzBdID09PSAwOyBlIC09IExPR19CQVNFKSByZC5zaGlmdCgpO1xuICAgIGZvciAoayA9IDEsIG4gPSByZFswXTsgbiA+PSAxMDsgbiAvPSAxMCkgaysrO1xuICAgIGlmIChrIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBrO1xuICB9XG4gIHIuZSA9IGU7XG4gIHIuZCA9IHJkO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHJvdW5kKHgpIHtcbiAgcmV0dXJuIGZpbmFsaXNlKHggPSBuZXcgdGhpcyh4KSwgeC5lICsgMSwgdGhpcy5yb3VuZGluZyk7XG59XG5mdW5jdGlvbiBzaWduKHgpIHtcbiAgeCA9IG5ldyB0aGlzKHgpO1xuICByZXR1cm4geC5kID8geC5kWzBdID8geC5zIDogMCAqIHgucyA6IHgucyB8fCBOYU47XG59XG5mdW5jdGlvbiBzaW4oeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuc2luKCk7XG59XG5mdW5jdGlvbiBzaW5oKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnNpbmgoKTtcbn1cbmZ1bmN0aW9uIHNxcnQoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuc3FydCgpO1xufVxuZnVuY3Rpb24gc3ViKHgsIHkpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnN1Yih5KTtcbn1cbmZ1bmN0aW9uIHN1bSgpIHtcbiAgdmFyIGkgPSAwLCBhcmdzID0gYXJndW1lbnRzLCB4ID0gbmV3IHRoaXMoYXJnc1tpXSk7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIGZvciAoOyB4LnMgJiYgKytpIDwgYXJncy5sZW5ndGg7ICkgeCA9IHgucGx1cyhhcmdzW2ldKTtcbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4gZmluYWxpc2UoeCwgdGhpcy5wcmVjaXNpb24sIHRoaXMucm91bmRpbmcpO1xufVxuZnVuY3Rpb24gdGFuKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnRhbigpO1xufVxuZnVuY3Rpb24gdGFuaCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS50YW5oKCk7XG59XG5mdW5jdGlvbiB0cnVuYyh4KSB7XG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIDEpO1xufVxuUFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildID0gUC50b1N0cmluZztcblBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9IFwiRGVjaW1hbFwiO1xudmFyIERlY2ltYWwgPSBQLmNvbnN0cnVjdG9yID0gY2xvbmUoREVGQVVMVFMpO1xuTE4xMCA9IG5ldyBEZWNpbWFsKExOMTApO1xuUEkgPSBuZXcgRGVjaW1hbChQSSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zcWwtdGVtcGxhdGUtdGFnQDUuMi4xL25vZGVfbW9kdWxlcy9zcWwtdGVtcGxhdGUtdGFnL2Rpc3QvaW5kZXguanNcbnZhciBTcWwgPSBjbGFzcyBfU3FsIHtcbiAgY29uc3RydWN0b3IocmF3U3RyaW5ncywgcmF3VmFsdWVzKSB7XG4gICAgaWYgKHJhd1N0cmluZ3MubGVuZ3RoIC0gMSAhPT0gcmF3VmFsdWVzLmxlbmd0aCkge1xuICAgICAgaWYgKHJhd1N0cmluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCAxIHN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkICR7cmF3U3RyaW5ncy5sZW5ndGh9IHN0cmluZ3MgdG8gaGF2ZSAke3Jhd1N0cmluZ3MubGVuZ3RoIC0gMX0gdmFsdWVzYCk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlc0xlbmd0aCA9IHJhd1ZhbHVlcy5yZWR1Y2UoKGxlbiwgdmFsdWUpID0+IGxlbiArICh2YWx1ZSBpbnN0YW5jZW9mIF9TcWwgPyB2YWx1ZS52YWx1ZXMubGVuZ3RoIDogMSksIDApO1xuICAgIHRoaXMudmFsdWVzID0gbmV3IEFycmF5KHZhbHVlc0xlbmd0aCk7XG4gICAgdGhpcy5zdHJpbmdzID0gbmV3IEFycmF5KHZhbHVlc0xlbmd0aCArIDEpO1xuICAgIHRoaXMuc3RyaW5nc1swXSA9IHJhd1N0cmluZ3NbMF07XG4gICAgbGV0IGkgPSAwLCBwb3MgPSAwO1xuICAgIHdoaWxlIChpIDwgcmF3VmFsdWVzLmxlbmd0aCkge1xuICAgICAgY29uc3QgY2hpbGQgPSByYXdWYWx1ZXNbaSsrXTtcbiAgICAgIGNvbnN0IHJhd1N0cmluZyA9IHJhd1N0cmluZ3NbaV07XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBfU3FsKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nc1twb3NdICs9IGNoaWxkLnN0cmluZ3NbMF07XG4gICAgICAgIGxldCBjaGlsZEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGNoaWxkSW5kZXggPCBjaGlsZC52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZXNbcG9zKytdID0gY2hpbGQudmFsdWVzW2NoaWxkSW5kZXgrK107XG4gICAgICAgICAgdGhpcy5zdHJpbmdzW3Bvc10gPSBjaGlsZC5zdHJpbmdzW2NoaWxkSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RyaW5nc1twb3NdICs9IHJhd1N0cmluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWVzW3BvcysrXSA9IGNoaWxkO1xuICAgICAgICB0aGlzLnN0cmluZ3NbcG9zXSA9IHJhd1N0cmluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IHNxbCgpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLnN0cmluZ3MubGVuZ3RoO1xuICAgIGxldCBpID0gMTtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnN0cmluZ3NbMF07XG4gICAgd2hpbGUgKGkgPCBsZW4pXG4gICAgICB2YWx1ZSArPSBgPyR7dGhpcy5zdHJpbmdzW2krK119YDtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZ2V0IHN0YXRlbWVudCgpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLnN0cmluZ3MubGVuZ3RoO1xuICAgIGxldCBpID0gMTtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnN0cmluZ3NbMF07XG4gICAgd2hpbGUgKGkgPCBsZW4pXG4gICAgICB2YWx1ZSArPSBgOiR7aX0ke3RoaXMuc3RyaW5nc1tpKytdfWA7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGdldCB0ZXh0KCkge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuc3RyaW5ncy5sZW5ndGg7XG4gICAgbGV0IGkgPSAxO1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuc3RyaW5nc1swXTtcbiAgICB3aGlsZSAoaSA8IGxlbilcbiAgICAgIHZhbHVlICs9IGAkJHtpfSR7dGhpcy5zdHJpbmdzW2krK119YDtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaW5zcGVjdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3FsOiB0aGlzLnNxbCxcbiAgICAgIHN0YXRlbWVudDogdGhpcy5zdGF0ZW1lbnQsXG4gICAgICB0ZXh0OiB0aGlzLnRleHQsXG4gICAgICB2YWx1ZXM6IHRoaXMudmFsdWVzXG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGpvaW4odmFsdWVzLCBzZXBhcmF0b3IgPSBcIixcIiwgcHJlZml4ID0gXCJcIiwgc3VmZml4ID0gXCJcIikge1xuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBgam9pbihbXSlgIHRvIGJlIGNhbGxlZCB3aXRoIGFuIGFycmF5IG9mIG11bHRpcGxlIGVsZW1lbnRzLCBidXQgZ290IGFuIGVtcHR5IGFycmF5XCIpO1xuICB9XG4gIHJldHVybiBuZXcgU3FsKFtwcmVmaXgsIC4uLkFycmF5KHZhbHVlcy5sZW5ndGggLSAxKS5maWxsKHNlcGFyYXRvciksIHN1ZmZpeF0sIHZhbHVlcyk7XG59XG5mdW5jdGlvbiByYXcodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBTcWwoW3ZhbHVlXSwgW10pO1xufVxudmFyIGVtcHR5ID0gcmF3KFwiXCIpO1xuZnVuY3Rpb24gc3FsKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICByZXR1cm4gbmV3IFNxbChzdHJpbmdzLCB2YWx1ZXMpO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFueU51bGwsXG4gIEFueU51bGxDbGFzcyxcbiAgRGJOdWxsLFxuICBEYk51bGxDbGFzcyxcbiAgRGVjaW1hbCxcbiAgSnNvbk51bGwsXG4gIEpzb25OdWxsQ2xhc3MsXG4gIE51bGxUeXBlcyxcbiAgT2JqZWN0RW51bVZhbHVlLFxuICBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yLFxuICBQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvcixcbiAgUHJpc21hQ2xpZW50UnVzdEVycm9yLFxuICBQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvcixcbiAgUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcixcbiAgUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yLFxuICBTcWwsXG4gIGVtcHR5LFxuICBoYXNCYXRjaEluZGV4LFxuICBpc0FueU51bGwsXG4gIGlzRGJOdWxsLFxuICBpc0pzb25OdWxsLFxuICBqb2luLFxuICByYXcsXG4gIHNxbFxufSk7XG4vKiEgQnVuZGxlZCBsaWNlbnNlIGluZm9ybWF0aW9uOlxuXG5kZWNpbWFsLmpzL2RlY2ltYWwubWpzOlxuICAoKiFcbiAgICogIGRlY2ltYWwuanMgdjEwLjUuMFxuICAgKiAgQW4gYXJiaXRyYXJ5LXByZWNpc2lvbiBEZWNpbWFsIHR5cGUgZm9yIEphdmFTY3JpcHQuXG4gICAqICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9kZWNpbWFsLmpzXG4gICAqICBDb3B5cmlnaHQgKGMpIDIwMjUgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cbiAgICogIE1JVCBMaWNlbmNlXG4gICAqKVxuKi9cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@prisma/client-runtime-utils/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@prisma/adapter-pg/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@prisma/adapter-pg/dist/index.mjs ***!
  \********************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PrismaPg: () => (/* binding */ PrismaPgAdapterFactory)\n/* harmony export */ });\n/* harmony import */ var _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @prisma/driver-adapter-utils */ \"(rsc)/./node_modules/@prisma/debug/dist/index.mjs\");\n/* harmony import */ var _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @prisma/driver-adapter-utils */ \"(rsc)/./node_modules/@prisma/driver-adapter-utils/dist/index.mjs\");\n/* harmony import */ var pg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pg */ \"pg\");\n/* harmony import */ var postgres_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! postgres-array */ \"(rsc)/./node_modules/postgres-array/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([pg__WEBPACK_IMPORTED_MODULE_0__]);\npg__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// src/pg.ts\n\n\n\n// package.json\nvar name = \"@prisma/adapter-pg\";\n\n// src/constants.ts\nvar FIRST_NORMAL_OBJECT_ID = 16384;\n\n// src/conversion.ts\n\n\n\nvar { types } = pg__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nvar { builtins: ScalarColumnType, getTypeParser } = types;\nvar AdditionalScalarColumnType = {\n  NAME: 19\n};\nvar ArrayColumnType = {\n  BIT_ARRAY: 1561,\n  BOOL_ARRAY: 1e3,\n  BYTEA_ARRAY: 1001,\n  BPCHAR_ARRAY: 1014,\n  CHAR_ARRAY: 1002,\n  CIDR_ARRAY: 651,\n  DATE_ARRAY: 1182,\n  FLOAT4_ARRAY: 1021,\n  FLOAT8_ARRAY: 1022,\n  INET_ARRAY: 1041,\n  INT2_ARRAY: 1005,\n  INT4_ARRAY: 1007,\n  INT8_ARRAY: 1016,\n  JSONB_ARRAY: 3807,\n  JSON_ARRAY: 199,\n  MONEY_ARRAY: 791,\n  NUMERIC_ARRAY: 1231,\n  OID_ARRAY: 1028,\n  TEXT_ARRAY: 1009,\n  TIMESTAMP_ARRAY: 1115,\n  TIMESTAMPTZ_ARRAY: 1185,\n  TIME_ARRAY: 1183,\n  UUID_ARRAY: 2951,\n  VARBIT_ARRAY: 1563,\n  VARCHAR_ARRAY: 1015,\n  XML_ARRAY: 143\n};\nvar UnsupportedNativeDataType = class _UnsupportedNativeDataType extends Error {\n  // map of type codes to type names\n  static typeNames = {\n    16: \"bool\",\n    17: \"bytea\",\n    18: \"char\",\n    19: \"name\",\n    20: \"int8\",\n    21: \"int2\",\n    22: \"int2vector\",\n    23: \"int4\",\n    24: \"regproc\",\n    25: \"text\",\n    26: \"oid\",\n    27: \"tid\",\n    28: \"xid\",\n    29: \"cid\",\n    30: \"oidvector\",\n    32: \"pg_ddl_command\",\n    71: \"pg_type\",\n    75: \"pg_attribute\",\n    81: \"pg_proc\",\n    83: \"pg_class\",\n    114: \"json\",\n    142: \"xml\",\n    194: \"pg_node_tree\",\n    269: \"table_am_handler\",\n    325: \"index_am_handler\",\n    600: \"point\",\n    601: \"lseg\",\n    602: \"path\",\n    603: \"box\",\n    604: \"polygon\",\n    628: \"line\",\n    650: \"cidr\",\n    700: \"float4\",\n    701: \"float8\",\n    705: \"unknown\",\n    718: \"circle\",\n    774: \"macaddr8\",\n    790: \"money\",\n    829: \"macaddr\",\n    869: \"inet\",\n    1033: \"aclitem\",\n    1042: \"bpchar\",\n    1043: \"varchar\",\n    1082: \"date\",\n    1083: \"time\",\n    1114: \"timestamp\",\n    1184: \"timestamptz\",\n    1186: \"interval\",\n    1266: \"timetz\",\n    1560: \"bit\",\n    1562: \"varbit\",\n    1700: \"numeric\",\n    1790: \"refcursor\",\n    2202: \"regprocedure\",\n    2203: \"regoper\",\n    2204: \"regoperator\",\n    2205: \"regclass\",\n    2206: \"regtype\",\n    2249: \"record\",\n    2275: \"cstring\",\n    2276: \"any\",\n    2277: \"anyarray\",\n    2278: \"void\",\n    2279: \"trigger\",\n    2280: \"language_handler\",\n    2281: \"internal\",\n    2283: \"anyelement\",\n    2287: \"_record\",\n    2776: \"anynonarray\",\n    2950: \"uuid\",\n    2970: \"txid_snapshot\",\n    3115: \"fdw_handler\",\n    3220: \"pg_lsn\",\n    3310: \"tsm_handler\",\n    3361: \"pg_ndistinct\",\n    3402: \"pg_dependencies\",\n    3500: \"anyenum\",\n    3614: \"tsvector\",\n    3615: \"tsquery\",\n    3642: \"gtsvector\",\n    3734: \"regconfig\",\n    3769: \"regdictionary\",\n    3802: \"jsonb\",\n    3831: \"anyrange\",\n    3838: \"event_trigger\",\n    3904: \"int4range\",\n    3906: \"numrange\",\n    3908: \"tsrange\",\n    3910: \"tstzrange\",\n    3912: \"daterange\",\n    3926: \"int8range\",\n    4072: \"jsonpath\",\n    4089: \"regnamespace\",\n    4096: \"regrole\",\n    4191: \"regcollation\",\n    4451: \"int4multirange\",\n    4532: \"nummultirange\",\n    4533: \"tsmultirange\",\n    4534: \"tstzmultirange\",\n    4535: \"datemultirange\",\n    4536: \"int8multirange\",\n    4537: \"anymultirange\",\n    4538: \"anycompatiblemultirange\",\n    4600: \"pg_brin_bloom_summary\",\n    4601: \"pg_brin_minmax_multi_summary\",\n    5017: \"pg_mcv_list\",\n    5038: \"pg_snapshot\",\n    5069: \"xid8\",\n    5077: \"anycompatible\",\n    5078: \"anycompatiblearray\",\n    5079: \"anycompatiblenonarray\",\n    5080: \"anycompatiblerange\"\n  };\n  type;\n  constructor(code) {\n    super();\n    this.type = _UnsupportedNativeDataType.typeNames[code] || \"Unknown\";\n    this.message = `Unsupported column type ${this.type}`;\n  }\n};\nfunction fieldToColumnType(fieldTypeId) {\n  switch (fieldTypeId) {\n    case ScalarColumnType.INT2:\n    case ScalarColumnType.INT4:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.Int32;\n    case ScalarColumnType.INT8:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.Int64;\n    case ScalarColumnType.FLOAT4:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.Float;\n    case ScalarColumnType.FLOAT8:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.Double;\n    case ScalarColumnType.BOOL:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.Boolean;\n    case ScalarColumnType.DATE:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.Date;\n    case ScalarColumnType.TIME:\n    case ScalarColumnType.TIMETZ:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.Time;\n    case ScalarColumnType.TIMESTAMP:\n    case ScalarColumnType.TIMESTAMPTZ:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.DateTime;\n    case ScalarColumnType.NUMERIC:\n    case ScalarColumnType.MONEY:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.Numeric;\n    case ScalarColumnType.JSON:\n    case ScalarColumnType.JSONB:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.Json;\n    case ScalarColumnType.UUID:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.Uuid;\n    case ScalarColumnType.OID:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.Int64;\n    case ScalarColumnType.BPCHAR:\n    case ScalarColumnType.TEXT:\n    case ScalarColumnType.VARCHAR:\n    case ScalarColumnType.BIT:\n    case ScalarColumnType.VARBIT:\n    case ScalarColumnType.INET:\n    case ScalarColumnType.CIDR:\n    case ScalarColumnType.XML:\n    case AdditionalScalarColumnType.NAME:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.Text;\n    case ScalarColumnType.BYTEA:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.Bytes;\n    case ArrayColumnType.INT2_ARRAY:\n    case ArrayColumnType.INT4_ARRAY:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.Int32Array;\n    case ArrayColumnType.FLOAT4_ARRAY:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.FloatArray;\n    case ArrayColumnType.FLOAT8_ARRAY:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.DoubleArray;\n    case ArrayColumnType.NUMERIC_ARRAY:\n    case ArrayColumnType.MONEY_ARRAY:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.NumericArray;\n    case ArrayColumnType.BOOL_ARRAY:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.BooleanArray;\n    case ArrayColumnType.CHAR_ARRAY:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.CharacterArray;\n    case ArrayColumnType.BPCHAR_ARRAY:\n    case ArrayColumnType.TEXT_ARRAY:\n    case ArrayColumnType.VARCHAR_ARRAY:\n    case ArrayColumnType.VARBIT_ARRAY:\n    case ArrayColumnType.BIT_ARRAY:\n    case ArrayColumnType.INET_ARRAY:\n    case ArrayColumnType.CIDR_ARRAY:\n    case ArrayColumnType.XML_ARRAY:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.TextArray;\n    case ArrayColumnType.DATE_ARRAY:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.DateArray;\n    case ArrayColumnType.TIME_ARRAY:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.TimeArray;\n    case ArrayColumnType.TIMESTAMP_ARRAY:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.DateTimeArray;\n    case ArrayColumnType.TIMESTAMPTZ_ARRAY:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.DateTimeArray;\n    case ArrayColumnType.JSON_ARRAY:\n    case ArrayColumnType.JSONB_ARRAY:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.JsonArray;\n    case ArrayColumnType.BYTEA_ARRAY:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.BytesArray;\n    case ArrayColumnType.UUID_ARRAY:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.UuidArray;\n    case ArrayColumnType.INT8_ARRAY:\n    case ArrayColumnType.OID_ARRAY:\n      return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.Int64Array;\n    default:\n      if (fieldTypeId >= FIRST_NORMAL_OBJECT_ID) {\n        return _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.ColumnTypeEnum.Text;\n      }\n      throw new UnsupportedNativeDataType(fieldTypeId);\n  }\n}\nfunction normalize_array(element_normalizer) {\n  return (str) => (0,postgres_array__WEBPACK_IMPORTED_MODULE_1__.parse)(str, element_normalizer);\n}\nfunction normalize_numeric(numeric) {\n  return numeric;\n}\nfunction normalize_date(date) {\n  return date;\n}\nfunction normalize_timestamp(time) {\n  return `${time.replace(\" \", \"T\")}+00:00`;\n}\nfunction normalize_timestamptz(time) {\n  return time.replace(\" \", \"T\").replace(/[+-]\\d{2}(:\\d{2})?$/, \"+00:00\");\n}\nfunction normalize_time(time) {\n  return time;\n}\nfunction normalize_timez(time) {\n  return time.replace(/[+-]\\d{2}(:\\d{2})?$/, \"\");\n}\nfunction normalize_money(money) {\n  return money.slice(1);\n}\nfunction normalize_xml(xml) {\n  return xml;\n}\nfunction toJson(json) {\n  return json;\n}\nfunction encodeBuffer(buffer) {\n  return Array.from(new Uint8Array(buffer));\n}\nvar parsePgBytes = getTypeParser(ScalarColumnType.BYTEA);\nvar parseBytesArray = getTypeParser(ArrayColumnType.BYTEA_ARRAY);\nfunction normalizeByteaArray(serializedBytesArray) {\n  const buffers = parseBytesArray(serializedBytesArray);\n  return buffers.map((buf) => buf ? encodeBuffer(buf) : null);\n}\nfunction convertBytes(serializedBytes) {\n  const buffer = parsePgBytes(serializedBytes);\n  return encodeBuffer(buffer);\n}\nfunction normalizeBit(bit) {\n  return bit;\n}\nvar customParsers = {\n  [ScalarColumnType.NUMERIC]: normalize_numeric,\n  [ArrayColumnType.NUMERIC_ARRAY]: normalize_array(normalize_numeric),\n  [ScalarColumnType.TIME]: normalize_time,\n  [ArrayColumnType.TIME_ARRAY]: normalize_array(normalize_time),\n  [ScalarColumnType.TIMETZ]: normalize_timez,\n  [ScalarColumnType.DATE]: normalize_date,\n  [ArrayColumnType.DATE_ARRAY]: normalize_array(normalize_date),\n  [ScalarColumnType.TIMESTAMP]: normalize_timestamp,\n  [ArrayColumnType.TIMESTAMP_ARRAY]: normalize_array(normalize_timestamp),\n  [ScalarColumnType.TIMESTAMPTZ]: normalize_timestamptz,\n  [ArrayColumnType.TIMESTAMPTZ_ARRAY]: normalize_array(normalize_timestamptz),\n  [ScalarColumnType.MONEY]: normalize_money,\n  [ArrayColumnType.MONEY_ARRAY]: normalize_array(normalize_money),\n  [ScalarColumnType.JSON]: toJson,\n  [ArrayColumnType.JSON_ARRAY]: normalize_array(toJson),\n  [ScalarColumnType.JSONB]: toJson,\n  [ArrayColumnType.JSONB_ARRAY]: normalize_array(toJson),\n  [ScalarColumnType.BYTEA]: convertBytes,\n  [ArrayColumnType.BYTEA_ARRAY]: normalizeByteaArray,\n  [ArrayColumnType.BIT_ARRAY]: normalize_array(normalizeBit),\n  [ArrayColumnType.VARBIT_ARRAY]: normalize_array(normalizeBit),\n  [ArrayColumnType.XML_ARRAY]: normalize_array(normalize_xml)\n};\nfunction mapArg(arg, argType) {\n  if (arg === null) {\n    return null;\n  }\n  if (Array.isArray(arg) && argType.arity === \"list\") {\n    return arg.map((value) => mapArg(value, argType));\n  }\n  if (typeof arg === \"string\" && argType.scalarType === \"datetime\") {\n    arg = new Date(arg);\n  }\n  if (arg instanceof Date) {\n    switch (argType.dbType) {\n      case \"TIME\":\n      case \"TIMETZ\":\n        return formatTime(arg);\n      case \"DATE\":\n        return formatDate(arg);\n      default:\n        return formatDateTime(arg);\n    }\n  }\n  if (typeof arg === \"string\" && argType.scalarType === \"bytes\") {\n    return Buffer.from(arg, \"base64\");\n  }\n  if (Array.isArray(arg) && argType.scalarType === \"bytes\") {\n    return Buffer.from(arg);\n  }\n  if (ArrayBuffer.isView(arg)) {\n    return Buffer.from(arg.buffer, arg.byteOffset, arg.byteLength);\n  }\n  return arg;\n}\nfunction formatDateTime(date) {\n  const pad = (n, z = 2) => String(n).padStart(z, \"0\");\n  const ms = date.getUTCMilliseconds();\n  return pad(date.getUTCFullYear(), 4) + \"-\" + pad(date.getUTCMonth() + 1) + \"-\" + pad(date.getUTCDate()) + \" \" + pad(date.getUTCHours()) + \":\" + pad(date.getUTCMinutes()) + \":\" + pad(date.getUTCSeconds()) + (ms ? \".\" + String(ms).padStart(3, \"0\") : \"\");\n}\nfunction formatDate(date) {\n  const pad = (n, z = 2) => String(n).padStart(z, \"0\");\n  return pad(date.getUTCFullYear(), 4) + \"-\" + pad(date.getUTCMonth() + 1) + \"-\" + pad(date.getUTCDate());\n}\nfunction formatTime(date) {\n  const pad = (n, z = 2) => String(n).padStart(z, \"0\");\n  const ms = date.getUTCMilliseconds();\n  return pad(date.getUTCHours()) + \":\" + pad(date.getUTCMinutes()) + \":\" + pad(date.getUTCSeconds()) + (ms ? \".\" + String(ms).padStart(3, \"0\") : \"\");\n}\n\n// src/errors.ts\nvar TLS_ERRORS = /* @__PURE__ */ new Set([\n  \"UNABLE_TO_GET_ISSUER_CERT\",\n  \"UNABLE_TO_GET_CRL\",\n  \"UNABLE_TO_DECRYPT_CERT_SIGNATURE\",\n  \"UNABLE_TO_DECRYPT_CRL_SIGNATURE\",\n  \"UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY\",\n  \"CERT_SIGNATURE_FAILURE\",\n  \"CRL_SIGNATURE_FAILURE\",\n  \"CERT_NOT_YET_VALID\",\n  \"CERT_HAS_EXPIRED\",\n  \"CRL_NOT_YET_VALID\",\n  \"CRL_HAS_EXPIRED\",\n  \"ERROR_IN_CERT_NOT_BEFORE_FIELD\",\n  \"ERROR_IN_CERT_NOT_AFTER_FIELD\",\n  \"ERROR_IN_CRL_LAST_UPDATE_FIELD\",\n  \"ERROR_IN_CRL_NEXT_UPDATE_FIELD\",\n  \"DEPTH_ZERO_SELF_SIGNED_CERT\",\n  \"SELF_SIGNED_CERT_IN_CHAIN\",\n  \"UNABLE_TO_GET_ISSUER_CERT_LOCALLY\",\n  \"UNABLE_TO_VERIFY_LEAF_SIGNATURE\",\n  \"CERT_CHAIN_TOO_LONG\",\n  \"CERT_REVOKED\",\n  \"INVALID_CA\",\n  \"INVALID_PURPOSE\",\n  \"CERT_UNTRUSTED\",\n  \"CERT_REJECTED\",\n  \"HOSTNAME_MISMATCH\",\n  \"ERR_TLS_CERT_ALTNAME_FORMAT\",\n  \"ERR_TLS_CERT_ALTNAME_INVALID\"\n]);\nvar SOCKET_ERRORS = /* @__PURE__ */ new Set([\"ENOTFOUND\", \"ECONNREFUSED\", \"ECONNRESET\", \"ETIMEDOUT\"]);\nfunction convertDriverError(error) {\n  if (isSocketError(error)) {\n    return mapSocketError(error);\n  }\n  if (isTlsError(error)) {\n    return {\n      kind: \"TlsConnectionError\",\n      reason: error.message\n    };\n  }\n  if (isDriverError(error)) {\n    return {\n      originalCode: error.code,\n      originalMessage: error.message,\n      ...mapDriverError(error)\n    };\n  }\n  throw error;\n}\nfunction mapDriverError(error) {\n  switch (error.code) {\n    case \"22001\":\n      return {\n        kind: \"LengthMismatch\",\n        column: error.column\n      };\n    case \"22003\":\n      return {\n        kind: \"ValueOutOfRange\",\n        cause: error.message\n      };\n    case \"23505\": {\n      const fields = error.detail?.match(/Key \\(([^)]+)\\)/)?.at(1)?.split(\", \");\n      return {\n        kind: \"UniqueConstraintViolation\",\n        constraint: fields !== void 0 ? { fields } : void 0\n      };\n    }\n    case \"23502\": {\n      const fields = error.detail?.match(/Key \\(([^)]+)\\)/)?.at(1)?.split(\", \");\n      return {\n        kind: \"NullConstraintViolation\",\n        constraint: fields !== void 0 ? { fields } : void 0\n      };\n    }\n    case \"23503\": {\n      let constraint;\n      if (error.column) {\n        constraint = { fields: [error.column] };\n      } else if (error.constraint) {\n        constraint = { index: error.constraint };\n      }\n      return {\n        kind: \"ForeignKeyConstraintViolation\",\n        constraint\n      };\n    }\n    case \"3D000\":\n      return {\n        kind: \"DatabaseDoesNotExist\",\n        db: error.message.split(\" \").at(1)?.split('\"').at(1)\n      };\n    case \"28000\":\n      return {\n        kind: \"DatabaseAccessDenied\",\n        db: error.message.split(\",\").find((s) => s.startsWith(\" database\"))?.split('\"').at(1)\n      };\n    case \"28P01\":\n      return {\n        kind: \"AuthenticationFailed\",\n        user: error.message.split(\" \").pop()?.split('\"').at(1)\n      };\n    case \"40001\":\n      return {\n        kind: \"TransactionWriteConflict\"\n      };\n    case \"42P01\":\n      return {\n        kind: \"TableDoesNotExist\",\n        table: error.message.split(\" \").at(1)?.split('\"').at(1)\n      };\n    case \"42703\":\n      return {\n        kind: \"ColumnNotFound\",\n        column: error.message.split(\" \").at(1)?.split('\"').at(1)\n      };\n    case \"42P04\":\n      return {\n        kind: \"DatabaseAlreadyExists\",\n        db: error.message.split(\" \").at(1)?.split('\"').at(1)\n      };\n    case \"53300\":\n      return {\n        kind: \"TooManyConnections\",\n        cause: error.message\n      };\n    default:\n      return {\n        kind: \"postgres\",\n        code: error.code ?? \"N/A\",\n        severity: error.severity ?? \"N/A\",\n        message: error.message,\n        detail: error.detail,\n        column: error.column,\n        hint: error.hint\n      };\n  }\n}\nfunction isDriverError(error) {\n  return typeof error.code === \"string\" && typeof error.message === \"string\" && typeof error.severity === \"string\" && (typeof error.detail === \"string\" || error.detail === void 0) && (typeof error.column === \"string\" || error.column === void 0) && (typeof error.hint === \"string\" || error.hint === void 0);\n}\nfunction mapSocketError(error) {\n  switch (error.code) {\n    case \"ENOTFOUND\":\n    case \"ECONNREFUSED\":\n      return {\n        kind: \"DatabaseNotReachable\",\n        host: error.address ?? error.hostname,\n        port: error.port\n      };\n    case \"ECONNRESET\":\n      return {\n        kind: \"ConnectionClosed\"\n      };\n    case \"ETIMEDOUT\":\n      return {\n        kind: \"SocketTimeout\"\n      };\n  }\n}\nfunction isSocketError(error) {\n  return typeof error.code === \"string\" && typeof error.syscall === \"string\" && typeof error.errno === \"number\" && SOCKET_ERRORS.has(error.code);\n}\nfunction isTlsError(error) {\n  if (typeof error.code === \"string\") {\n    return TLS_ERRORS.has(error.code);\n  }\n  switch (error.message) {\n    case \"The server does not support SSL connections\":\n    case \"There was an error establishing an SSL connection\":\n      return true;\n  }\n  return false;\n}\n\n// src/pg.ts\nvar types2 = pg__WEBPACK_IMPORTED_MODULE_0__[\"default\"].types;\nvar debug = (0,_prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_3__.Debug)(\"prisma:driver-adapter:pg\");\nvar PgQueryable = class {\n  constructor(client, pgOptions) {\n    this.client = client;\n    this.pgOptions = pgOptions;\n  }\n  provider = \"postgres\";\n  adapterName = name;\n  /**\n   * Execute a query given as SQL, interpolating the given parameters.\n   */\n  async queryRaw(query) {\n    const tag = \"[js::query_raw]\";\n    debug(`${tag} %O`, query);\n    const { fields, rows } = await this.performIO(query);\n    const columnNames = fields.map((field) => field.name);\n    let columnTypes = [];\n    try {\n      columnTypes = fields.map((field) => fieldToColumnType(field.dataTypeID));\n    } catch (e) {\n      if (e instanceof UnsupportedNativeDataType) {\n        throw new _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.DriverAdapterError({\n          kind: \"UnsupportedNativeDataType\",\n          type: e.type\n        });\n      }\n      throw e;\n    }\n    const udtParser = this.pgOptions?.userDefinedTypeParser;\n    if (udtParser) {\n      for (let i = 0; i < fields.length; i++) {\n        const field = fields[i];\n        if (field.dataTypeID >= FIRST_NORMAL_OBJECT_ID && !Object.hasOwn(customParsers, field.dataTypeID)) {\n          for (let j = 0; j < rows.length; j++) {\n            rows[j][i] = await udtParser(field.dataTypeID, rows[j][i], this);\n          }\n        }\n      }\n    }\n    return {\n      columnNames,\n      columnTypes,\n      rows\n    };\n  }\n  /**\n   * Execute a query given as SQL, interpolating the given parameters and\n   * returning the number of affected rows.\n   * Note: Queryable expects a u64, but napi.rs only supports u32.\n   */\n  async executeRaw(query) {\n    const tag = \"[js::execute_raw]\";\n    debug(`${tag} %O`, query);\n    return (await this.performIO(query)).rowCount ?? 0;\n  }\n  /**\n   * Run a query against the database, returning the result set.\n   * Should the query fail due to a connection error, the connection is\n   * marked as unhealthy.\n   */\n  async performIO(query) {\n    const { sql, args } = query;\n    const values = args.map((arg, i) => mapArg(arg, query.argTypes[i]));\n    try {\n      const result = await this.client.query(\n        {\n          text: sql,\n          values,\n          rowMode: \"array\",\n          types: {\n            // This is the error expected:\n            // No overload matches this call.\n            // The last overload gave the following error.\n            // Type '(oid: number, format?: any) => (json: string) => unknown' is not assignable to type '{ <T>(oid: number): TypeParser<string, string | T>; <T>(oid: number, format: \"text\"): TypeParser<string, string | T>; <T>(oid: number, format: \"binary\"): TypeParser<...>; }'.\n            //   Type '(json: string) => unknown' is not assignable to type 'TypeParser<Buffer, any>'.\n            //     Types of parameters 'json' and 'value' are incompatible.\n            //       Type 'Buffer' is not assignable to type 'string'.ts(2769)\n            //\n            // Because pg-types types expect us to handle both binary and text protocol versions,\n            // where as far we can see, pg will ever pass only text version.\n            //\n            // @ts-expect-error\n            getTypeParser: (oid, format) => {\n              if (format === \"text\" && customParsers[oid]) {\n                return customParsers[oid];\n              }\n              return types2.getTypeParser(oid, format);\n            }\n          }\n        },\n        values\n      );\n      return result;\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n  onError(error) {\n    debug(\"Error in performIO: %O\", error);\n    throw new _prisma_driver_adapter_utils__WEBPACK_IMPORTED_MODULE_2__.DriverAdapterError(convertDriverError(error));\n  }\n};\nvar PgTransaction = class extends PgQueryable {\n  constructor(client, options, pgOptions, cleanup) {\n    super(client, pgOptions);\n    this.options = options;\n    this.pgOptions = pgOptions;\n    this.cleanup = cleanup;\n  }\n  async commit() {\n    debug(`[js::commit]`);\n    this.cleanup?.();\n    this.client.release();\n  }\n  async rollback() {\n    debug(`[js::rollback]`);\n    this.cleanup?.();\n    this.client.release();\n  }\n};\nvar PrismaPgAdapter = class extends PgQueryable {\n  constructor(client, pgOptions, release) {\n    super(client);\n    this.pgOptions = pgOptions;\n    this.release = release;\n  }\n  async startTransaction(isolationLevel) {\n    const options = {\n      usePhantomQuery: false\n    };\n    const tag = \"[js::startTransaction]\";\n    debug(\"%s options: %O\", tag, options);\n    const conn = await this.client.connect().catch((error) => this.onError(error));\n    const onError = (err) => {\n      debug(`Error from pool connection: ${err.message} %O`, err);\n      this.pgOptions?.onConnectionError?.(err);\n    };\n    conn.on(\"error\", onError);\n    const cleanup = () => {\n      conn.removeListener(\"error\", onError);\n    };\n    try {\n      const tx = new PgTransaction(conn, options, this.pgOptions, cleanup);\n      await tx.executeRaw({ sql: \"BEGIN\", args: [], argTypes: [] });\n      if (isolationLevel) {\n        await tx.executeRaw({\n          sql: `SET TRANSACTION ISOLATION LEVEL ${isolationLevel}`,\n          args: [],\n          argTypes: []\n        });\n      }\n      return tx;\n    } catch (error) {\n      cleanup();\n      conn.release(error);\n      this.onError(error);\n    }\n  }\n  async executeScript(script) {\n    const statements = script.split(\";\").map((stmt) => stmt.trim()).filter((stmt) => stmt.length > 0);\n    for (const stmt of statements) {\n      try {\n        await this.client.query(stmt);\n      } catch (error) {\n        this.onError(error);\n      }\n    }\n  }\n  getConnectionInfo() {\n    return {\n      schemaName: this.pgOptions?.schema,\n      supportsRelationJoins: true\n    };\n  }\n  async dispose() {\n    return this.release?.();\n  }\n  underlyingDriver() {\n    return this.client;\n  }\n};\nvar PrismaPgAdapterFactory = class {\n  constructor(poolOrConfig, options) {\n    this.options = options;\n    if (poolOrConfig instanceof pg__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Pool) {\n      this.externalPool = poolOrConfig;\n      this.config = poolOrConfig.options;\n    } else {\n      this.externalPool = null;\n      this.config = poolOrConfig;\n    }\n  }\n  provider = \"postgres\";\n  adapterName = name;\n  config;\n  externalPool;\n  async connect() {\n    const client = this.externalPool ?? new pg__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Pool(this.config);\n    const onIdleClientError = (err) => {\n      debug(`Error from idle pool client: ${err.message} %O`, err);\n      this.options?.onPoolError?.(err);\n    };\n    client.on(\"error\", onIdleClientError);\n    return new PrismaPgAdapter(client, this.options, async () => {\n      if (this.externalPool) {\n        if (this.options?.disposeExternalPool) {\n          await this.externalPool.end();\n          this.externalPool = null;\n        } else {\n          this.externalPool.removeListener(\"error\", onIdleClientError);\n        }\n      } else {\n        await client.end();\n      }\n    });\n  }\n  async connectToShadowDb() {\n    const conn = await this.connect();\n    const database = `prisma_migrate_shadow_db_${globalThis.crypto.randomUUID()}`;\n    await conn.executeScript(`CREATE DATABASE \"${database}\"`);\n    const client = new pg__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Pool({ ...this.config, database });\n    return new PrismaPgAdapter(client, void 0, async () => {\n      await conn.executeScript(`DROP DATABASE \"${database}\"`);\n      await client.end();\n    });\n  }\n};\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHByaXNtYS9hZGFwdGVyLXBnL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDeUU7QUFDcEQ7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUM4RDtBQUMxQztBQUNpQztBQUNyRCxNQUFNLFFBQVEsRUFBRSwwQ0FBRTtBQUNsQixNQUFNLDRDQUE0QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0VBQWM7QUFDM0I7QUFDQSxhQUFhLHdFQUFjO0FBQzNCO0FBQ0EsYUFBYSx3RUFBYztBQUMzQjtBQUNBLGFBQWEsd0VBQWM7QUFDM0I7QUFDQSxhQUFhLHdFQUFjO0FBQzNCO0FBQ0EsYUFBYSx3RUFBYztBQUMzQjtBQUNBO0FBQ0EsYUFBYSx3RUFBYztBQUMzQjtBQUNBO0FBQ0EsYUFBYSx3RUFBYztBQUMzQjtBQUNBO0FBQ0EsYUFBYSx3RUFBYztBQUMzQjtBQUNBO0FBQ0EsYUFBYSx3RUFBYztBQUMzQjtBQUNBLGFBQWEsd0VBQWM7QUFDM0I7QUFDQSxhQUFhLHdFQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0VBQWM7QUFDM0I7QUFDQSxhQUFhLHdFQUFjO0FBQzNCO0FBQ0E7QUFDQSxhQUFhLHdFQUFjO0FBQzNCO0FBQ0EsYUFBYSx3RUFBYztBQUMzQjtBQUNBLGFBQWEsd0VBQWM7QUFDM0I7QUFDQTtBQUNBLGFBQWEsd0VBQWM7QUFDM0I7QUFDQSxhQUFhLHdFQUFjO0FBQzNCO0FBQ0EsYUFBYSx3RUFBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3RUFBYztBQUMzQjtBQUNBLGFBQWEsd0VBQWM7QUFDM0I7QUFDQSxhQUFhLHdFQUFjO0FBQzNCO0FBQ0EsYUFBYSx3RUFBYztBQUMzQjtBQUNBLGFBQWEsd0VBQWM7QUFDM0I7QUFDQTtBQUNBLGFBQWEsd0VBQWM7QUFDM0I7QUFDQSxhQUFhLHdFQUFjO0FBQzNCO0FBQ0EsYUFBYSx3RUFBYztBQUMzQjtBQUNBO0FBQ0EsYUFBYSx3RUFBYztBQUMzQjtBQUNBO0FBQ0EsZUFBZSx3RUFBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFEQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0EsZ0RBQWdELEVBQUUsS0FBSyxFQUFFO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRSxLQUFLLEVBQUU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixRQUFRO0FBQ1IsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZ0RBQVM7QUFDdEIsWUFBWSxtRUFBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0JBQWtCLDRFQUFrQjtBQUNwQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEcsa0RBQWtELGtFQUFrRSxzREFBc0Q7QUFDdFI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0RUFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNDQUFzQztBQUNsRTtBQUNBO0FBQ0Esa0RBQWtELGVBQWU7QUFDakU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrQ0FBUTtBQUN4QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywrQ0FBUTtBQUNwRDtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwrQkFBK0I7QUFDaEYsaURBQWlELFNBQVM7QUFDMUQsdUJBQXVCLCtDQUFRLEdBQUcsMEJBQTBCO0FBQzVEO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmFja2VuZC8uL25vZGVfbW9kdWxlcy9AcHJpc21hL2FkYXB0ZXItcGcvZGlzdC9pbmRleC5tanM/YTkxYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcGcudHNcbmltcG9ydCB7IERlYnVnLCBEcml2ZXJBZGFwdGVyRXJyb3IgfSBmcm9tIFwiQHByaXNtYS9kcml2ZXItYWRhcHRlci11dGlsc1wiO1xuaW1wb3J0IHBnMiBmcm9tIFwicGdcIjtcblxuLy8gcGFja2FnZS5qc29uXG52YXIgbmFtZSA9IFwiQHByaXNtYS9hZGFwdGVyLXBnXCI7XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBGSVJTVF9OT1JNQUxfT0JKRUNUX0lEID0gMTYzODQ7XG5cbi8vIHNyYy9jb252ZXJzaW9uLnRzXG5pbXBvcnQgeyBDb2x1bW5UeXBlRW51bSB9IGZyb20gXCJAcHJpc21hL2RyaXZlci1hZGFwdGVyLXV0aWxzXCI7XG5pbXBvcnQgcGcgZnJvbSBcInBnXCI7XG5pbXBvcnQgeyBwYXJzZSBhcyBwYXJzZUFycmF5IH0gZnJvbSBcInBvc3RncmVzLWFycmF5XCI7XG52YXIgeyB0eXBlcyB9ID0gcGc7XG52YXIgeyBidWlsdGluczogU2NhbGFyQ29sdW1uVHlwZSwgZ2V0VHlwZVBhcnNlciB9ID0gdHlwZXM7XG52YXIgQWRkaXRpb25hbFNjYWxhckNvbHVtblR5cGUgPSB7XG4gIE5BTUU6IDE5XG59O1xudmFyIEFycmF5Q29sdW1uVHlwZSA9IHtcbiAgQklUX0FSUkFZOiAxNTYxLFxuICBCT09MX0FSUkFZOiAxZTMsXG4gIEJZVEVBX0FSUkFZOiAxMDAxLFxuICBCUENIQVJfQVJSQVk6IDEwMTQsXG4gIENIQVJfQVJSQVk6IDEwMDIsXG4gIENJRFJfQVJSQVk6IDY1MSxcbiAgREFURV9BUlJBWTogMTE4MixcbiAgRkxPQVQ0X0FSUkFZOiAxMDIxLFxuICBGTE9BVDhfQVJSQVk6IDEwMjIsXG4gIElORVRfQVJSQVk6IDEwNDEsXG4gIElOVDJfQVJSQVk6IDEwMDUsXG4gIElOVDRfQVJSQVk6IDEwMDcsXG4gIElOVDhfQVJSQVk6IDEwMTYsXG4gIEpTT05CX0FSUkFZOiAzODA3LFxuICBKU09OX0FSUkFZOiAxOTksXG4gIE1PTkVZX0FSUkFZOiA3OTEsXG4gIE5VTUVSSUNfQVJSQVk6IDEyMzEsXG4gIE9JRF9BUlJBWTogMTAyOCxcbiAgVEVYVF9BUlJBWTogMTAwOSxcbiAgVElNRVNUQU1QX0FSUkFZOiAxMTE1LFxuICBUSU1FU1RBTVBUWl9BUlJBWTogMTE4NSxcbiAgVElNRV9BUlJBWTogMTE4MyxcbiAgVVVJRF9BUlJBWTogMjk1MSxcbiAgVkFSQklUX0FSUkFZOiAxNTYzLFxuICBWQVJDSEFSX0FSUkFZOiAxMDE1LFxuICBYTUxfQVJSQVk6IDE0M1xufTtcbnZhciBVbnN1cHBvcnRlZE5hdGl2ZURhdGFUeXBlID0gY2xhc3MgX1Vuc3VwcG9ydGVkTmF0aXZlRGF0YVR5cGUgZXh0ZW5kcyBFcnJvciB7XG4gIC8vIG1hcCBvZiB0eXBlIGNvZGVzIHRvIHR5cGUgbmFtZXNcbiAgc3RhdGljIHR5cGVOYW1lcyA9IHtcbiAgICAxNjogXCJib29sXCIsXG4gICAgMTc6IFwiYnl0ZWFcIixcbiAgICAxODogXCJjaGFyXCIsXG4gICAgMTk6IFwibmFtZVwiLFxuICAgIDIwOiBcImludDhcIixcbiAgICAyMTogXCJpbnQyXCIsXG4gICAgMjI6IFwiaW50MnZlY3RvclwiLFxuICAgIDIzOiBcImludDRcIixcbiAgICAyNDogXCJyZWdwcm9jXCIsXG4gICAgMjU6IFwidGV4dFwiLFxuICAgIDI2OiBcIm9pZFwiLFxuICAgIDI3OiBcInRpZFwiLFxuICAgIDI4OiBcInhpZFwiLFxuICAgIDI5OiBcImNpZFwiLFxuICAgIDMwOiBcIm9pZHZlY3RvclwiLFxuICAgIDMyOiBcInBnX2RkbF9jb21tYW5kXCIsXG4gICAgNzE6IFwicGdfdHlwZVwiLFxuICAgIDc1OiBcInBnX2F0dHJpYnV0ZVwiLFxuICAgIDgxOiBcInBnX3Byb2NcIixcbiAgICA4MzogXCJwZ19jbGFzc1wiLFxuICAgIDExNDogXCJqc29uXCIsXG4gICAgMTQyOiBcInhtbFwiLFxuICAgIDE5NDogXCJwZ19ub2RlX3RyZWVcIixcbiAgICAyNjk6IFwidGFibGVfYW1faGFuZGxlclwiLFxuICAgIDMyNTogXCJpbmRleF9hbV9oYW5kbGVyXCIsXG4gICAgNjAwOiBcInBvaW50XCIsXG4gICAgNjAxOiBcImxzZWdcIixcbiAgICA2MDI6IFwicGF0aFwiLFxuICAgIDYwMzogXCJib3hcIixcbiAgICA2MDQ6IFwicG9seWdvblwiLFxuICAgIDYyODogXCJsaW5lXCIsXG4gICAgNjUwOiBcImNpZHJcIixcbiAgICA3MDA6IFwiZmxvYXQ0XCIsXG4gICAgNzAxOiBcImZsb2F0OFwiLFxuICAgIDcwNTogXCJ1bmtub3duXCIsXG4gICAgNzE4OiBcImNpcmNsZVwiLFxuICAgIDc3NDogXCJtYWNhZGRyOFwiLFxuICAgIDc5MDogXCJtb25leVwiLFxuICAgIDgyOTogXCJtYWNhZGRyXCIsXG4gICAgODY5OiBcImluZXRcIixcbiAgICAxMDMzOiBcImFjbGl0ZW1cIixcbiAgICAxMDQyOiBcImJwY2hhclwiLFxuICAgIDEwNDM6IFwidmFyY2hhclwiLFxuICAgIDEwODI6IFwiZGF0ZVwiLFxuICAgIDEwODM6IFwidGltZVwiLFxuICAgIDExMTQ6IFwidGltZXN0YW1wXCIsXG4gICAgMTE4NDogXCJ0aW1lc3RhbXB0elwiLFxuICAgIDExODY6IFwiaW50ZXJ2YWxcIixcbiAgICAxMjY2OiBcInRpbWV0elwiLFxuICAgIDE1NjA6IFwiYml0XCIsXG4gICAgMTU2MjogXCJ2YXJiaXRcIixcbiAgICAxNzAwOiBcIm51bWVyaWNcIixcbiAgICAxNzkwOiBcInJlZmN1cnNvclwiLFxuICAgIDIyMDI6IFwicmVncHJvY2VkdXJlXCIsXG4gICAgMjIwMzogXCJyZWdvcGVyXCIsXG4gICAgMjIwNDogXCJyZWdvcGVyYXRvclwiLFxuICAgIDIyMDU6IFwicmVnY2xhc3NcIixcbiAgICAyMjA2OiBcInJlZ3R5cGVcIixcbiAgICAyMjQ5OiBcInJlY29yZFwiLFxuICAgIDIyNzU6IFwiY3N0cmluZ1wiLFxuICAgIDIyNzY6IFwiYW55XCIsXG4gICAgMjI3NzogXCJhbnlhcnJheVwiLFxuICAgIDIyNzg6IFwidm9pZFwiLFxuICAgIDIyNzk6IFwidHJpZ2dlclwiLFxuICAgIDIyODA6IFwibGFuZ3VhZ2VfaGFuZGxlclwiLFxuICAgIDIyODE6IFwiaW50ZXJuYWxcIixcbiAgICAyMjgzOiBcImFueWVsZW1lbnRcIixcbiAgICAyMjg3OiBcIl9yZWNvcmRcIixcbiAgICAyNzc2OiBcImFueW5vbmFycmF5XCIsXG4gICAgMjk1MDogXCJ1dWlkXCIsXG4gICAgMjk3MDogXCJ0eGlkX3NuYXBzaG90XCIsXG4gICAgMzExNTogXCJmZHdfaGFuZGxlclwiLFxuICAgIDMyMjA6IFwicGdfbHNuXCIsXG4gICAgMzMxMDogXCJ0c21faGFuZGxlclwiLFxuICAgIDMzNjE6IFwicGdfbmRpc3RpbmN0XCIsXG4gICAgMzQwMjogXCJwZ19kZXBlbmRlbmNpZXNcIixcbiAgICAzNTAwOiBcImFueWVudW1cIixcbiAgICAzNjE0OiBcInRzdmVjdG9yXCIsXG4gICAgMzYxNTogXCJ0c3F1ZXJ5XCIsXG4gICAgMzY0MjogXCJndHN2ZWN0b3JcIixcbiAgICAzNzM0OiBcInJlZ2NvbmZpZ1wiLFxuICAgIDM3Njk6IFwicmVnZGljdGlvbmFyeVwiLFxuICAgIDM4MDI6IFwianNvbmJcIixcbiAgICAzODMxOiBcImFueXJhbmdlXCIsXG4gICAgMzgzODogXCJldmVudF90cmlnZ2VyXCIsXG4gICAgMzkwNDogXCJpbnQ0cmFuZ2VcIixcbiAgICAzOTA2OiBcIm51bXJhbmdlXCIsXG4gICAgMzkwODogXCJ0c3JhbmdlXCIsXG4gICAgMzkxMDogXCJ0c3R6cmFuZ2VcIixcbiAgICAzOTEyOiBcImRhdGVyYW5nZVwiLFxuICAgIDM5MjY6IFwiaW50OHJhbmdlXCIsXG4gICAgNDA3MjogXCJqc29ucGF0aFwiLFxuICAgIDQwODk6IFwicmVnbmFtZXNwYWNlXCIsXG4gICAgNDA5NjogXCJyZWdyb2xlXCIsXG4gICAgNDE5MTogXCJyZWdjb2xsYXRpb25cIixcbiAgICA0NDUxOiBcImludDRtdWx0aXJhbmdlXCIsXG4gICAgNDUzMjogXCJudW1tdWx0aXJhbmdlXCIsXG4gICAgNDUzMzogXCJ0c211bHRpcmFuZ2VcIixcbiAgICA0NTM0OiBcInRzdHptdWx0aXJhbmdlXCIsXG4gICAgNDUzNTogXCJkYXRlbXVsdGlyYW5nZVwiLFxuICAgIDQ1MzY6IFwiaW50OG11bHRpcmFuZ2VcIixcbiAgICA0NTM3OiBcImFueW11bHRpcmFuZ2VcIixcbiAgICA0NTM4OiBcImFueWNvbXBhdGlibGVtdWx0aXJhbmdlXCIsXG4gICAgNDYwMDogXCJwZ19icmluX2Jsb29tX3N1bW1hcnlcIixcbiAgICA0NjAxOiBcInBnX2JyaW5fbWlubWF4X211bHRpX3N1bW1hcnlcIixcbiAgICA1MDE3OiBcInBnX21jdl9saXN0XCIsXG4gICAgNTAzODogXCJwZ19zbmFwc2hvdFwiLFxuICAgIDUwNjk6IFwieGlkOFwiLFxuICAgIDUwNzc6IFwiYW55Y29tcGF0aWJsZVwiLFxuICAgIDUwNzg6IFwiYW55Y29tcGF0aWJsZWFycmF5XCIsXG4gICAgNTA3OTogXCJhbnljb21wYXRpYmxlbm9uYXJyYXlcIixcbiAgICA1MDgwOiBcImFueWNvbXBhdGlibGVyYW5nZVwiXG4gIH07XG4gIHR5cGU7XG4gIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudHlwZSA9IF9VbnN1cHBvcnRlZE5hdGl2ZURhdGFUeXBlLnR5cGVOYW1lc1tjb2RlXSB8fCBcIlVua25vd25cIjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBgVW5zdXBwb3J0ZWQgY29sdW1uIHR5cGUgJHt0aGlzLnR5cGV9YDtcbiAgfVxufTtcbmZ1bmN0aW9uIGZpZWxkVG9Db2x1bW5UeXBlKGZpZWxkVHlwZUlkKSB7XG4gIHN3aXRjaCAoZmllbGRUeXBlSWQpIHtcbiAgICBjYXNlIFNjYWxhckNvbHVtblR5cGUuSU5UMjpcbiAgICBjYXNlIFNjYWxhckNvbHVtblR5cGUuSU5UNDpcbiAgICAgIHJldHVybiBDb2x1bW5UeXBlRW51bS5JbnQzMjtcbiAgICBjYXNlIFNjYWxhckNvbHVtblR5cGUuSU5UODpcbiAgICAgIHJldHVybiBDb2x1bW5UeXBlRW51bS5JbnQ2NDtcbiAgICBjYXNlIFNjYWxhckNvbHVtblR5cGUuRkxPQVQ0OlxuICAgICAgcmV0dXJuIENvbHVtblR5cGVFbnVtLkZsb2F0O1xuICAgIGNhc2UgU2NhbGFyQ29sdW1uVHlwZS5GTE9BVDg6XG4gICAgICByZXR1cm4gQ29sdW1uVHlwZUVudW0uRG91YmxlO1xuICAgIGNhc2UgU2NhbGFyQ29sdW1uVHlwZS5CT09MOlxuICAgICAgcmV0dXJuIENvbHVtblR5cGVFbnVtLkJvb2xlYW47XG4gICAgY2FzZSBTY2FsYXJDb2x1bW5UeXBlLkRBVEU6XG4gICAgICByZXR1cm4gQ29sdW1uVHlwZUVudW0uRGF0ZTtcbiAgICBjYXNlIFNjYWxhckNvbHVtblR5cGUuVElNRTpcbiAgICBjYXNlIFNjYWxhckNvbHVtblR5cGUuVElNRVRaOlxuICAgICAgcmV0dXJuIENvbHVtblR5cGVFbnVtLlRpbWU7XG4gICAgY2FzZSBTY2FsYXJDb2x1bW5UeXBlLlRJTUVTVEFNUDpcbiAgICBjYXNlIFNjYWxhckNvbHVtblR5cGUuVElNRVNUQU1QVFo6XG4gICAgICByZXR1cm4gQ29sdW1uVHlwZUVudW0uRGF0ZVRpbWU7XG4gICAgY2FzZSBTY2FsYXJDb2x1bW5UeXBlLk5VTUVSSUM6XG4gICAgY2FzZSBTY2FsYXJDb2x1bW5UeXBlLk1PTkVZOlxuICAgICAgcmV0dXJuIENvbHVtblR5cGVFbnVtLk51bWVyaWM7XG4gICAgY2FzZSBTY2FsYXJDb2x1bW5UeXBlLkpTT046XG4gICAgY2FzZSBTY2FsYXJDb2x1bW5UeXBlLkpTT05COlxuICAgICAgcmV0dXJuIENvbHVtblR5cGVFbnVtLkpzb247XG4gICAgY2FzZSBTY2FsYXJDb2x1bW5UeXBlLlVVSUQ6XG4gICAgICByZXR1cm4gQ29sdW1uVHlwZUVudW0uVXVpZDtcbiAgICBjYXNlIFNjYWxhckNvbHVtblR5cGUuT0lEOlxuICAgICAgcmV0dXJuIENvbHVtblR5cGVFbnVtLkludDY0O1xuICAgIGNhc2UgU2NhbGFyQ29sdW1uVHlwZS5CUENIQVI6XG4gICAgY2FzZSBTY2FsYXJDb2x1bW5UeXBlLlRFWFQ6XG4gICAgY2FzZSBTY2FsYXJDb2x1bW5UeXBlLlZBUkNIQVI6XG4gICAgY2FzZSBTY2FsYXJDb2x1bW5UeXBlLkJJVDpcbiAgICBjYXNlIFNjYWxhckNvbHVtblR5cGUuVkFSQklUOlxuICAgIGNhc2UgU2NhbGFyQ29sdW1uVHlwZS5JTkVUOlxuICAgIGNhc2UgU2NhbGFyQ29sdW1uVHlwZS5DSURSOlxuICAgIGNhc2UgU2NhbGFyQ29sdW1uVHlwZS5YTUw6XG4gICAgY2FzZSBBZGRpdGlvbmFsU2NhbGFyQ29sdW1uVHlwZS5OQU1FOlxuICAgICAgcmV0dXJuIENvbHVtblR5cGVFbnVtLlRleHQ7XG4gICAgY2FzZSBTY2FsYXJDb2x1bW5UeXBlLkJZVEVBOlxuICAgICAgcmV0dXJuIENvbHVtblR5cGVFbnVtLkJ5dGVzO1xuICAgIGNhc2UgQXJyYXlDb2x1bW5UeXBlLklOVDJfQVJSQVk6XG4gICAgY2FzZSBBcnJheUNvbHVtblR5cGUuSU5UNF9BUlJBWTpcbiAgICAgIHJldHVybiBDb2x1bW5UeXBlRW51bS5JbnQzMkFycmF5O1xuICAgIGNhc2UgQXJyYXlDb2x1bW5UeXBlLkZMT0FUNF9BUlJBWTpcbiAgICAgIHJldHVybiBDb2x1bW5UeXBlRW51bS5GbG9hdEFycmF5O1xuICAgIGNhc2UgQXJyYXlDb2x1bW5UeXBlLkZMT0FUOF9BUlJBWTpcbiAgICAgIHJldHVybiBDb2x1bW5UeXBlRW51bS5Eb3VibGVBcnJheTtcbiAgICBjYXNlIEFycmF5Q29sdW1uVHlwZS5OVU1FUklDX0FSUkFZOlxuICAgIGNhc2UgQXJyYXlDb2x1bW5UeXBlLk1PTkVZX0FSUkFZOlxuICAgICAgcmV0dXJuIENvbHVtblR5cGVFbnVtLk51bWVyaWNBcnJheTtcbiAgICBjYXNlIEFycmF5Q29sdW1uVHlwZS5CT09MX0FSUkFZOlxuICAgICAgcmV0dXJuIENvbHVtblR5cGVFbnVtLkJvb2xlYW5BcnJheTtcbiAgICBjYXNlIEFycmF5Q29sdW1uVHlwZS5DSEFSX0FSUkFZOlxuICAgICAgcmV0dXJuIENvbHVtblR5cGVFbnVtLkNoYXJhY3RlckFycmF5O1xuICAgIGNhc2UgQXJyYXlDb2x1bW5UeXBlLkJQQ0hBUl9BUlJBWTpcbiAgICBjYXNlIEFycmF5Q29sdW1uVHlwZS5URVhUX0FSUkFZOlxuICAgIGNhc2UgQXJyYXlDb2x1bW5UeXBlLlZBUkNIQVJfQVJSQVk6XG4gICAgY2FzZSBBcnJheUNvbHVtblR5cGUuVkFSQklUX0FSUkFZOlxuICAgIGNhc2UgQXJyYXlDb2x1bW5UeXBlLkJJVF9BUlJBWTpcbiAgICBjYXNlIEFycmF5Q29sdW1uVHlwZS5JTkVUX0FSUkFZOlxuICAgIGNhc2UgQXJyYXlDb2x1bW5UeXBlLkNJRFJfQVJSQVk6XG4gICAgY2FzZSBBcnJheUNvbHVtblR5cGUuWE1MX0FSUkFZOlxuICAgICAgcmV0dXJuIENvbHVtblR5cGVFbnVtLlRleHRBcnJheTtcbiAgICBjYXNlIEFycmF5Q29sdW1uVHlwZS5EQVRFX0FSUkFZOlxuICAgICAgcmV0dXJuIENvbHVtblR5cGVFbnVtLkRhdGVBcnJheTtcbiAgICBjYXNlIEFycmF5Q29sdW1uVHlwZS5USU1FX0FSUkFZOlxuICAgICAgcmV0dXJuIENvbHVtblR5cGVFbnVtLlRpbWVBcnJheTtcbiAgICBjYXNlIEFycmF5Q29sdW1uVHlwZS5USU1FU1RBTVBfQVJSQVk6XG4gICAgICByZXR1cm4gQ29sdW1uVHlwZUVudW0uRGF0ZVRpbWVBcnJheTtcbiAgICBjYXNlIEFycmF5Q29sdW1uVHlwZS5USU1FU1RBTVBUWl9BUlJBWTpcbiAgICAgIHJldHVybiBDb2x1bW5UeXBlRW51bS5EYXRlVGltZUFycmF5O1xuICAgIGNhc2UgQXJyYXlDb2x1bW5UeXBlLkpTT05fQVJSQVk6XG4gICAgY2FzZSBBcnJheUNvbHVtblR5cGUuSlNPTkJfQVJSQVk6XG4gICAgICByZXR1cm4gQ29sdW1uVHlwZUVudW0uSnNvbkFycmF5O1xuICAgIGNhc2UgQXJyYXlDb2x1bW5UeXBlLkJZVEVBX0FSUkFZOlxuICAgICAgcmV0dXJuIENvbHVtblR5cGVFbnVtLkJ5dGVzQXJyYXk7XG4gICAgY2FzZSBBcnJheUNvbHVtblR5cGUuVVVJRF9BUlJBWTpcbiAgICAgIHJldHVybiBDb2x1bW5UeXBlRW51bS5VdWlkQXJyYXk7XG4gICAgY2FzZSBBcnJheUNvbHVtblR5cGUuSU5UOF9BUlJBWTpcbiAgICBjYXNlIEFycmF5Q29sdW1uVHlwZS5PSURfQVJSQVk6XG4gICAgICByZXR1cm4gQ29sdW1uVHlwZUVudW0uSW50NjRBcnJheTtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGZpZWxkVHlwZUlkID49IEZJUlNUX05PUk1BTF9PQkpFQ1RfSUQpIHtcbiAgICAgICAgcmV0dXJuIENvbHVtblR5cGVFbnVtLlRleHQ7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWROYXRpdmVEYXRhVHlwZShmaWVsZFR5cGVJZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZV9hcnJheShlbGVtZW50X25vcm1hbGl6ZXIpIHtcbiAgcmV0dXJuIChzdHIpID0+IHBhcnNlQXJyYXkoc3RyLCBlbGVtZW50X25vcm1hbGl6ZXIpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplX251bWVyaWMobnVtZXJpYykge1xuICByZXR1cm4gbnVtZXJpYztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZV9kYXRlKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGU7XG59XG5mdW5jdGlvbiBub3JtYWxpemVfdGltZXN0YW1wKHRpbWUpIHtcbiAgcmV0dXJuIGAke3RpbWUucmVwbGFjZShcIiBcIiwgXCJUXCIpfSswMDowMGA7XG59XG5mdW5jdGlvbiBub3JtYWxpemVfdGltZXN0YW1wdHoodGltZSkge1xuICByZXR1cm4gdGltZS5yZXBsYWNlKFwiIFwiLCBcIlRcIikucmVwbGFjZSgvWystXVxcZHsyfSg6XFxkezJ9KT8kLywgXCIrMDA6MDBcIik7XG59XG5mdW5jdGlvbiBub3JtYWxpemVfdGltZSh0aW1lKSB7XG4gIHJldHVybiB0aW1lO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplX3RpbWV6KHRpbWUpIHtcbiAgcmV0dXJuIHRpbWUucmVwbGFjZSgvWystXVxcZHsyfSg6XFxkezJ9KT8kLywgXCJcIik7XG59XG5mdW5jdGlvbiBub3JtYWxpemVfbW9uZXkobW9uZXkpIHtcbiAgcmV0dXJuIG1vbmV5LnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplX3htbCh4bWwpIHtcbiAgcmV0dXJuIHhtbDtcbn1cbmZ1bmN0aW9uIHRvSnNvbihqc29uKSB7XG4gIHJldHVybiBqc29uO1xufVxuZnVuY3Rpb24gZW5jb2RlQnVmZmVyKGJ1ZmZlcikge1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShidWZmZXIpKTtcbn1cbnZhciBwYXJzZVBnQnl0ZXMgPSBnZXRUeXBlUGFyc2VyKFNjYWxhckNvbHVtblR5cGUuQllURUEpO1xudmFyIHBhcnNlQnl0ZXNBcnJheSA9IGdldFR5cGVQYXJzZXIoQXJyYXlDb2x1bW5UeXBlLkJZVEVBX0FSUkFZKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUJ5dGVhQXJyYXkoc2VyaWFsaXplZEJ5dGVzQXJyYXkpIHtcbiAgY29uc3QgYnVmZmVycyA9IHBhcnNlQnl0ZXNBcnJheShzZXJpYWxpemVkQnl0ZXNBcnJheSk7XG4gIHJldHVybiBidWZmZXJzLm1hcCgoYnVmKSA9PiBidWYgPyBlbmNvZGVCdWZmZXIoYnVmKSA6IG51bGwpO1xufVxuZnVuY3Rpb24gY29udmVydEJ5dGVzKHNlcmlhbGl6ZWRCeXRlcykge1xuICBjb25zdCBidWZmZXIgPSBwYXJzZVBnQnl0ZXMoc2VyaWFsaXplZEJ5dGVzKTtcbiAgcmV0dXJuIGVuY29kZUJ1ZmZlcihidWZmZXIpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQml0KGJpdCkge1xuICByZXR1cm4gYml0O1xufVxudmFyIGN1c3RvbVBhcnNlcnMgPSB7XG4gIFtTY2FsYXJDb2x1bW5UeXBlLk5VTUVSSUNdOiBub3JtYWxpemVfbnVtZXJpYyxcbiAgW0FycmF5Q29sdW1uVHlwZS5OVU1FUklDX0FSUkFZXTogbm9ybWFsaXplX2FycmF5KG5vcm1hbGl6ZV9udW1lcmljKSxcbiAgW1NjYWxhckNvbHVtblR5cGUuVElNRV06IG5vcm1hbGl6ZV90aW1lLFxuICBbQXJyYXlDb2x1bW5UeXBlLlRJTUVfQVJSQVldOiBub3JtYWxpemVfYXJyYXkobm9ybWFsaXplX3RpbWUpLFxuICBbU2NhbGFyQ29sdW1uVHlwZS5USU1FVFpdOiBub3JtYWxpemVfdGltZXosXG4gIFtTY2FsYXJDb2x1bW5UeXBlLkRBVEVdOiBub3JtYWxpemVfZGF0ZSxcbiAgW0FycmF5Q29sdW1uVHlwZS5EQVRFX0FSUkFZXTogbm9ybWFsaXplX2FycmF5KG5vcm1hbGl6ZV9kYXRlKSxcbiAgW1NjYWxhckNvbHVtblR5cGUuVElNRVNUQU1QXTogbm9ybWFsaXplX3RpbWVzdGFtcCxcbiAgW0FycmF5Q29sdW1uVHlwZS5USU1FU1RBTVBfQVJSQVldOiBub3JtYWxpemVfYXJyYXkobm9ybWFsaXplX3RpbWVzdGFtcCksXG4gIFtTY2FsYXJDb2x1bW5UeXBlLlRJTUVTVEFNUFRaXTogbm9ybWFsaXplX3RpbWVzdGFtcHR6LFxuICBbQXJyYXlDb2x1bW5UeXBlLlRJTUVTVEFNUFRaX0FSUkFZXTogbm9ybWFsaXplX2FycmF5KG5vcm1hbGl6ZV90aW1lc3RhbXB0eiksXG4gIFtTY2FsYXJDb2x1bW5UeXBlLk1PTkVZXTogbm9ybWFsaXplX21vbmV5LFxuICBbQXJyYXlDb2x1bW5UeXBlLk1PTkVZX0FSUkFZXTogbm9ybWFsaXplX2FycmF5KG5vcm1hbGl6ZV9tb25leSksXG4gIFtTY2FsYXJDb2x1bW5UeXBlLkpTT05dOiB0b0pzb24sXG4gIFtBcnJheUNvbHVtblR5cGUuSlNPTl9BUlJBWV06IG5vcm1hbGl6ZV9hcnJheSh0b0pzb24pLFxuICBbU2NhbGFyQ29sdW1uVHlwZS5KU09OQl06IHRvSnNvbixcbiAgW0FycmF5Q29sdW1uVHlwZS5KU09OQl9BUlJBWV06IG5vcm1hbGl6ZV9hcnJheSh0b0pzb24pLFxuICBbU2NhbGFyQ29sdW1uVHlwZS5CWVRFQV06IGNvbnZlcnRCeXRlcyxcbiAgW0FycmF5Q29sdW1uVHlwZS5CWVRFQV9BUlJBWV06IG5vcm1hbGl6ZUJ5dGVhQXJyYXksXG4gIFtBcnJheUNvbHVtblR5cGUuQklUX0FSUkFZXTogbm9ybWFsaXplX2FycmF5KG5vcm1hbGl6ZUJpdCksXG4gIFtBcnJheUNvbHVtblR5cGUuVkFSQklUX0FSUkFZXTogbm9ybWFsaXplX2FycmF5KG5vcm1hbGl6ZUJpdCksXG4gIFtBcnJheUNvbHVtblR5cGUuWE1MX0FSUkFZXTogbm9ybWFsaXplX2FycmF5KG5vcm1hbGl6ZV94bWwpXG59O1xuZnVuY3Rpb24gbWFwQXJnKGFyZywgYXJnVHlwZSkge1xuICBpZiAoYXJnID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSAmJiBhcmdUeXBlLmFyaXR5ID09PSBcImxpc3RcIikge1xuICAgIHJldHVybiBhcmcubWFwKCh2YWx1ZSkgPT4gbWFwQXJnKHZhbHVlLCBhcmdUeXBlKSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIgJiYgYXJnVHlwZS5zY2FsYXJUeXBlID09PSBcImRhdGV0aW1lXCIpIHtcbiAgICBhcmcgPSBuZXcgRGF0ZShhcmcpO1xuICB9XG4gIGlmIChhcmcgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgc3dpdGNoIChhcmdUeXBlLmRiVHlwZSkge1xuICAgICAgY2FzZSBcIlRJTUVcIjpcbiAgICAgIGNhc2UgXCJUSU1FVFpcIjpcbiAgICAgICAgcmV0dXJuIGZvcm1hdFRpbWUoYXJnKTtcbiAgICAgIGNhc2UgXCJEQVRFXCI6XG4gICAgICAgIHJldHVybiBmb3JtYXREYXRlKGFyZyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZm9ybWF0RGF0ZVRpbWUoYXJnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIgJiYgYXJnVHlwZS5zY2FsYXJUeXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJnLCBcImJhc2U2NFwiKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZ1R5cGUuc2NhbGFyVHlwZSA9PT0gXCJieXRlc1wiKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFyZyk7XG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhhcmcpKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFyZy5idWZmZXIsIGFyZy5ieXRlT2Zmc2V0LCBhcmcuYnl0ZUxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGFyZztcbn1cbmZ1bmN0aW9uIGZvcm1hdERhdGVUaW1lKGRhdGUpIHtcbiAgY29uc3QgcGFkID0gKG4sIHogPSAyKSA9PiBTdHJpbmcobikucGFkU3RhcnQoeiwgXCIwXCIpO1xuICBjb25zdCBtcyA9IGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHJldHVybiBwYWQoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCA0KSArIFwiLVwiICsgcGFkKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpICsgXCItXCIgKyBwYWQoZGF0ZS5nZXRVVENEYXRlKCkpICsgXCIgXCIgKyBwYWQoZGF0ZS5nZXRVVENIb3VycygpKSArIFwiOlwiICsgcGFkKGRhdGUuZ2V0VVRDTWludXRlcygpKSArIFwiOlwiICsgcGFkKGRhdGUuZ2V0VVRDU2Vjb25kcygpKSArIChtcyA/IFwiLlwiICsgU3RyaW5nKG1zKS5wYWRTdGFydCgzLCBcIjBcIikgOiBcIlwiKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICBjb25zdCBwYWQgPSAobiwgeiA9IDIpID0+IFN0cmluZyhuKS5wYWRTdGFydCh6LCBcIjBcIik7XG4gIHJldHVybiBwYWQoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCA0KSArIFwiLVwiICsgcGFkKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpICsgXCItXCIgKyBwYWQoZGF0ZS5nZXRVVENEYXRlKCkpO1xufVxuZnVuY3Rpb24gZm9ybWF0VGltZShkYXRlKSB7XG4gIGNvbnN0IHBhZCA9IChuLCB6ID0gMikgPT4gU3RyaW5nKG4pLnBhZFN0YXJ0KHosIFwiMFwiKTtcbiAgY29uc3QgbXMgPSBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICByZXR1cm4gcGFkKGRhdGUuZ2V0VVRDSG91cnMoKSkgKyBcIjpcIiArIHBhZChkYXRlLmdldFVUQ01pbnV0ZXMoKSkgKyBcIjpcIiArIHBhZChkYXRlLmdldFVUQ1NlY29uZHMoKSkgKyAobXMgPyBcIi5cIiArIFN0cmluZyhtcykucGFkU3RhcnQoMywgXCIwXCIpIDogXCJcIik7XG59XG5cbi8vIHNyYy9lcnJvcnMudHNcbnZhciBUTFNfRVJST1JTID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcIlVOQUJMRV9UT19HRVRfSVNTVUVSX0NFUlRcIixcbiAgXCJVTkFCTEVfVE9fR0VUX0NSTFwiLFxuICBcIlVOQUJMRV9UT19ERUNSWVBUX0NFUlRfU0lHTkFUVVJFXCIsXG4gIFwiVU5BQkxFX1RPX0RFQ1JZUFRfQ1JMX1NJR05BVFVSRVwiLFxuICBcIlVOQUJMRV9UT19ERUNPREVfSVNTVUVSX1BVQkxJQ19LRVlcIixcbiAgXCJDRVJUX1NJR05BVFVSRV9GQUlMVVJFXCIsXG4gIFwiQ1JMX1NJR05BVFVSRV9GQUlMVVJFXCIsXG4gIFwiQ0VSVF9OT1RfWUVUX1ZBTElEXCIsXG4gIFwiQ0VSVF9IQVNfRVhQSVJFRFwiLFxuICBcIkNSTF9OT1RfWUVUX1ZBTElEXCIsXG4gIFwiQ1JMX0hBU19FWFBJUkVEXCIsXG4gIFwiRVJST1JfSU5fQ0VSVF9OT1RfQkVGT1JFX0ZJRUxEXCIsXG4gIFwiRVJST1JfSU5fQ0VSVF9OT1RfQUZURVJfRklFTERcIixcbiAgXCJFUlJPUl9JTl9DUkxfTEFTVF9VUERBVEVfRklFTERcIixcbiAgXCJFUlJPUl9JTl9DUkxfTkVYVF9VUERBVEVfRklFTERcIixcbiAgXCJERVBUSF9aRVJPX1NFTEZfU0lHTkVEX0NFUlRcIixcbiAgXCJTRUxGX1NJR05FRF9DRVJUX0lOX0NIQUlOXCIsXG4gIFwiVU5BQkxFX1RPX0dFVF9JU1NVRVJfQ0VSVF9MT0NBTExZXCIsXG4gIFwiVU5BQkxFX1RPX1ZFUklGWV9MRUFGX1NJR05BVFVSRVwiLFxuICBcIkNFUlRfQ0hBSU5fVE9PX0xPTkdcIixcbiAgXCJDRVJUX1JFVk9LRURcIixcbiAgXCJJTlZBTElEX0NBXCIsXG4gIFwiSU5WQUxJRF9QVVJQT1NFXCIsXG4gIFwiQ0VSVF9VTlRSVVNURURcIixcbiAgXCJDRVJUX1JFSkVDVEVEXCIsXG4gIFwiSE9TVE5BTUVfTUlTTUFUQ0hcIixcbiAgXCJFUlJfVExTX0NFUlRfQUxUTkFNRV9GT1JNQVRcIixcbiAgXCJFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEXCJcbl0pO1xudmFyIFNPQ0tFVF9FUlJPUlMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJFTk9URk9VTkRcIiwgXCJFQ09OTlJFRlVTRURcIiwgXCJFQ09OTlJFU0VUXCIsIFwiRVRJTUVET1VUXCJdKTtcbmZ1bmN0aW9uIGNvbnZlcnREcml2ZXJFcnJvcihlcnJvcikge1xuICBpZiAoaXNTb2NrZXRFcnJvcihlcnJvcikpIHtcbiAgICByZXR1cm4gbWFwU29ja2V0RXJyb3IoZXJyb3IpO1xuICB9XG4gIGlmIChpc1Rsc0Vycm9yKGVycm9yKSkge1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBcIlRsc0Nvbm5lY3Rpb25FcnJvclwiLFxuICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlXG4gICAgfTtcbiAgfVxuICBpZiAoaXNEcml2ZXJFcnJvcihlcnJvcikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3JpZ2luYWxDb2RlOiBlcnJvci5jb2RlLFxuICAgICAgb3JpZ2luYWxNZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgLi4ubWFwRHJpdmVyRXJyb3IoZXJyb3IpXG4gICAgfTtcbiAgfVxuICB0aHJvdyBlcnJvcjtcbn1cbmZ1bmN0aW9uIG1hcERyaXZlckVycm9yKGVycm9yKSB7XG4gIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgIGNhc2UgXCIyMjAwMVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJMZW5ndGhNaXNtYXRjaFwiLFxuICAgICAgICBjb2x1bW46IGVycm9yLmNvbHVtblxuICAgICAgfTtcbiAgICBjYXNlIFwiMjIwMDNcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IFwiVmFsdWVPdXRPZlJhbmdlXCIsXG4gICAgICAgIGNhdXNlOiBlcnJvci5tZXNzYWdlXG4gICAgICB9O1xuICAgIGNhc2UgXCIyMzUwNVwiOiB7XG4gICAgICBjb25zdCBmaWVsZHMgPSBlcnJvci5kZXRhaWw/Lm1hdGNoKC9LZXkgXFwoKFteKV0rKVxcKS8pPy5hdCgxKT8uc3BsaXQoXCIsIFwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IFwiVW5pcXVlQ29uc3RyYWludFZpb2xhdGlvblwiLFxuICAgICAgICBjb25zdHJhaW50OiBmaWVsZHMgIT09IHZvaWQgMCA/IHsgZmllbGRzIH0gOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCIyMzUwMlwiOiB7XG4gICAgICBjb25zdCBmaWVsZHMgPSBlcnJvci5kZXRhaWw/Lm1hdGNoKC9LZXkgXFwoKFteKV0rKVxcKS8pPy5hdCgxKT8uc3BsaXQoXCIsIFwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IFwiTnVsbENvbnN0cmFpbnRWaW9sYXRpb25cIixcbiAgICAgICAgY29uc3RyYWludDogZmllbGRzICE9PSB2b2lkIDAgPyB7IGZpZWxkcyB9IDogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiMjM1MDNcIjoge1xuICAgICAgbGV0IGNvbnN0cmFpbnQ7XG4gICAgICBpZiAoZXJyb3IuY29sdW1uKSB7XG4gICAgICAgIGNvbnN0cmFpbnQgPSB7IGZpZWxkczogW2Vycm9yLmNvbHVtbl0gfTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IuY29uc3RyYWludCkge1xuICAgICAgICBjb25zdHJhaW50ID0geyBpbmRleDogZXJyb3IuY29uc3RyYWludCB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJGb3JlaWduS2V5Q29uc3RyYWludFZpb2xhdGlvblwiLFxuICAgICAgICBjb25zdHJhaW50XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiM0QwMDBcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IFwiRGF0YWJhc2VEb2VzTm90RXhpc3RcIixcbiAgICAgICAgZGI6IGVycm9yLm1lc3NhZ2Uuc3BsaXQoXCIgXCIpLmF0KDEpPy5zcGxpdCgnXCInKS5hdCgxKVxuICAgICAgfTtcbiAgICBjYXNlIFwiMjgwMDBcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IFwiRGF0YWJhc2VBY2Nlc3NEZW5pZWRcIixcbiAgICAgICAgZGI6IGVycm9yLm1lc3NhZ2Uuc3BsaXQoXCIsXCIpLmZpbmQoKHMpID0+IHMuc3RhcnRzV2l0aChcIiBkYXRhYmFzZVwiKSk/LnNwbGl0KCdcIicpLmF0KDEpXG4gICAgICB9O1xuICAgIGNhc2UgXCIyOFAwMVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJBdXRoZW50aWNhdGlvbkZhaWxlZFwiLFxuICAgICAgICB1c2VyOiBlcnJvci5tZXNzYWdlLnNwbGl0KFwiIFwiKS5wb3AoKT8uc3BsaXQoJ1wiJykuYXQoMSlcbiAgICAgIH07XG4gICAgY2FzZSBcIjQwMDAxXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBcIlRyYW5zYWN0aW9uV3JpdGVDb25mbGljdFwiXG4gICAgICB9O1xuICAgIGNhc2UgXCI0MlAwMVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJUYWJsZURvZXNOb3RFeGlzdFwiLFxuICAgICAgICB0YWJsZTogZXJyb3IubWVzc2FnZS5zcGxpdChcIiBcIikuYXQoMSk/LnNwbGl0KCdcIicpLmF0KDEpXG4gICAgICB9O1xuICAgIGNhc2UgXCI0MjcwM1wiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJDb2x1bW5Ob3RGb3VuZFwiLFxuICAgICAgICBjb2x1bW46IGVycm9yLm1lc3NhZ2Uuc3BsaXQoXCIgXCIpLmF0KDEpPy5zcGxpdCgnXCInKS5hdCgxKVxuICAgICAgfTtcbiAgICBjYXNlIFwiNDJQMDRcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IFwiRGF0YWJhc2VBbHJlYWR5RXhpc3RzXCIsXG4gICAgICAgIGRiOiBlcnJvci5tZXNzYWdlLnNwbGl0KFwiIFwiKS5hdCgxKT8uc3BsaXQoJ1wiJykuYXQoMSlcbiAgICAgIH07XG4gICAgY2FzZSBcIjUzMzAwXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBcIlRvb01hbnlDb25uZWN0aW9uc1wiLFxuICAgICAgICBjYXVzZTogZXJyb3IubWVzc2FnZVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJwb3N0Z3Jlc1wiLFxuICAgICAgICBjb2RlOiBlcnJvci5jb2RlID8/IFwiTi9BXCIsXG4gICAgICAgIHNldmVyaXR5OiBlcnJvci5zZXZlcml0eSA/PyBcIk4vQVwiLFxuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICBkZXRhaWw6IGVycm9yLmRldGFpbCxcbiAgICAgICAgY29sdW1uOiBlcnJvci5jb2x1bW4sXG4gICAgICAgIGhpbnQ6IGVycm9yLmhpbnRcbiAgICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRHJpdmVyRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBlcnJvci5jb2RlID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci5zZXZlcml0eSA9PT0gXCJzdHJpbmdcIiAmJiAodHlwZW9mIGVycm9yLmRldGFpbCA9PT0gXCJzdHJpbmdcIiB8fCBlcnJvci5kZXRhaWwgPT09IHZvaWQgMCkgJiYgKHR5cGVvZiBlcnJvci5jb2x1bW4gPT09IFwic3RyaW5nXCIgfHwgZXJyb3IuY29sdW1uID09PSB2b2lkIDApICYmICh0eXBlb2YgZXJyb3IuaGludCA9PT0gXCJzdHJpbmdcIiB8fCBlcnJvci5oaW50ID09PSB2b2lkIDApO1xufVxuZnVuY3Rpb24gbWFwU29ja2V0RXJyb3IoZXJyb3IpIHtcbiAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgY2FzZSBcIkVOT1RGT1VORFwiOlxuICAgIGNhc2UgXCJFQ09OTlJFRlVTRURcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IFwiRGF0YWJhc2VOb3RSZWFjaGFibGVcIixcbiAgICAgICAgaG9zdDogZXJyb3IuYWRkcmVzcyA/PyBlcnJvci5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogZXJyb3IucG9ydFxuICAgICAgfTtcbiAgICBjYXNlIFwiRUNPTk5SRVNFVFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJDb25uZWN0aW9uQ2xvc2VkXCJcbiAgICAgIH07XG4gICAgY2FzZSBcIkVUSU1FRE9VVFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJTb2NrZXRUaW1lb3V0XCJcbiAgICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU29ja2V0RXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBlcnJvci5jb2RlID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci5zeXNjYWxsID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci5lcnJubyA9PT0gXCJudW1iZXJcIiAmJiBTT0NLRVRfRVJST1JTLmhhcyhlcnJvci5jb2RlKTtcbn1cbmZ1bmN0aW9uIGlzVGxzRXJyb3IoZXJyb3IpIHtcbiAgaWYgKHR5cGVvZiBlcnJvci5jb2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFRMU19FUlJPUlMuaGFzKGVycm9yLmNvZGUpO1xuICB9XG4gIHN3aXRjaCAoZXJyb3IubWVzc2FnZSkge1xuICAgIGNhc2UgXCJUaGUgc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgU1NMIGNvbm5lY3Rpb25zXCI6XG4gICAgY2FzZSBcIlRoZXJlIHdhcyBhbiBlcnJvciBlc3RhYmxpc2hpbmcgYW4gU1NMIGNvbm5lY3Rpb25cIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc3JjL3BnLnRzXG52YXIgdHlwZXMyID0gcGcyLnR5cGVzO1xudmFyIGRlYnVnID0gRGVidWcoXCJwcmlzbWE6ZHJpdmVyLWFkYXB0ZXI6cGdcIik7XG52YXIgUGdRdWVyeWFibGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgcGdPcHRpb25zKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wZ09wdGlvbnMgPSBwZ09wdGlvbnM7XG4gIH1cbiAgcHJvdmlkZXIgPSBcInBvc3RncmVzXCI7XG4gIGFkYXB0ZXJOYW1lID0gbmFtZTtcbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBxdWVyeSBnaXZlbiBhcyBTUUwsIGludGVycG9sYXRpbmcgdGhlIGdpdmVuIHBhcmFtZXRlcnMuXG4gICAqL1xuICBhc3luYyBxdWVyeVJhdyhxdWVyeSkge1xuICAgIGNvbnN0IHRhZyA9IFwiW2pzOjpxdWVyeV9yYXddXCI7XG4gICAgZGVidWcoYCR7dGFnfSAlT2AsIHF1ZXJ5KTtcbiAgICBjb25zdCB7IGZpZWxkcywgcm93cyB9ID0gYXdhaXQgdGhpcy5wZXJmb3JtSU8ocXVlcnkpO1xuICAgIGNvbnN0IGNvbHVtbk5hbWVzID0gZmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLm5hbWUpO1xuICAgIGxldCBjb2x1bW5UeXBlcyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBjb2x1bW5UeXBlcyA9IGZpZWxkcy5tYXAoKGZpZWxkKSA9PiBmaWVsZFRvQ29sdW1uVHlwZShmaWVsZC5kYXRhVHlwZUlEKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBVbnN1cHBvcnRlZE5hdGl2ZURhdGFUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBEcml2ZXJBZGFwdGVyRXJyb3Ioe1xuICAgICAgICAgIGtpbmQ6IFwiVW5zdXBwb3J0ZWROYXRpdmVEYXRhVHlwZVwiLFxuICAgICAgICAgIHR5cGU6IGUudHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGNvbnN0IHVkdFBhcnNlciA9IHRoaXMucGdPcHRpb25zPy51c2VyRGVmaW5lZFR5cGVQYXJzZXI7XG4gICAgaWYgKHVkdFBhcnNlcikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgIGlmIChmaWVsZC5kYXRhVHlwZUlEID49IEZJUlNUX05PUk1BTF9PQkpFQ1RfSUQgJiYgIU9iamVjdC5oYXNPd24oY3VzdG9tUGFyc2VycywgZmllbGQuZGF0YVR5cGVJRCkpIHtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHJvd3Nbal1baV0gPSBhd2FpdCB1ZHRQYXJzZXIoZmllbGQuZGF0YVR5cGVJRCwgcm93c1tqXVtpXSwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5OYW1lcyxcbiAgICAgIGNvbHVtblR5cGVzLFxuICAgICAgcm93c1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBxdWVyeSBnaXZlbiBhcyBTUUwsIGludGVycG9sYXRpbmcgdGhlIGdpdmVuIHBhcmFtZXRlcnMgYW5kXG4gICAqIHJldHVybmluZyB0aGUgbnVtYmVyIG9mIGFmZmVjdGVkIHJvd3MuXG4gICAqIE5vdGU6IFF1ZXJ5YWJsZSBleHBlY3RzIGEgdTY0LCBidXQgbmFwaS5ycyBvbmx5IHN1cHBvcnRzIHUzMi5cbiAgICovXG4gIGFzeW5jIGV4ZWN1dGVSYXcocXVlcnkpIHtcbiAgICBjb25zdCB0YWcgPSBcIltqczo6ZXhlY3V0ZV9yYXddXCI7XG4gICAgZGVidWcoYCR7dGFnfSAlT2AsIHF1ZXJ5KTtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMucGVyZm9ybUlPKHF1ZXJ5KSkucm93Q291bnQgPz8gMDtcbiAgfVxuICAvKipcbiAgICogUnVuIGEgcXVlcnkgYWdhaW5zdCB0aGUgZGF0YWJhc2UsIHJldHVybmluZyB0aGUgcmVzdWx0IHNldC5cbiAgICogU2hvdWxkIHRoZSBxdWVyeSBmYWlsIGR1ZSB0byBhIGNvbm5lY3Rpb24gZXJyb3IsIHRoZSBjb25uZWN0aW9uIGlzXG4gICAqIG1hcmtlZCBhcyB1bmhlYWx0aHkuXG4gICAqL1xuICBhc3luYyBwZXJmb3JtSU8ocXVlcnkpIHtcbiAgICBjb25zdCB7IHNxbCwgYXJncyB9ID0gcXVlcnk7XG4gICAgY29uc3QgdmFsdWVzID0gYXJncy5tYXAoKGFyZywgaSkgPT4gbWFwQXJnKGFyZywgcXVlcnkuYXJnVHlwZXNbaV0pKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jbGllbnQucXVlcnkoXG4gICAgICAgIHtcbiAgICAgICAgICB0ZXh0OiBzcWwsXG4gICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgIHJvd01vZGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB0eXBlczoge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZXJyb3IgZXhwZWN0ZWQ6XG4gICAgICAgICAgICAvLyBObyBvdmVybG9hZCBtYXRjaGVzIHRoaXMgY2FsbC5cbiAgICAgICAgICAgIC8vIFRoZSBsYXN0IG92ZXJsb2FkIGdhdmUgdGhlIGZvbGxvd2luZyBlcnJvci5cbiAgICAgICAgICAgIC8vIFR5cGUgJyhvaWQ6IG51bWJlciwgZm9ybWF0PzogYW55KSA9PiAoanNvbjogc3RyaW5nKSA9PiB1bmtub3duJyBpcyBub3QgYXNzaWduYWJsZSB0byB0eXBlICd7IDxUPihvaWQ6IG51bWJlcik6IFR5cGVQYXJzZXI8c3RyaW5nLCBzdHJpbmcgfCBUPjsgPFQ+KG9pZDogbnVtYmVyLCBmb3JtYXQ6IFwidGV4dFwiKTogVHlwZVBhcnNlcjxzdHJpbmcsIHN0cmluZyB8IFQ+OyA8VD4ob2lkOiBudW1iZXIsIGZvcm1hdDogXCJiaW5hcnlcIik6IFR5cGVQYXJzZXI8Li4uPjsgfScuXG4gICAgICAgICAgICAvLyAgIFR5cGUgJyhqc29uOiBzdHJpbmcpID0+IHVua25vd24nIGlzIG5vdCBhc3NpZ25hYmxlIHRvIHR5cGUgJ1R5cGVQYXJzZXI8QnVmZmVyLCBhbnk+Jy5cbiAgICAgICAgICAgIC8vICAgICBUeXBlcyBvZiBwYXJhbWV0ZXJzICdqc29uJyBhbmQgJ3ZhbHVlJyBhcmUgaW5jb21wYXRpYmxlLlxuICAgICAgICAgICAgLy8gICAgICAgVHlwZSAnQnVmZmVyJyBpcyBub3QgYXNzaWduYWJsZSB0byB0eXBlICdzdHJpbmcnLnRzKDI3NjkpXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQmVjYXVzZSBwZy10eXBlcyB0eXBlcyBleHBlY3QgdXMgdG8gaGFuZGxlIGJvdGggYmluYXJ5IGFuZCB0ZXh0IHByb3RvY29sIHZlcnNpb25zLFxuICAgICAgICAgICAgLy8gd2hlcmUgYXMgZmFyIHdlIGNhbiBzZWUsIHBnIHdpbGwgZXZlciBwYXNzIG9ubHkgdGV4dCB2ZXJzaW9uLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGdldFR5cGVQYXJzZXI6IChvaWQsIGZvcm1hdCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcInRleHRcIiAmJiBjdXN0b21QYXJzZXJzW29pZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tUGFyc2Vyc1tvaWRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0eXBlczIuZ2V0VHlwZVBhcnNlcihvaWQsIGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWx1ZXNcbiAgICAgICk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMub25FcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgb25FcnJvcihlcnJvcikge1xuICAgIGRlYnVnKFwiRXJyb3IgaW4gcGVyZm9ybUlPOiAlT1wiLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IERyaXZlckFkYXB0ZXJFcnJvcihjb252ZXJ0RHJpdmVyRXJyb3IoZXJyb3IpKTtcbiAgfVxufTtcbnZhciBQZ1RyYW5zYWN0aW9uID0gY2xhc3MgZXh0ZW5kcyBQZ1F1ZXJ5YWJsZSB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgb3B0aW9ucywgcGdPcHRpb25zLCBjbGVhbnVwKSB7XG4gICAgc3VwZXIoY2xpZW50LCBwZ09wdGlvbnMpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5wZ09wdGlvbnMgPSBwZ09wdGlvbnM7XG4gICAgdGhpcy5jbGVhbnVwID0gY2xlYW51cDtcbiAgfVxuICBhc3luYyBjb21taXQoKSB7XG4gICAgZGVidWcoYFtqczo6Y29tbWl0XWApO1xuICAgIHRoaXMuY2xlYW51cD8uKCk7XG4gICAgdGhpcy5jbGllbnQucmVsZWFzZSgpO1xuICB9XG4gIGFzeW5jIHJvbGxiYWNrKCkge1xuICAgIGRlYnVnKGBbanM6OnJvbGxiYWNrXWApO1xuICAgIHRoaXMuY2xlYW51cD8uKCk7XG4gICAgdGhpcy5jbGllbnQucmVsZWFzZSgpO1xuICB9XG59O1xudmFyIFByaXNtYVBnQWRhcHRlciA9IGNsYXNzIGV4dGVuZHMgUGdRdWVyeWFibGUge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIHBnT3B0aW9ucywgcmVsZWFzZSkge1xuICAgIHN1cGVyKGNsaWVudCk7XG4gICAgdGhpcy5wZ09wdGlvbnMgPSBwZ09wdGlvbnM7XG4gICAgdGhpcy5yZWxlYXNlID0gcmVsZWFzZTtcbiAgfVxuICBhc3luYyBzdGFydFRyYW5zYWN0aW9uKGlzb2xhdGlvbkxldmVsKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHVzZVBoYW50b21RdWVyeTogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IHRhZyA9IFwiW2pzOjpzdGFydFRyYW5zYWN0aW9uXVwiO1xuICAgIGRlYnVnKFwiJXMgb3B0aW9uczogJU9cIiwgdGFnLCBvcHRpb25zKTtcbiAgICBjb25zdCBjb25uID0gYXdhaXQgdGhpcy5jbGllbnQuY29ubmVjdCgpLmNhdGNoKChlcnJvcikgPT4gdGhpcy5vbkVycm9yKGVycm9yKSk7XG4gICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgIGRlYnVnKGBFcnJvciBmcm9tIHBvb2wgY29ubmVjdGlvbjogJHtlcnIubWVzc2FnZX0gJU9gLCBlcnIpO1xuICAgICAgdGhpcy5wZ09wdGlvbnM/Lm9uQ29ubmVjdGlvbkVycm9yPy4oZXJyKTtcbiAgICB9O1xuICAgIGNvbm4ub24oXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgY29ubi5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHR4ID0gbmV3IFBnVHJhbnNhY3Rpb24oY29ubiwgb3B0aW9ucywgdGhpcy5wZ09wdGlvbnMsIGNsZWFudXApO1xuICAgICAgYXdhaXQgdHguZXhlY3V0ZVJhdyh7IHNxbDogXCJCRUdJTlwiLCBhcmdzOiBbXSwgYXJnVHlwZXM6IFtdIH0pO1xuICAgICAgaWYgKGlzb2xhdGlvbkxldmVsKSB7XG4gICAgICAgIGF3YWl0IHR4LmV4ZWN1dGVSYXcoe1xuICAgICAgICAgIHNxbDogYFNFVCBUUkFOU0FDVElPTiBJU09MQVRJT04gTEVWRUwgJHtpc29sYXRpb25MZXZlbH1gLFxuICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgIGFyZ1R5cGVzOiBbXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2xlYW51cCgpO1xuICAgICAgY29ubi5yZWxlYXNlKGVycm9yKTtcbiAgICAgIHRoaXMub25FcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGV4ZWN1dGVTY3JpcHQoc2NyaXB0KSB7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IHNjcmlwdC5zcGxpdChcIjtcIikubWFwKChzdG10KSA9PiBzdG10LnRyaW0oKSkuZmlsdGVyKChzdG10KSA9PiBzdG10Lmxlbmd0aCA+IDApO1xuICAgIGZvciAoY29uc3Qgc3RtdCBvZiBzdGF0ZW1lbnRzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5xdWVyeShzdG10KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMub25FcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldENvbm5lY3Rpb25JbmZvKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWFOYW1lOiB0aGlzLnBnT3B0aW9ucz8uc2NoZW1hLFxuICAgICAgc3VwcG9ydHNSZWxhdGlvbkpvaW5zOiB0cnVlXG4gICAgfTtcbiAgfVxuICBhc3luYyBkaXNwb3NlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbGVhc2U/LigpO1xuICB9XG4gIHVuZGVybHlpbmdEcml2ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50O1xuICB9XG59O1xudmFyIFByaXNtYVBnQWRhcHRlckZhY3RvcnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBvb2xPckNvbmZpZywgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKHBvb2xPckNvbmZpZyBpbnN0YW5jZW9mIHBnMi5Qb29sKSB7XG4gICAgICB0aGlzLmV4dGVybmFsUG9vbCA9IHBvb2xPckNvbmZpZztcbiAgICAgIHRoaXMuY29uZmlnID0gcG9vbE9yQ29uZmlnLm9wdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXh0ZXJuYWxQb29sID0gbnVsbDtcbiAgICAgIHRoaXMuY29uZmlnID0gcG9vbE9yQ29uZmlnO1xuICAgIH1cbiAgfVxuICBwcm92aWRlciA9IFwicG9zdGdyZXNcIjtcbiAgYWRhcHRlck5hbWUgPSBuYW1lO1xuICBjb25maWc7XG4gIGV4dGVybmFsUG9vbDtcbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmV4dGVybmFsUG9vbCA/PyBuZXcgcGcyLlBvb2wodGhpcy5jb25maWcpO1xuICAgIGNvbnN0IG9uSWRsZUNsaWVudEVycm9yID0gKGVycikgPT4ge1xuICAgICAgZGVidWcoYEVycm9yIGZyb20gaWRsZSBwb29sIGNsaWVudDogJHtlcnIubWVzc2FnZX0gJU9gLCBlcnIpO1xuICAgICAgdGhpcy5vcHRpb25zPy5vblBvb2xFcnJvcj8uKGVycik7XG4gICAgfTtcbiAgICBjbGllbnQub24oXCJlcnJvclwiLCBvbklkbGVDbGllbnRFcnJvcik7XG4gICAgcmV0dXJuIG5ldyBQcmlzbWFQZ0FkYXB0ZXIoY2xpZW50LCB0aGlzLm9wdGlvbnMsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmV4dGVybmFsUG9vbCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zPy5kaXNwb3NlRXh0ZXJuYWxQb29sKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5leHRlcm5hbFBvb2wuZW5kKCk7XG4gICAgICAgICAgdGhpcy5leHRlcm5hbFBvb2wgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZXh0ZXJuYWxQb29sLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgb25JZGxlQ2xpZW50RXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCBjbGllbnQuZW5kKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdFRvU2hhZG93RGIoKSB7XG4gICAgY29uc3QgY29ubiA9IGF3YWl0IHRoaXMuY29ubmVjdCgpO1xuICAgIGNvbnN0IGRhdGFiYXNlID0gYHByaXNtYV9taWdyYXRlX3NoYWRvd19kYl8ke2dsb2JhbFRoaXMuY3J5cHRvLnJhbmRvbVVVSUQoKX1gO1xuICAgIGF3YWl0IGNvbm4uZXhlY3V0ZVNjcmlwdChgQ1JFQVRFIERBVEFCQVNFIFwiJHtkYXRhYmFzZX1cImApO1xuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBwZzIuUG9vbCh7IC4uLnRoaXMuY29uZmlnLCBkYXRhYmFzZSB9KTtcbiAgICByZXR1cm4gbmV3IFByaXNtYVBnQWRhcHRlcihjbGllbnQsIHZvaWQgMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgY29ubi5leGVjdXRlU2NyaXB0KGBEUk9QIERBVEFCQVNFIFwiJHtkYXRhYmFzZX1cImApO1xuICAgICAgYXdhaXQgY2xpZW50LmVuZCgpO1xuICAgIH0pO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgUHJpc21hUGdBZGFwdGVyRmFjdG9yeSBhcyBQcmlzbWFQZ1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@prisma/adapter-pg/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@prisma/debug/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@prisma/debug/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Debug: () => (/* binding */ Debug),\n/* harmony export */   clearLogs: () => (/* binding */ clearLogs),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   getLogs: () => (/* binding */ getLogs)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// ../../node_modules/.pnpm/kleur@4.1.5/node_modules/kleur/colors.mjs\nvar colors_exports = {};\n__export(colors_exports, {\n  $: () => $,\n  bgBlack: () => bgBlack,\n  bgBlue: () => bgBlue,\n  bgCyan: () => bgCyan,\n  bgGreen: () => bgGreen,\n  bgMagenta: () => bgMagenta,\n  bgRed: () => bgRed,\n  bgWhite: () => bgWhite,\n  bgYellow: () => bgYellow,\n  black: () => black,\n  blue: () => blue,\n  bold: () => bold,\n  cyan: () => cyan,\n  dim: () => dim,\n  gray: () => gray,\n  green: () => green,\n  grey: () => grey,\n  hidden: () => hidden,\n  inverse: () => inverse,\n  italic: () => italic,\n  magenta: () => magenta,\n  red: () => red,\n  reset: () => reset,\n  strikethrough: () => strikethrough,\n  underline: () => underline,\n  white: () => white,\n  yellow: () => yellow\n});\nvar FORCE_COLOR;\nvar NODE_DISABLE_COLORS;\nvar NO_COLOR;\nvar TERM;\nvar isTTY = true;\nif (typeof process !== \"undefined\") {\n  ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});\n  isTTY = process.stdout && process.stdout.isTTY;\n}\nvar $ = {\n  enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== \"dumb\" && (FORCE_COLOR != null && FORCE_COLOR !== \"0\" || isTTY)\n};\nfunction init(x, y) {\n  let rgx = new RegExp(`\\\\x1b\\\\[${y}m`, \"g\");\n  let open = `\\x1B[${x}m`, close = `\\x1B[${y}m`;\n  return function(txt) {\n    if (!$.enabled || txt == null) return txt;\n    return open + (!!~(\"\" + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;\n  };\n}\nvar reset = init(0, 0);\nvar bold = init(1, 22);\nvar dim = init(2, 22);\nvar italic = init(3, 23);\nvar underline = init(4, 24);\nvar inverse = init(7, 27);\nvar hidden = init(8, 28);\nvar strikethrough = init(9, 29);\nvar black = init(30, 39);\nvar red = init(31, 39);\nvar green = init(32, 39);\nvar yellow = init(33, 39);\nvar blue = init(34, 39);\nvar magenta = init(35, 39);\nvar cyan = init(36, 39);\nvar white = init(37, 39);\nvar gray = init(90, 39);\nvar grey = init(90, 39);\nvar bgBlack = init(40, 49);\nvar bgRed = init(41, 49);\nvar bgGreen = init(42, 49);\nvar bgYellow = init(43, 49);\nvar bgBlue = init(44, 49);\nvar bgMagenta = init(45, 49);\nvar bgCyan = init(46, 49);\nvar bgWhite = init(47, 49);\n\n// src/index.ts\nvar MAX_ARGS_HISTORY = 100;\nvar COLORS = [\"green\", \"yellow\", \"blue\", \"magenta\", \"cyan\", \"red\"];\nvar argsHistory = [];\nvar lastTimestamp = Date.now();\nvar lastColor = 0;\nvar processEnv = typeof process !== \"undefined\" ? process.env : {};\nglobalThis.DEBUG ??= processEnv.DEBUG ?? \"\";\nglobalThis.DEBUG_COLORS ??= processEnv.DEBUG_COLORS ? processEnv.DEBUG_COLORS === \"true\" : true;\nvar topProps = {\n  enable(namespace) {\n    if (typeof namespace === \"string\") {\n      globalThis.DEBUG = namespace;\n    }\n  },\n  disable() {\n    const prev = globalThis.DEBUG;\n    globalThis.DEBUG = \"\";\n    return prev;\n  },\n  // this is the core logic to check if logging should happen or not\n  enabled(namespace) {\n    const listenedNamespaces = globalThis.DEBUG.split(\",\").map((s) => {\n      return s.replace(/[.+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n    });\n    const isListened = listenedNamespaces.some((listenedNamespace) => {\n      if (listenedNamespace === \"\" || listenedNamespace[0] === \"-\") return false;\n      return namespace.match(RegExp(listenedNamespace.split(\"*\").join(\".*\") + \"$\"));\n    });\n    const isExcluded = listenedNamespaces.some((listenedNamespace) => {\n      if (listenedNamespace === \"\" || listenedNamespace[0] !== \"-\") return false;\n      return namespace.match(RegExp(listenedNamespace.slice(1).split(\"*\").join(\".*\") + \"$\"));\n    });\n    return isListened && !isExcluded;\n  },\n  log: (...args) => {\n    const [namespace, format, ...rest] = args;\n    const logWithFormatting = console.warn ?? console.log;\n    logWithFormatting(`${namespace} ${format}`, ...rest);\n  },\n  formatters: {}\n  // not implemented\n};\nfunction debugCreate(namespace) {\n  const instanceProps = {\n    color: COLORS[lastColor++ % COLORS.length],\n    enabled: topProps.enabled(namespace),\n    namespace,\n    log: topProps.log,\n    extend: () => {\n    }\n    // not implemented\n  };\n  const debugCall = (...args) => {\n    const { enabled, namespace: namespace2, color, log } = instanceProps;\n    if (args.length !== 0) {\n      argsHistory.push([namespace2, ...args]);\n    }\n    if (argsHistory.length > MAX_ARGS_HISTORY) {\n      argsHistory.shift();\n    }\n    if (topProps.enabled(namespace2) || enabled) {\n      const stringArgs = args.map((arg) => {\n        if (typeof arg === \"string\") {\n          return arg;\n        }\n        return safeStringify(arg);\n      });\n      const ms = `+${Date.now() - lastTimestamp}ms`;\n      lastTimestamp = Date.now();\n      if (globalThis.DEBUG_COLORS) {\n        log(colors_exports[color](bold(namespace2)), ...stringArgs, colors_exports[color](ms));\n      } else {\n        log(namespace2, ...stringArgs, ms);\n      }\n    }\n  };\n  return new Proxy(debugCall, {\n    get: (_, prop) => instanceProps[prop],\n    set: (_, prop, value) => instanceProps[prop] = value\n  });\n}\nvar Debug = new Proxy(debugCreate, {\n  get: (_, prop) => topProps[prop],\n  set: (_, prop, value) => topProps[prop] = value\n});\nfunction safeStringify(value, indent = 2) {\n  const cache = /* @__PURE__ */ new Set();\n  return JSON.stringify(\n    value,\n    (key, value2) => {\n      if (typeof value2 === \"object\" && value2 !== null) {\n        if (cache.has(value2)) {\n          return `[Circular *]`;\n        }\n        cache.add(value2);\n      } else if (typeof value2 === \"bigint\") {\n        return value2.toString();\n      }\n      return value2;\n    },\n    indent\n  );\n}\nfunction getLogs(numChars = 7500) {\n  const logs = argsHistory.map(([namespace, ...args]) => {\n    return `${namespace} ${args.map((arg) => {\n      if (typeof arg === \"string\") {\n        return arg;\n      } else {\n        return JSON.stringify(arg);\n      }\n    }).join(\" \")}`;\n  }).join(\"\\n\");\n  if (logs.length < numChars) {\n    return logs;\n  }\n  return logs.slice(-numChars);\n}\nfunction clearLogs() {\n  argsHistory.length = 0;\n}\nvar index_default = Debug;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHByaXNtYS9kZWJ1Zy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxtREFBbUQsbUJBQW1CO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxFQUFFO0FBQ3BDLHFCQUFxQixFQUFFLG9CQUFvQixFQUFFO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXLEVBQUUsT0FBTztBQUM3QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQTZDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyxFQUFFO0FBQzNCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUssWUFBWTtBQUNqQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iYWNrZW5kLy4vbm9kZV9tb2R1bGVzL0BwcmlzbWEvZGVidWcvZGlzdC9pbmRleC5tanM/NTYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0va2xldXJANC4xLjUvbm9kZV9tb2R1bGVzL2tsZXVyL2NvbG9ycy5tanNcbnZhciBjb2xvcnNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY29sb3JzX2V4cG9ydHMsIHtcbiAgJDogKCkgPT4gJCxcbiAgYmdCbGFjazogKCkgPT4gYmdCbGFjayxcbiAgYmdCbHVlOiAoKSA9PiBiZ0JsdWUsXG4gIGJnQ3lhbjogKCkgPT4gYmdDeWFuLFxuICBiZ0dyZWVuOiAoKSA9PiBiZ0dyZWVuLFxuICBiZ01hZ2VudGE6ICgpID0+IGJnTWFnZW50YSxcbiAgYmdSZWQ6ICgpID0+IGJnUmVkLFxuICBiZ1doaXRlOiAoKSA9PiBiZ1doaXRlLFxuICBiZ1llbGxvdzogKCkgPT4gYmdZZWxsb3csXG4gIGJsYWNrOiAoKSA9PiBibGFjayxcbiAgYmx1ZTogKCkgPT4gYmx1ZSxcbiAgYm9sZDogKCkgPT4gYm9sZCxcbiAgY3lhbjogKCkgPT4gY3lhbixcbiAgZGltOiAoKSA9PiBkaW0sXG4gIGdyYXk6ICgpID0+IGdyYXksXG4gIGdyZWVuOiAoKSA9PiBncmVlbixcbiAgZ3JleTogKCkgPT4gZ3JleSxcbiAgaGlkZGVuOiAoKSA9PiBoaWRkZW4sXG4gIGludmVyc2U6ICgpID0+IGludmVyc2UsXG4gIGl0YWxpYzogKCkgPT4gaXRhbGljLFxuICBtYWdlbnRhOiAoKSA9PiBtYWdlbnRhLFxuICByZWQ6ICgpID0+IHJlZCxcbiAgcmVzZXQ6ICgpID0+IHJlc2V0LFxuICBzdHJpa2V0aHJvdWdoOiAoKSA9PiBzdHJpa2V0aHJvdWdoLFxuICB1bmRlcmxpbmU6ICgpID0+IHVuZGVybGluZSxcbiAgd2hpdGU6ICgpID0+IHdoaXRlLFxuICB5ZWxsb3c6ICgpID0+IHllbGxvd1xufSk7XG52YXIgRk9SQ0VfQ09MT1I7XG52YXIgTk9ERV9ESVNBQkxFX0NPTE9SUztcbnZhciBOT19DT0xPUjtcbnZhciBURVJNO1xudmFyIGlzVFRZID0gdHJ1ZTtcbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAoeyBGT1JDRV9DT0xPUiwgTk9ERV9ESVNBQkxFX0NPTE9SUywgTk9fQ09MT1IsIFRFUk0gfSA9IHByb2Nlc3MuZW52IHx8IHt9KTtcbiAgaXNUVFkgPSBwcm9jZXNzLnN0ZG91dCAmJiBwcm9jZXNzLnN0ZG91dC5pc1RUWTtcbn1cbnZhciAkID0ge1xuICBlbmFibGVkOiAhTk9ERV9ESVNBQkxFX0NPTE9SUyAmJiBOT19DT0xPUiA9PSBudWxsICYmIFRFUk0gIT09IFwiZHVtYlwiICYmIChGT1JDRV9DT0xPUiAhPSBudWxsICYmIEZPUkNFX0NPTE9SICE9PSBcIjBcIiB8fCBpc1RUWSlcbn07XG5mdW5jdGlvbiBpbml0KHgsIHkpIHtcbiAgbGV0IHJneCA9IG5ldyBSZWdFeHAoYFxcXFx4MWJcXFxcWyR7eX1tYCwgXCJnXCIpO1xuICBsZXQgb3BlbiA9IGBcXHgxQlske3h9bWAsIGNsb3NlID0gYFxceDFCWyR7eX1tYDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHR4dCkge1xuICAgIGlmICghJC5lbmFibGVkIHx8IHR4dCA9PSBudWxsKSByZXR1cm4gdHh0O1xuICAgIHJldHVybiBvcGVuICsgKCEhfihcIlwiICsgdHh0KS5pbmRleE9mKGNsb3NlKSA/IHR4dC5yZXBsYWNlKHJneCwgY2xvc2UgKyBvcGVuKSA6IHR4dCkgKyBjbG9zZTtcbiAgfTtcbn1cbnZhciByZXNldCA9IGluaXQoMCwgMCk7XG52YXIgYm9sZCA9IGluaXQoMSwgMjIpO1xudmFyIGRpbSA9IGluaXQoMiwgMjIpO1xudmFyIGl0YWxpYyA9IGluaXQoMywgMjMpO1xudmFyIHVuZGVybGluZSA9IGluaXQoNCwgMjQpO1xudmFyIGludmVyc2UgPSBpbml0KDcsIDI3KTtcbnZhciBoaWRkZW4gPSBpbml0KDgsIDI4KTtcbnZhciBzdHJpa2V0aHJvdWdoID0gaW5pdCg5LCAyOSk7XG52YXIgYmxhY2sgPSBpbml0KDMwLCAzOSk7XG52YXIgcmVkID0gaW5pdCgzMSwgMzkpO1xudmFyIGdyZWVuID0gaW5pdCgzMiwgMzkpO1xudmFyIHllbGxvdyA9IGluaXQoMzMsIDM5KTtcbnZhciBibHVlID0gaW5pdCgzNCwgMzkpO1xudmFyIG1hZ2VudGEgPSBpbml0KDM1LCAzOSk7XG52YXIgY3lhbiA9IGluaXQoMzYsIDM5KTtcbnZhciB3aGl0ZSA9IGluaXQoMzcsIDM5KTtcbnZhciBncmF5ID0gaW5pdCg5MCwgMzkpO1xudmFyIGdyZXkgPSBpbml0KDkwLCAzOSk7XG52YXIgYmdCbGFjayA9IGluaXQoNDAsIDQ5KTtcbnZhciBiZ1JlZCA9IGluaXQoNDEsIDQ5KTtcbnZhciBiZ0dyZWVuID0gaW5pdCg0MiwgNDkpO1xudmFyIGJnWWVsbG93ID0gaW5pdCg0MywgNDkpO1xudmFyIGJnQmx1ZSA9IGluaXQoNDQsIDQ5KTtcbnZhciBiZ01hZ2VudGEgPSBpbml0KDQ1LCA0OSk7XG52YXIgYmdDeWFuID0gaW5pdCg0NiwgNDkpO1xudmFyIGJnV2hpdGUgPSBpbml0KDQ3LCA0OSk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIE1BWF9BUkdTX0hJU1RPUlkgPSAxMDA7XG52YXIgQ09MT1JTID0gW1wiZ3JlZW5cIiwgXCJ5ZWxsb3dcIiwgXCJibHVlXCIsIFwibWFnZW50YVwiLCBcImN5YW5cIiwgXCJyZWRcIl07XG52YXIgYXJnc0hpc3RvcnkgPSBbXTtcbnZhciBsYXN0VGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbnZhciBsYXN0Q29sb3IgPSAwO1xudmFyIHByb2Nlc3NFbnYgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiA/IHByb2Nlc3MuZW52IDoge307XG5nbG9iYWxUaGlzLkRFQlVHID8/PSBwcm9jZXNzRW52LkRFQlVHID8/IFwiXCI7XG5nbG9iYWxUaGlzLkRFQlVHX0NPTE9SUyA/Pz0gcHJvY2Vzc0Vudi5ERUJVR19DT0xPUlMgPyBwcm9jZXNzRW52LkRFQlVHX0NPTE9SUyA9PT0gXCJ0cnVlXCIgOiB0cnVlO1xudmFyIHRvcFByb3BzID0ge1xuICBlbmFibGUobmFtZXNwYWNlKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGdsb2JhbFRoaXMuREVCVUcgPSBuYW1lc3BhY2U7XG4gICAgfVxuICB9LFxuICBkaXNhYmxlKCkge1xuICAgIGNvbnN0IHByZXYgPSBnbG9iYWxUaGlzLkRFQlVHO1xuICAgIGdsb2JhbFRoaXMuREVCVUcgPSBcIlwiO1xuICAgIHJldHVybiBwcmV2O1xuICB9LFxuICAvLyB0aGlzIGlzIHRoZSBjb3JlIGxvZ2ljIHRvIGNoZWNrIGlmIGxvZ2dpbmcgc2hvdWxkIGhhcHBlbiBvciBub3RcbiAgZW5hYmxlZChuYW1lc3BhY2UpIHtcbiAgICBjb25zdCBsaXN0ZW5lZE5hbWVzcGFjZXMgPSBnbG9iYWxUaGlzLkRFQlVHLnNwbGl0KFwiLFwiKS5tYXAoKHMpID0+IHtcbiAgICAgIHJldHVybiBzLnJlcGxhY2UoL1suKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xuICAgIH0pO1xuICAgIGNvbnN0IGlzTGlzdGVuZWQgPSBsaXN0ZW5lZE5hbWVzcGFjZXMuc29tZSgobGlzdGVuZWROYW1lc3BhY2UpID0+IHtcbiAgICAgIGlmIChsaXN0ZW5lZE5hbWVzcGFjZSA9PT0gXCJcIiB8fCBsaXN0ZW5lZE5hbWVzcGFjZVswXSA9PT0gXCItXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBuYW1lc3BhY2UubWF0Y2goUmVnRXhwKGxpc3RlbmVkTmFtZXNwYWNlLnNwbGl0KFwiKlwiKS5qb2luKFwiLipcIikgKyBcIiRcIikpO1xuICAgIH0pO1xuICAgIGNvbnN0IGlzRXhjbHVkZWQgPSBsaXN0ZW5lZE5hbWVzcGFjZXMuc29tZSgobGlzdGVuZWROYW1lc3BhY2UpID0+IHtcbiAgICAgIGlmIChsaXN0ZW5lZE5hbWVzcGFjZSA9PT0gXCJcIiB8fCBsaXN0ZW5lZE5hbWVzcGFjZVswXSAhPT0gXCItXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBuYW1lc3BhY2UubWF0Y2goUmVnRXhwKGxpc3RlbmVkTmFtZXNwYWNlLnNsaWNlKDEpLnNwbGl0KFwiKlwiKS5qb2luKFwiLipcIikgKyBcIiRcIikpO1xuICAgIH0pO1xuICAgIHJldHVybiBpc0xpc3RlbmVkICYmICFpc0V4Y2x1ZGVkO1xuICB9LFxuICBsb2c6ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgW25hbWVzcGFjZSwgZm9ybWF0LCAuLi5yZXN0XSA9IGFyZ3M7XG4gICAgY29uc3QgbG9nV2l0aEZvcm1hdHRpbmcgPSBjb25zb2xlLndhcm4gPz8gY29uc29sZS5sb2c7XG4gICAgbG9nV2l0aEZvcm1hdHRpbmcoYCR7bmFtZXNwYWNlfSAke2Zvcm1hdH1gLCAuLi5yZXN0KTtcbiAgfSxcbiAgZm9ybWF0dGVyczoge31cbiAgLy8gbm90IGltcGxlbWVudGVkXG59O1xuZnVuY3Rpb24gZGVidWdDcmVhdGUobmFtZXNwYWNlKSB7XG4gIGNvbnN0IGluc3RhbmNlUHJvcHMgPSB7XG4gICAgY29sb3I6IENPTE9SU1tsYXN0Q29sb3IrKyAlIENPTE9SUy5sZW5ndGhdLFxuICAgIGVuYWJsZWQ6IHRvcFByb3BzLmVuYWJsZWQobmFtZXNwYWNlKSxcbiAgICBuYW1lc3BhY2UsXG4gICAgbG9nOiB0b3BQcm9wcy5sb2csXG4gICAgZXh0ZW5kOiAoKSA9PiB7XG4gICAgfVxuICAgIC8vIG5vdCBpbXBsZW1lbnRlZFxuICB9O1xuICBjb25zdCBkZWJ1Z0NhbGwgPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHsgZW5hYmxlZCwgbmFtZXNwYWNlOiBuYW1lc3BhY2UyLCBjb2xvciwgbG9nIH0gPSBpbnN0YW5jZVByb3BzO1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgYXJnc0hpc3RvcnkucHVzaChbbmFtZXNwYWNlMiwgLi4uYXJnc10pO1xuICAgIH1cbiAgICBpZiAoYXJnc0hpc3RvcnkubGVuZ3RoID4gTUFYX0FSR1NfSElTVE9SWSkge1xuICAgICAgYXJnc0hpc3Rvcnkuc2hpZnQoKTtcbiAgICB9XG4gICAgaWYgKHRvcFByb3BzLmVuYWJsZWQobmFtZXNwYWNlMikgfHwgZW5hYmxlZCkge1xuICAgICAgY29uc3Qgc3RyaW5nQXJncyA9IGFyZ3MubWFwKChhcmcpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYWZlU3RyaW5naWZ5KGFyZyk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1zID0gYCske0RhdGUubm93KCkgLSBsYXN0VGltZXN0YW1wfW1zYDtcbiAgICAgIGxhc3RUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgaWYgKGdsb2JhbFRoaXMuREVCVUdfQ09MT1JTKSB7XG4gICAgICAgIGxvZyhjb2xvcnNfZXhwb3J0c1tjb2xvcl0oYm9sZChuYW1lc3BhY2UyKSksIC4uLnN0cmluZ0FyZ3MsIGNvbG9yc19leHBvcnRzW2NvbG9yXShtcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nKG5hbWVzcGFjZTIsIC4uLnN0cmluZ0FyZ3MsIG1zKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkoZGVidWdDYWxsLCB7XG4gICAgZ2V0OiAoXywgcHJvcCkgPT4gaW5zdGFuY2VQcm9wc1twcm9wXSxcbiAgICBzZXQ6IChfLCBwcm9wLCB2YWx1ZSkgPT4gaW5zdGFuY2VQcm9wc1twcm9wXSA9IHZhbHVlXG4gIH0pO1xufVxudmFyIERlYnVnID0gbmV3IFByb3h5KGRlYnVnQ3JlYXRlLCB7XG4gIGdldDogKF8sIHByb3ApID0+IHRvcFByb3BzW3Byb3BdLFxuICBzZXQ6IChfLCBwcm9wLCB2YWx1ZSkgPT4gdG9wUHJvcHNbcHJvcF0gPSB2YWx1ZVxufSk7XG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5KHZhbHVlLCBpbmRlbnQgPSAyKSB7XG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgIHZhbHVlLFxuICAgIChrZXksIHZhbHVlMikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZTIgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChjYWNoZS5oYXModmFsdWUyKSkge1xuICAgICAgICAgIHJldHVybiBgW0NpcmN1bGFyICpdYDtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZS5hZGQodmFsdWUyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlMiA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUyLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUyO1xuICAgIH0sXG4gICAgaW5kZW50XG4gICk7XG59XG5mdW5jdGlvbiBnZXRMb2dzKG51bUNoYXJzID0gNzUwMCkge1xuICBjb25zdCBsb2dzID0gYXJnc0hpc3RvcnkubWFwKChbbmFtZXNwYWNlLCAuLi5hcmdzXSkgPT4ge1xuICAgIHJldHVybiBgJHtuYW1lc3BhY2V9ICR7YXJncy5tYXAoKGFyZykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmcpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oXCIgXCIpfWA7XG4gIH0pLmpvaW4oXCJcXG5cIik7XG4gIGlmIChsb2dzLmxlbmd0aCA8IG51bUNoYXJzKSB7XG4gICAgcmV0dXJuIGxvZ3M7XG4gIH1cbiAgcmV0dXJuIGxvZ3Muc2xpY2UoLW51bUNoYXJzKTtcbn1cbmZ1bmN0aW9uIGNsZWFyTG9ncygpIHtcbiAgYXJnc0hpc3RvcnkubGVuZ3RoID0gMDtcbn1cbnZhciBpbmRleF9kZWZhdWx0ID0gRGVidWc7XG5leHBvcnQge1xuICBEZWJ1ZyxcbiAgY2xlYXJMb2dzLFxuICBpbmRleF9kZWZhdWx0IGFzIGRlZmF1bHQsXG4gIGdldExvZ3Ncbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@prisma/debug/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@prisma/driver-adapter-utils/dist/index.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@prisma/driver-adapter-utils/dist/index.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnTypeEnum: () => (/* binding */ ColumnTypeEnum),\n/* harmony export */   Debug: () => (/* reexport safe */ _prisma_debug__WEBPACK_IMPORTED_MODULE_0__.Debug),\n/* harmony export */   DriverAdapterError: () => (/* binding */ DriverAdapterError),\n/* harmony export */   bindAdapter: () => (/* binding */ bindAdapter),\n/* harmony export */   bindMigrationAwareSqlAdapterFactory: () => (/* binding */ bindMigrationAwareSqlAdapterFactory),\n/* harmony export */   bindSqlAdapterFactory: () => (/* binding */ bindSqlAdapterFactory),\n/* harmony export */   err: () => (/* binding */ err),\n/* harmony export */   isDriverAdapterError: () => (/* binding */ isDriverAdapterError),\n/* harmony export */   mockAdapter: () => (/* binding */ mockAdapter),\n/* harmony export */   mockAdapterErrors: () => (/* binding */ mockAdapterErrors),\n/* harmony export */   mockAdapterFactory: () => (/* binding */ mockAdapterFactory),\n/* harmony export */   mockMigrationAwareAdapterFactory: () => (/* binding */ mockMigrationAwareAdapterFactory),\n/* harmony export */   ok: () => (/* binding */ ok)\n/* harmony export */ });\n/* harmony import */ var _prisma_debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prisma/debug */ \"(rsc)/./node_modules/@prisma/debug/dist/index.mjs\");\n// src/debug.ts\n\n\n// src/error.ts\nvar DriverAdapterError = class extends Error {\n  name = \"DriverAdapterError\";\n  cause;\n  constructor(payload) {\n    super(typeof payload[\"message\"] === \"string\" ? payload[\"message\"] : payload.kind);\n    this.cause = payload;\n  }\n};\nfunction isDriverAdapterError(error) {\n  return error[\"name\"] === \"DriverAdapterError\" && typeof error[\"cause\"] === \"object\";\n}\n\n// src/result.ts\nfunction ok(value) {\n  return {\n    ok: true,\n    value,\n    map(fn) {\n      return ok(fn(value));\n    },\n    flatMap(fn) {\n      return fn(value);\n    }\n  };\n}\nfunction err(error) {\n  return {\n    ok: false,\n    error,\n    map() {\n      return err(error);\n    },\n    flatMap() {\n      return err(error);\n    }\n  };\n}\n\n// src/binder.ts\nvar debug = (0,_prisma_debug__WEBPACK_IMPORTED_MODULE_0__.Debug)(\"driver-adapter-utils\");\nvar ErrorRegistryInternal = class {\n  registeredErrors = [];\n  consumeError(id) {\n    return this.registeredErrors[id];\n  }\n  registerNewError(error) {\n    let i = 0;\n    while (this.registeredErrors[i] !== void 0) {\n      i++;\n    }\n    this.registeredErrors[i] = { error };\n    return i;\n  }\n};\nfunction copySymbolsFromSource(source, target) {\n  const symbols = Object.getOwnPropertySymbols(source);\n  const symbolObject = Object.fromEntries(symbols.map((symbol) => [symbol, true]));\n  Object.assign(target, symbolObject);\n}\nvar bindMigrationAwareSqlAdapterFactory = (adapterFactory) => {\n  const errorRegistry = new ErrorRegistryInternal();\n  const boundFactory = {\n    adapterName: adapterFactory.adapterName,\n    provider: adapterFactory.provider,\n    errorRegistry,\n    connect: async (...args) => {\n      const ctx = await wrapAsync(errorRegistry, adapterFactory.connect.bind(adapterFactory))(...args);\n      return ctx.map((ctx2) => bindAdapter(ctx2, errorRegistry));\n    },\n    connectToShadowDb: async (...args) => {\n      const ctx = await wrapAsync(errorRegistry, adapterFactory.connectToShadowDb.bind(adapterFactory))(...args);\n      return ctx.map((ctx2) => bindAdapter(ctx2, errorRegistry));\n    }\n  };\n  copySymbolsFromSource(adapterFactory, boundFactory);\n  return boundFactory;\n};\nvar bindSqlAdapterFactory = (adapterFactory) => {\n  const errorRegistry = new ErrorRegistryInternal();\n  const boundFactory = {\n    adapterName: adapterFactory.adapterName,\n    provider: adapterFactory.provider,\n    errorRegistry,\n    connect: async (...args) => {\n      const ctx = await wrapAsync(errorRegistry, adapterFactory.connect.bind(adapterFactory))(...args);\n      return ctx.map((ctx2) => bindAdapter(ctx2, errorRegistry));\n    }\n  };\n  copySymbolsFromSource(adapterFactory, boundFactory);\n  return boundFactory;\n};\nvar bindAdapter = (adapter, errorRegistry = new ErrorRegistryInternal()) => {\n  const boundAdapter = {\n    adapterName: adapter.adapterName,\n    errorRegistry,\n    queryRaw: wrapAsync(errorRegistry, adapter.queryRaw.bind(adapter)),\n    executeRaw: wrapAsync(errorRegistry, adapter.executeRaw.bind(adapter)),\n    executeScript: wrapAsync(errorRegistry, adapter.executeScript.bind(adapter)),\n    dispose: wrapAsync(errorRegistry, adapter.dispose.bind(adapter)),\n    provider: adapter.provider,\n    startTransaction: async (...args) => {\n      const ctx = await wrapAsync(errorRegistry, adapter.startTransaction.bind(adapter))(...args);\n      return ctx.map((ctx2) => bindTransaction(errorRegistry, ctx2));\n    }\n  };\n  if (adapter.getConnectionInfo) {\n    boundAdapter.getConnectionInfo = wrapSync(errorRegistry, adapter.getConnectionInfo.bind(adapter));\n  }\n  return boundAdapter;\n};\nvar bindTransaction = (errorRegistry, transaction) => {\n  return {\n    adapterName: transaction.adapterName,\n    provider: transaction.provider,\n    options: transaction.options,\n    queryRaw: wrapAsync(errorRegistry, transaction.queryRaw.bind(transaction)),\n    executeRaw: wrapAsync(errorRegistry, transaction.executeRaw.bind(transaction)),\n    commit: wrapAsync(errorRegistry, transaction.commit.bind(transaction)),\n    rollback: wrapAsync(errorRegistry, transaction.rollback.bind(transaction))\n  };\n};\nfunction wrapAsync(registry, fn) {\n  return async (...args) => {\n    try {\n      return ok(await fn(...args));\n    } catch (error) {\n      debug(\"[error@wrapAsync]\", error);\n      if (isDriverAdapterError(error)) {\n        return err(error.cause);\n      }\n      const id = registry.registerNewError(error);\n      return err({ kind: \"GenericJs\", id });\n    }\n  };\n}\nfunction wrapSync(registry, fn) {\n  return (...args) => {\n    try {\n      return ok(fn(...args));\n    } catch (error) {\n      debug(\"[error@wrapSync]\", error);\n      if (isDriverAdapterError(error)) {\n        return err(error.cause);\n      }\n      const id = registry.registerNewError(error);\n      return err({ kind: \"GenericJs\", id });\n    }\n  };\n}\n\n// src/const.ts\nvar ColumnTypeEnum = {\n  // Scalars\n  Int32: 0,\n  Int64: 1,\n  Float: 2,\n  Double: 3,\n  Numeric: 4,\n  Boolean: 5,\n  Character: 6,\n  Text: 7,\n  Date: 8,\n  Time: 9,\n  DateTime: 10,\n  Json: 11,\n  Enum: 12,\n  Bytes: 13,\n  Set: 14,\n  Uuid: 15,\n  // Arrays\n  Int32Array: 64,\n  Int64Array: 65,\n  FloatArray: 66,\n  DoubleArray: 67,\n  NumericArray: 68,\n  BooleanArray: 69,\n  CharacterArray: 70,\n  TextArray: 71,\n  DateArray: 72,\n  TimeArray: 73,\n  DateTimeArray: 74,\n  JsonArray: 75,\n  EnumArray: 76,\n  BytesArray: 77,\n  UuidArray: 78,\n  // Custom\n  UnknownNumber: 128\n};\n\n// src/mock.ts\nvar mockAdapterErrors = {\n  queryRaw: new Error(\"Not implemented: queryRaw\"),\n  executeRaw: new Error(\"Not implemented: executeRaw\"),\n  startTransaction: new Error(\"Not implemented: startTransaction\"),\n  executeScript: new Error(\"Not implemented: executeScript\"),\n  dispose: new Error(\"Not implemented: dispose\")\n};\nfunction mockAdapter(provider) {\n  return {\n    provider,\n    adapterName: \"@prisma/adapter-mock\",\n    queryRaw: () => Promise.reject(mockAdapterErrors.queryRaw),\n    executeRaw: () => Promise.reject(mockAdapterErrors.executeRaw),\n    startTransaction: () => Promise.reject(mockAdapterErrors.startTransaction),\n    executeScript: () => Promise.reject(mockAdapterErrors.executeScript),\n    dispose: () => Promise.reject(mockAdapterErrors.dispose),\n    [Symbol.for(\"adapter.mockAdapter\")]: true\n  };\n}\nfunction mockAdapterFactory(provider) {\n  return {\n    provider,\n    adapterName: \"@prisma/adapter-mock\",\n    connect: () => Promise.resolve(mockAdapter(provider)),\n    [Symbol.for(\"adapter.mockAdapterFactory\")]: true\n  };\n}\nfunction mockMigrationAwareAdapterFactory(provider) {\n  return {\n    provider,\n    adapterName: \"@prisma/adapter-mock\",\n    connect: () => Promise.resolve(mockAdapter(provider)),\n    connectToShadowDb: () => Promise.resolve(mockAdapter(provider)),\n    [Symbol.for(\"adapter.mockMigrationAwareAdapterFactory\")]: true\n  };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHByaXNtYS9kcml2ZXItYWRhcHRlci11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3NDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxvREFBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFlRSIsInNvdXJjZXMiOlsid2VicGFjazovL2JhY2tlbmQvLi9ub2RlX21vZHVsZXMvQHByaXNtYS9kcml2ZXItYWRhcHRlci11dGlscy9kaXN0L2luZGV4Lm1qcz84OWMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9kZWJ1Zy50c1xuaW1wb3J0IHsgRGVidWcgfSBmcm9tIFwiQHByaXNtYS9kZWJ1Z1wiO1xuXG4vLyBzcmMvZXJyb3IudHNcbnZhciBEcml2ZXJBZGFwdGVyRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgbmFtZSA9IFwiRHJpdmVyQWRhcHRlckVycm9yXCI7XG4gIGNhdXNlO1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkKSB7XG4gICAgc3VwZXIodHlwZW9mIHBheWxvYWRbXCJtZXNzYWdlXCJdID09PSBcInN0cmluZ1wiID8gcGF5bG9hZFtcIm1lc3NhZ2VcIl0gOiBwYXlsb2FkLmtpbmQpO1xuICAgIHRoaXMuY2F1c2UgPSBwYXlsb2FkO1xuICB9XG59O1xuZnVuY3Rpb24gaXNEcml2ZXJBZGFwdGVyRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yW1wibmFtZVwiXSA9PT0gXCJEcml2ZXJBZGFwdGVyRXJyb3JcIiAmJiB0eXBlb2YgZXJyb3JbXCJjYXVzZVwiXSA9PT0gXCJvYmplY3RcIjtcbn1cblxuLy8gc3JjL3Jlc3VsdC50c1xuZnVuY3Rpb24gb2sodmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBvazogdHJ1ZSxcbiAgICB2YWx1ZSxcbiAgICBtYXAoZm4pIHtcbiAgICAgIHJldHVybiBvayhmbih2YWx1ZSkpO1xuICAgIH0sXG4gICAgZmxhdE1hcChmbikge1xuICAgICAgcmV0dXJuIGZuKHZhbHVlKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBlcnIoZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICBvazogZmFsc2UsXG4gICAgZXJyb3IsXG4gICAgbWFwKCkge1xuICAgICAgcmV0dXJuIGVycihlcnJvcik7XG4gICAgfSxcbiAgICBmbGF0TWFwKCkge1xuICAgICAgcmV0dXJuIGVycihlcnJvcik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYmluZGVyLnRzXG52YXIgZGVidWcgPSBEZWJ1ZyhcImRyaXZlci1hZGFwdGVyLXV0aWxzXCIpO1xudmFyIEVycm9yUmVnaXN0cnlJbnRlcm5hbCA9IGNsYXNzIHtcbiAgcmVnaXN0ZXJlZEVycm9ycyA9IFtdO1xuICBjb25zdW1lRXJyb3IoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmVkRXJyb3JzW2lkXTtcbiAgfVxuICByZWdpc3Rlck5ld0Vycm9yKGVycm9yKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlICh0aGlzLnJlZ2lzdGVyZWRFcnJvcnNbaV0gIT09IHZvaWQgMCkge1xuICAgICAgaSsrO1xuICAgIH1cbiAgICB0aGlzLnJlZ2lzdGVyZWRFcnJvcnNbaV0gPSB7IGVycm9yIH07XG4gICAgcmV0dXJuIGk7XG4gIH1cbn07XG5mdW5jdGlvbiBjb3B5U3ltYm9sc0Zyb21Tb3VyY2Uoc291cmNlLCB0YXJnZXQpIHtcbiAgY29uc3Qgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcbiAgY29uc3Qgc3ltYm9sT2JqZWN0ID0gT2JqZWN0LmZyb21FbnRyaWVzKHN5bWJvbHMubWFwKChzeW1ib2wpID0+IFtzeW1ib2wsIHRydWVdKSk7XG4gIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzeW1ib2xPYmplY3QpO1xufVxudmFyIGJpbmRNaWdyYXRpb25Bd2FyZVNxbEFkYXB0ZXJGYWN0b3J5ID0gKGFkYXB0ZXJGYWN0b3J5KSA9PiB7XG4gIGNvbnN0IGVycm9yUmVnaXN0cnkgPSBuZXcgRXJyb3JSZWdpc3RyeUludGVybmFsKCk7XG4gIGNvbnN0IGJvdW5kRmFjdG9yeSA9IHtcbiAgICBhZGFwdGVyTmFtZTogYWRhcHRlckZhY3RvcnkuYWRhcHRlck5hbWUsXG4gICAgcHJvdmlkZXI6IGFkYXB0ZXJGYWN0b3J5LnByb3ZpZGVyLFxuICAgIGVycm9yUmVnaXN0cnksXG4gICAgY29ubmVjdDogYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGN0eCA9IGF3YWl0IHdyYXBBc3luYyhlcnJvclJlZ2lzdHJ5LCBhZGFwdGVyRmFjdG9yeS5jb25uZWN0LmJpbmQoYWRhcHRlckZhY3RvcnkpKSguLi5hcmdzKTtcbiAgICAgIHJldHVybiBjdHgubWFwKChjdHgyKSA9PiBiaW5kQWRhcHRlcihjdHgyLCBlcnJvclJlZ2lzdHJ5KSk7XG4gICAgfSxcbiAgICBjb25uZWN0VG9TaGFkb3dEYjogYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGN0eCA9IGF3YWl0IHdyYXBBc3luYyhlcnJvclJlZ2lzdHJ5LCBhZGFwdGVyRmFjdG9yeS5jb25uZWN0VG9TaGFkb3dEYi5iaW5kKGFkYXB0ZXJGYWN0b3J5KSkoLi4uYXJncyk7XG4gICAgICByZXR1cm4gY3R4Lm1hcCgoY3R4MikgPT4gYmluZEFkYXB0ZXIoY3R4MiwgZXJyb3JSZWdpc3RyeSkpO1xuICAgIH1cbiAgfTtcbiAgY29weVN5bWJvbHNGcm9tU291cmNlKGFkYXB0ZXJGYWN0b3J5LCBib3VuZEZhY3RvcnkpO1xuICByZXR1cm4gYm91bmRGYWN0b3J5O1xufTtcbnZhciBiaW5kU3FsQWRhcHRlckZhY3RvcnkgPSAoYWRhcHRlckZhY3RvcnkpID0+IHtcbiAgY29uc3QgZXJyb3JSZWdpc3RyeSA9IG5ldyBFcnJvclJlZ2lzdHJ5SW50ZXJuYWwoKTtcbiAgY29uc3QgYm91bmRGYWN0b3J5ID0ge1xuICAgIGFkYXB0ZXJOYW1lOiBhZGFwdGVyRmFjdG9yeS5hZGFwdGVyTmFtZSxcbiAgICBwcm92aWRlcjogYWRhcHRlckZhY3RvcnkucHJvdmlkZXIsXG4gICAgZXJyb3JSZWdpc3RyeSxcbiAgICBjb25uZWN0OiBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgY3R4ID0gYXdhaXQgd3JhcEFzeW5jKGVycm9yUmVnaXN0cnksIGFkYXB0ZXJGYWN0b3J5LmNvbm5lY3QuYmluZChhZGFwdGVyRmFjdG9yeSkpKC4uLmFyZ3MpO1xuICAgICAgcmV0dXJuIGN0eC5tYXAoKGN0eDIpID0+IGJpbmRBZGFwdGVyKGN0eDIsIGVycm9yUmVnaXN0cnkpKTtcbiAgICB9XG4gIH07XG4gIGNvcHlTeW1ib2xzRnJvbVNvdXJjZShhZGFwdGVyRmFjdG9yeSwgYm91bmRGYWN0b3J5KTtcbiAgcmV0dXJuIGJvdW5kRmFjdG9yeTtcbn07XG52YXIgYmluZEFkYXB0ZXIgPSAoYWRhcHRlciwgZXJyb3JSZWdpc3RyeSA9IG5ldyBFcnJvclJlZ2lzdHJ5SW50ZXJuYWwoKSkgPT4ge1xuICBjb25zdCBib3VuZEFkYXB0ZXIgPSB7XG4gICAgYWRhcHRlck5hbWU6IGFkYXB0ZXIuYWRhcHRlck5hbWUsXG4gICAgZXJyb3JSZWdpc3RyeSxcbiAgICBxdWVyeVJhdzogd3JhcEFzeW5jKGVycm9yUmVnaXN0cnksIGFkYXB0ZXIucXVlcnlSYXcuYmluZChhZGFwdGVyKSksXG4gICAgZXhlY3V0ZVJhdzogd3JhcEFzeW5jKGVycm9yUmVnaXN0cnksIGFkYXB0ZXIuZXhlY3V0ZVJhdy5iaW5kKGFkYXB0ZXIpKSxcbiAgICBleGVjdXRlU2NyaXB0OiB3cmFwQXN5bmMoZXJyb3JSZWdpc3RyeSwgYWRhcHRlci5leGVjdXRlU2NyaXB0LmJpbmQoYWRhcHRlcikpLFxuICAgIGRpc3Bvc2U6IHdyYXBBc3luYyhlcnJvclJlZ2lzdHJ5LCBhZGFwdGVyLmRpc3Bvc2UuYmluZChhZGFwdGVyKSksXG4gICAgcHJvdmlkZXI6IGFkYXB0ZXIucHJvdmlkZXIsXG4gICAgc3RhcnRUcmFuc2FjdGlvbjogYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGN0eCA9IGF3YWl0IHdyYXBBc3luYyhlcnJvclJlZ2lzdHJ5LCBhZGFwdGVyLnN0YXJ0VHJhbnNhY3Rpb24uYmluZChhZGFwdGVyKSkoLi4uYXJncyk7XG4gICAgICByZXR1cm4gY3R4Lm1hcCgoY3R4MikgPT4gYmluZFRyYW5zYWN0aW9uKGVycm9yUmVnaXN0cnksIGN0eDIpKTtcbiAgICB9XG4gIH07XG4gIGlmIChhZGFwdGVyLmdldENvbm5lY3Rpb25JbmZvKSB7XG4gICAgYm91bmRBZGFwdGVyLmdldENvbm5lY3Rpb25JbmZvID0gd3JhcFN5bmMoZXJyb3JSZWdpc3RyeSwgYWRhcHRlci5nZXRDb25uZWN0aW9uSW5mby5iaW5kKGFkYXB0ZXIpKTtcbiAgfVxuICByZXR1cm4gYm91bmRBZGFwdGVyO1xufTtcbnZhciBiaW5kVHJhbnNhY3Rpb24gPSAoZXJyb3JSZWdpc3RyeSwgdHJhbnNhY3Rpb24pID0+IHtcbiAgcmV0dXJuIHtcbiAgICBhZGFwdGVyTmFtZTogdHJhbnNhY3Rpb24uYWRhcHRlck5hbWUsXG4gICAgcHJvdmlkZXI6IHRyYW5zYWN0aW9uLnByb3ZpZGVyLFxuICAgIG9wdGlvbnM6IHRyYW5zYWN0aW9uLm9wdGlvbnMsXG4gICAgcXVlcnlSYXc6IHdyYXBBc3luYyhlcnJvclJlZ2lzdHJ5LCB0cmFuc2FjdGlvbi5xdWVyeVJhdy5iaW5kKHRyYW5zYWN0aW9uKSksXG4gICAgZXhlY3V0ZVJhdzogd3JhcEFzeW5jKGVycm9yUmVnaXN0cnksIHRyYW5zYWN0aW9uLmV4ZWN1dGVSYXcuYmluZCh0cmFuc2FjdGlvbikpLFxuICAgIGNvbW1pdDogd3JhcEFzeW5jKGVycm9yUmVnaXN0cnksIHRyYW5zYWN0aW9uLmNvbW1pdC5iaW5kKHRyYW5zYWN0aW9uKSksXG4gICAgcm9sbGJhY2s6IHdyYXBBc3luYyhlcnJvclJlZ2lzdHJ5LCB0cmFuc2FjdGlvbi5yb2xsYmFjay5iaW5kKHRyYW5zYWN0aW9uKSlcbiAgfTtcbn07XG5mdW5jdGlvbiB3cmFwQXN5bmMocmVnaXN0cnksIGZuKSB7XG4gIHJldHVybiBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gb2soYXdhaXQgZm4oLi4uYXJncykpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZWJ1ZyhcIltlcnJvckB3cmFwQXN5bmNdXCIsIGVycm9yKTtcbiAgICAgIGlmIChpc0RyaXZlckFkYXB0ZXJFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIGVycihlcnJvci5jYXVzZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBpZCA9IHJlZ2lzdHJ5LnJlZ2lzdGVyTmV3RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGVycih7IGtpbmQ6IFwiR2VuZXJpY0pzXCIsIGlkIH0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHdyYXBTeW5jKHJlZ2lzdHJ5LCBmbikge1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG9rKGZuKC4uLmFyZ3MpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcoXCJbZXJyb3JAd3JhcFN5bmNdXCIsIGVycm9yKTtcbiAgICAgIGlmIChpc0RyaXZlckFkYXB0ZXJFcnJvcihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIGVycihlcnJvci5jYXVzZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBpZCA9IHJlZ2lzdHJ5LnJlZ2lzdGVyTmV3RXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGVycih7IGtpbmQ6IFwiR2VuZXJpY0pzXCIsIGlkIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2NvbnN0LnRzXG52YXIgQ29sdW1uVHlwZUVudW0gPSB7XG4gIC8vIFNjYWxhcnNcbiAgSW50MzI6IDAsXG4gIEludDY0OiAxLFxuICBGbG9hdDogMixcbiAgRG91YmxlOiAzLFxuICBOdW1lcmljOiA0LFxuICBCb29sZWFuOiA1LFxuICBDaGFyYWN0ZXI6IDYsXG4gIFRleHQ6IDcsXG4gIERhdGU6IDgsXG4gIFRpbWU6IDksXG4gIERhdGVUaW1lOiAxMCxcbiAgSnNvbjogMTEsXG4gIEVudW06IDEyLFxuICBCeXRlczogMTMsXG4gIFNldDogMTQsXG4gIFV1aWQ6IDE1LFxuICAvLyBBcnJheXNcbiAgSW50MzJBcnJheTogNjQsXG4gIEludDY0QXJyYXk6IDY1LFxuICBGbG9hdEFycmF5OiA2NixcbiAgRG91YmxlQXJyYXk6IDY3LFxuICBOdW1lcmljQXJyYXk6IDY4LFxuICBCb29sZWFuQXJyYXk6IDY5LFxuICBDaGFyYWN0ZXJBcnJheTogNzAsXG4gIFRleHRBcnJheTogNzEsXG4gIERhdGVBcnJheTogNzIsXG4gIFRpbWVBcnJheTogNzMsXG4gIERhdGVUaW1lQXJyYXk6IDc0LFxuICBKc29uQXJyYXk6IDc1LFxuICBFbnVtQXJyYXk6IDc2LFxuICBCeXRlc0FycmF5OiA3NyxcbiAgVXVpZEFycmF5OiA3OCxcbiAgLy8gQ3VzdG9tXG4gIFVua25vd25OdW1iZXI6IDEyOFxufTtcblxuLy8gc3JjL21vY2sudHNcbnZhciBtb2NrQWRhcHRlckVycm9ycyA9IHtcbiAgcXVlcnlSYXc6IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZDogcXVlcnlSYXdcIiksXG4gIGV4ZWN1dGVSYXc6IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZDogZXhlY3V0ZVJhd1wiKSxcbiAgc3RhcnRUcmFuc2FjdGlvbjogbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkOiBzdGFydFRyYW5zYWN0aW9uXCIpLFxuICBleGVjdXRlU2NyaXB0OiBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQ6IGV4ZWN1dGVTY3JpcHRcIiksXG4gIGRpc3Bvc2U6IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZDogZGlzcG9zZVwiKVxufTtcbmZ1bmN0aW9uIG1vY2tBZGFwdGVyKHByb3ZpZGVyKSB7XG4gIHJldHVybiB7XG4gICAgcHJvdmlkZXIsXG4gICAgYWRhcHRlck5hbWU6IFwiQHByaXNtYS9hZGFwdGVyLW1vY2tcIixcbiAgICBxdWVyeVJhdzogKCkgPT4gUHJvbWlzZS5yZWplY3QobW9ja0FkYXB0ZXJFcnJvcnMucXVlcnlSYXcpLFxuICAgIGV4ZWN1dGVSYXc6ICgpID0+IFByb21pc2UucmVqZWN0KG1vY2tBZGFwdGVyRXJyb3JzLmV4ZWN1dGVSYXcpLFxuICAgIHN0YXJ0VHJhbnNhY3Rpb246ICgpID0+IFByb21pc2UucmVqZWN0KG1vY2tBZGFwdGVyRXJyb3JzLnN0YXJ0VHJhbnNhY3Rpb24pLFxuICAgIGV4ZWN1dGVTY3JpcHQ6ICgpID0+IFByb21pc2UucmVqZWN0KG1vY2tBZGFwdGVyRXJyb3JzLmV4ZWN1dGVTY3JpcHQpLFxuICAgIGRpc3Bvc2U6ICgpID0+IFByb21pc2UucmVqZWN0KG1vY2tBZGFwdGVyRXJyb3JzLmRpc3Bvc2UpLFxuICAgIFtTeW1ib2wuZm9yKFwiYWRhcHRlci5tb2NrQWRhcHRlclwiKV06IHRydWVcbiAgfTtcbn1cbmZ1bmN0aW9uIG1vY2tBZGFwdGVyRmFjdG9yeShwcm92aWRlcikge1xuICByZXR1cm4ge1xuICAgIHByb3ZpZGVyLFxuICAgIGFkYXB0ZXJOYW1lOiBcIkBwcmlzbWEvYWRhcHRlci1tb2NrXCIsXG4gICAgY29ubmVjdDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKG1vY2tBZGFwdGVyKHByb3ZpZGVyKSksXG4gICAgW1N5bWJvbC5mb3IoXCJhZGFwdGVyLm1vY2tBZGFwdGVyRmFjdG9yeVwiKV06IHRydWVcbiAgfTtcbn1cbmZ1bmN0aW9uIG1vY2tNaWdyYXRpb25Bd2FyZUFkYXB0ZXJGYWN0b3J5KHByb3ZpZGVyKSB7XG4gIHJldHVybiB7XG4gICAgcHJvdmlkZXIsXG4gICAgYWRhcHRlck5hbWU6IFwiQHByaXNtYS9hZGFwdGVyLW1vY2tcIixcbiAgICBjb25uZWN0OiAoKSA9PiBQcm9taXNlLnJlc29sdmUobW9ja0FkYXB0ZXIocHJvdmlkZXIpKSxcbiAgICBjb25uZWN0VG9TaGFkb3dEYjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKG1vY2tBZGFwdGVyKHByb3ZpZGVyKSksXG4gICAgW1N5bWJvbC5mb3IoXCJhZGFwdGVyLm1vY2tNaWdyYXRpb25Bd2FyZUFkYXB0ZXJGYWN0b3J5XCIpXTogdHJ1ZVxuICB9O1xufVxuZXhwb3J0IHtcbiAgQ29sdW1uVHlwZUVudW0sXG4gIERlYnVnLFxuICBEcml2ZXJBZGFwdGVyRXJyb3IsXG4gIGJpbmRBZGFwdGVyLFxuICBiaW5kTWlncmF0aW9uQXdhcmVTcWxBZGFwdGVyRmFjdG9yeSxcbiAgYmluZFNxbEFkYXB0ZXJGYWN0b3J5LFxuICBlcnIsXG4gIGlzRHJpdmVyQWRhcHRlckVycm9yLFxuICBtb2NrQWRhcHRlcixcbiAgbW9ja0FkYXB0ZXJFcnJvcnMsXG4gIG1vY2tBZGFwdGVyRmFjdG9yeSxcbiAgbW9ja01pZ3JhdGlvbkF3YXJlQWRhcHRlckZhY3RvcnksXG4gIG9rXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@prisma/driver-adapter-utils/dist/index.mjs\n");

/***/ })

};
;